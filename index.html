<!DOCTYPE html>
<html>
<head>
    <title>Merged HTML</title>
</head>
<body>
<html><head></head><body>
<div id="title">
 1. Two Sum
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of integers
   <code>
    nums
   </code>
   and an integer
   <code>
    target
   </code>
   , return
   <em>
    indices of the two numbers such that they add up to
    <code>
     target
    </code>
   </em>
   .
  </p>
  <p>
   You may assume that each input would have
   <strong>
    <em>
     exactly
    </em>
    one solution
   </strong>
   , and you may not use the
   <em>
    same
   </em>
   element twice.
  </p>
  <p>
   You can return the answer in any order.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,7,11,15], target = 9
<strong>Output:</strong> [0,1]
<strong>Output:</strong> Because nums[0] + nums[1] == 9, we return [0, 1].
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,2,4], target = 6
<strong>Output:</strong> [1,2]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,3], target = 6
<strong>Output:</strong> [0,1]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     2 &lt;= nums.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      9
     </sup>
     &lt;= nums[i] &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      9
     </sup>
     &lt;= target &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
   <li>
    <strong>
     Only one valid answer exists.
    </strong>
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow-up:
  </strong>
  Can you come up with an algorithm that is less than
  <code>
   O(n
   <sup>
    2
   </sup>
   )
  </code>
  time complexity?
 </div>
</div>
</body></html>
<!-- Solution for Question 1 -->
<pre>/*
 * @lc app=leetcode id=1 lang=cpp
 *
 * [1] Two Sum
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        map&lt;int,int&gt;m;
        for(int i=0; i&lt;nums.size();i++){
            if(m.find(target-nums[i])==m.end()){
                m[nums[i]]=i;
            }
            else{
                return {m[target-nums[i]],i};
            }
        }
        return {-1,-1};
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 2. Add Two Numbers
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given two
   <strong>
    non-empty
   </strong>
   linked lists representing two non-negative integers. The digits are stored in
   <strong>
    reverse order
   </strong>
   , and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
  </p>
  <p>
   You may assume the two numbers do not contain any leading zero, except the number 0 itself.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/addtwonumber1.jpg" style="width: 483px; height: 342px;"/>
  <pre><strong>Input:</strong> l1 = [2,4,3], l2 = [5,6,4]
<strong>Output:</strong> [7,0,8]
<strong>Explanation:</strong> 342 + 465 = 807.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> l1 = [0], l2 = [0]
<strong>Output:</strong> [0]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
<strong>Output:</strong> [8,9,9,9,0,0,0,1]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in each linked list is in the range
    <code>
     [1, 100]
    </code>
    .
   </li>
   <li>
    <code>
     0 &lt;= Node.val &lt;= 9
    </code>
   </li>
   <li>
    It is guaranteed that the list represents a number that does not have leading zeros.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 2 -->
<pre>/*
 * @lc app=leetcode id=2 lang=cpp
 *
 * [2] Add Two Numbers
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        if(l1==NULL &amp;&amp; l2==NULL )return NULL;
        if(l1==NULL) return l2;
        if(l2==NULL) return l1;

        int val=l1-&gt;val+l2-&gt;val;
        ListNode* node = new ListNode(val%10);
        node-&gt;next=addTwoNumbers(l1-&gt;next,l2-&gt;next);
        if(val&gt;=10){
            node-&gt;next=addTwoNumbers(node-&gt;next,new ListNode(1));
        }
        return node;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 3. Longest Substring Without Repeating Characters
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    s
   </code>
   , find the length of the
   <b>
    longest substring
   </b>
   without repeating characters.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "abcabcbb"
<strong>Output:</strong> 3
<strong>Explanation:</strong> The answer is "abc", with the length of 3.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "bbbbb"
<strong>Output:</strong> 1
<strong>Explanation:</strong> The answer is "b", with the length of 1.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "pwwkew"
<strong>Output:</strong> 3
<strong>Explanation:</strong> The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = ""
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= s.length &lt;= 5 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consists of English letters, digits, symbols and spaces.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 3 -->
<pre>/*
 * @lc app=leetcode id=3 lang=cpp
 *
 * [3] Longest Substring Without Repeating Characters
 */

// @lc code=start
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        vector&lt;int&gt;m(128,0);
        if(s.length()==1) return 1;
        int begin=0,end=0,counter=0,maxx=0;
        while(end&lt;s.length()){
            // check only increment counter until each character occurence is 1
            // by moving end
            if(m[s[end++]]++ &gt; 0) counter ++; //use and then increment
            while(counter&gt; 0){
                // decerement cunter until each character occurence is once
                // by moving begin
                if(m[s[begin++]]--&gt;1) counter --;
                maxx=max(maxx,end-begin);
            }
        }
        return max(maxx,end-begin);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 4. Median of Two Sorted Arrays
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two sorted arrays
   <code>
    nums1
   </code>
   and
   <code>
    nums2
   </code>
   of size
   <code>
    m
   </code>
   and
   <code>
    n
   </code>
   respectively, return
   <strong>
    the median
   </strong>
   of the two sorted arrays.
  </p>
  <p>
   The overall run time complexity should be
   <code>
    O(log (m+n))
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums1 = [1,3], nums2 = [2]
<strong>Output:</strong> 2.00000
<strong>Explanation:</strong> merged array = [1,2,3] and median is 2.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums1 = [1,2], nums2 = [3,4]
<strong>Output:</strong> 2.50000
<strong>Explanation:</strong> merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums1 = [0,0], nums2 = [0,0]
<strong>Output:</strong> 0.00000
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums1 = [], nums2 = [1]
<strong>Output:</strong> 1.00000
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums1 = [2], nums2 = []
<strong>Output:</strong> 2.00000
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     nums1.length == m
    </code>
   </li>
   <li>
    <code>
     nums2.length == n
    </code>
   </li>
   <li>
    <code>
     0 &lt;= m &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     0 &lt;= n &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m + n &lt;= 2000
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      6
     </sup>
     &lt;= nums1[i], nums2[i] &lt;= 10
     <sup>
      6
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 4 -->
<pre>/*
 * @lc app=leetcode id=4 lang=cpp
 *
 * [4] Median of Two Sorted Arrays
 */

// @lc code=start
class Solution {
public:
    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
    vector&lt;int&gt; a(nums1.size() + nums2.size());
    int m = 0, i = 0;
    while (i &lt; nums1.size()) {
        a[m] = nums1[i];
        i++;
        m++;
    }
    i = 0;
    while (i &lt; nums2.size()) {
        a[m] = nums2[i];
        m++;
        i++;
    }
    sort(a.begin(), a.end());
    int k = a.size() / 2;

    if (a.size() % 2 != 0) {
        return a[k];
    } else {
        double x = a[k - 1] + a[k];
        return x / 2.0;
    }
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 5. Longest Palindromic Substring
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    s
   </code>
   , return
   <em>
    the longest palindromic substring
   </em>
   in
   <code>
    s
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "babad"
<strong>Output:</strong> "bab"
<strong>Note:</strong> "aba" is also a valid answer.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "cbbd"
<strong>Output:</strong> "bb"
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "a"
<strong>Output:</strong> "a"
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "ac"
<strong>Output:</strong> "a"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consist of only digits and English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 5 -->
<pre>/*
 * @lc app=leetcode id=5 lang=cpp
 *
 * [5] Longest Palindromic Substring
 */

// @lc code=start
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.length();
        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0));
        string ans=&quot;&quot;;
        for(int i = 0; i &lt; n; i++){
            ans=s[i];
            dp[i][i] = 1;
        }
        for(int i = 0; i &lt; n; i++){
            if(s[i]==s[i+1]){
                dp[i][i+1]=1;
                ans=s.substr(i,2);
            }
        }
        for(int len = 1; len &lt; n; len++){
            for(int i = 0; i + len &lt; n; i++){
                int j = i + len;
                if(s[i] == s[j] &amp;&amp;  dp[i + 1][j - 1]){
                    dp[i][j]=1;
                    if(j-i+1&gt;ans.length()) ans=s.substr(i,j-i+1);
                }

            }
        }
        
        for(int i=0;i&lt;n;i++){
            for(int j = 0;j&lt;n;j++){
                cout&lt;&lt;dp[i][j]&lt;&lt;&#x27; &#x27;;
            }
            cout&lt;&lt;&#x27;\n&#x27;;
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 6. ZigZag Conversion
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   The string
   <code>
    "PAYPALISHIRING"
   </code>
   is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)
  </p>
  <pre>P   A   H   N
A P L S I I G
Y   I   R
</pre>
  <p>
   And then read line by line:
   <code>
    "PAHNAPLSIIGYIR"
   </code>
  </p>
  <p>
   Write the code that will take a string and make this conversion given a number of rows:
  </p>
  <pre>string convert(string s, int numRows);
</pre>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "PAYPALISHIRING", numRows = 3
<strong>Output:</strong> "PAHNAPLSIIGYIR"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "PAYPALISHIRING", numRows = 4
<strong>Output:</strong> "PINALSIGYAHRPI"
<strong>Explanation:</strong>
P     I    N
A   L S  I G
Y A   H R
P     I
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "A", numRows = 1
<strong>Output:</strong> "A"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consists of English letters (lower-case and upper-case),
    <code>
     ','
    </code>
    and
    <code>
     '.'
    </code>
    .
   </li>
   <li>
    <code>
     1 &lt;= numRows &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 6 -->
<pre>/*
 * @lc app=leetcode id=6 lang=cpp
 *
 * [6] Zigzag Conversion
 */

// @lc code=start
class Solution {
public:
    string convert(string s, int numRows) {
        if(numRows == 1 || s.length() == 1)
        {
            return s;
        }
        vector&lt;string&gt;a(numRows,&quot;&quot;);
        int place=0;
        int count=0;
        for(int i = 0; i &lt; s.length();i++)
        {
            a[place] =a[place]+s[i];
            if(count==0)
            {
            place++;
            if(place==numRows-1)
            {
                count=1;
            }
            }
            else
            {
                place--;
                if(place==0)
                {
                    count=0;
                }
            }
        }
        string ans=&quot;&quot;;
        for(int i = 0; i &lt; numRows; i++)
        {
            ans=ans+a[i];
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 7. Reverse Integer
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a signed 32-bit integer
   <code>
    x
   </code>
   , return
   <code>
    x
   </code>
   <em>
    with its digits reversed
   </em>
   . If reversing
   <code>
    x
   </code>
   causes the value to go outside the signed 32-bit integer range
   <code>
    [-2
    <sup>
     31
    </sup>
    , 2
    <sup>
     31
    </sup>
    - 1]
   </code>
   , then return
   <code>
    0
   </code>
   .
  </p>
  <p>
   <strong>
    Assume the environment does not allow you to store 64-bit integers (signed or unsigned).
   </strong>
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> x = 123
<strong>Output:</strong> 321
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> x = -123
<strong>Output:</strong> -321
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> x = 120
<strong>Output:</strong> 21
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> x = 0
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= x &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 7 -->
<pre>/*
 * @lc app=leetcode id=7 lang=cpp
 *
 * [7] Reverse Integer
 */

// @lc code=start
class Solution {
public:
    int reverse(int x) {

        int y=0;
        while(x){
            if(y&gt;INT_MAX/10 || y&lt;INT_MIN/10){
                return 0;
            }
            else{
                y=y*10 + x%10;
                x=x/10;
            }
        }
        return y;

    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 8. String to Integer (atoi)
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Implement the
   <code>
    myAtoi(string s)
   </code>
   function, which converts a string to a 32-bit signed integer (similar to C/C++'s
   <code>
    atoi
   </code>
   function).
  </p>
  <p>
   The algorithm for
   <code>
    myAtoi(string s)
   </code>
   is as follows:
  </p>
  <ol>
   <li>
    Read in and ignore any leading whitespace.
   </li>
   <li>
    Check if the next character (if not already at the end of the string) is
    <code>
     '-'
    </code>
    or
    <code>
     '+'
    </code>
    . Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.
   </li>
   <li>
    Read in next the characters until the next non-digit charcter or the end of the input is reached. The rest of the string is ignored.
   </li>
   <li>
    Convert these digits into an integer (i.e.
    <code>
     "123" -&gt; 123
    </code>
    ,
    <code>
     "0032" -&gt; 32
    </code>
    ). If no digits were read, then the integer is
    <code>
     0
    </code>
    . Change the sign as necessary (from step 2).
   </li>
   <li>
    If the integer is out of the 32-bit signed integer range
    <code>
     [-2
     <sup>
      31
     </sup>
     , 2
     <sup>
      31
     </sup>
     - 1]
    </code>
    , then clamp the integer so that it remains in the range. Specifically, integers less than
    <code>
     -2
     <sup>
      31
     </sup>
    </code>
    should be clamped to
    <code>
     -2
     <sup>
      31
     </sup>
    </code>
    , and integers greater than
    <code>
     2
     <sup>
      31
     </sup>
     - 1
    </code>
    should be clamped to
    <code>
     2
     <sup>
      31
     </sup>
     - 1
    </code>
    .
   </li>
   <li>
    Return the integer as the final result.
   </li>
  </ol>
  <p>
   <strong>
    Note:
   </strong>
  </p>
  <ul>
   <li>
    Only the space character
    <code>
     ' '
    </code>
    is considered a whitespace character.
   </li>
   <li>
    <strong>
     Do not ignore
    </strong>
    any characters other than the leading whitespace or the rest of the string after the digits.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "42"
<strong>Output:</strong> 42
<strong>Explanation:</strong> The underlined characters are what is read in, the caret is the current reader position.
Step 1: "42" (no characters read because there is no leading whitespace)
         ^
Step 2: "42" (no characters read because there is neither a '-' nor '+')
         ^
Step 3: "<u>42</u>" ("42" is read in)
           ^
The parsed integer is 42.
Since 42 is in the range [-2<sup>31</sup>, 2<sup>31</sup> - 1], the final result is 42.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "   -42"
<strong>Output:</strong> -42
<strong>Explanation:</strong>
Step 1: "<u>   </u>-42" (leading whitespace is read and ignored)
            ^
Step 2: "   <u>-</u>42" ('-' is read, so the result should be negative)
             ^
Step 3: "   -<u>42</u>" ("42" is read in)
               ^
The parsed integer is -42.
Since -42 is in the range [-2<sup>31</sup>, 2<sup>31</sup> - 1], the final result is -42.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "4193 with words"
<strong>Output:</strong> 4193
<strong>Explanation:</strong>
Step 1: "4193 with words" (no characters read because there is no leading whitespace)
         ^
Step 2: "4193 with words" (no characters read because there is neither a '-' nor '+')
         ^
Step 3: "<u>4193</u> with words" ("4193" is read in; reading stops because the next character is a non-digit)
             ^
The parsed integer is 4193.
Since 4193 is in the range [-2<sup>31</sup>, 2<sup>31</sup> - 1], the final result is 4193.
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "words and 987"
<strong>Output:</strong> 0
<strong>Explanation:
</strong>Step 1: "words and 987" (no characters read because there is no leading whitespace)
         ^
Step 2: "words and 987" (no characters read because there is neither a '-' nor '+')
         ^
Step 3: "words and 987" (reading stops immediately because there is a non-digit 'w')
         ^
The parsed integer is 0 because no digits were read.
Since 0 is in the range [-2<sup>31</sup>, 2<sup>31</sup> - 1], the final result is 0.
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "-91283472332"
<strong>Output:</strong> -2147483648
<strong>Explanation:
</strong>Step 1: "-91283472332" (no characters read because there is no leading whitespace)
         ^
Step 2: "<u>-</u>91283472332" ('-' is read, so the result should be negative)
          ^
Step 3: "-<u>91283472332</u>" ("91283472332" is read in)
                     ^
The parsed integer is -91283472332.
Since -91283472332 is less than the lower bound of the range [-2<sup>31</sup>, 2<sup>31</sup> - 1], the final result is clamped to -2<sup>31</sup> = -2147483648.<strong><span style="display: none;"> </span></strong>
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= s.length &lt;= 200
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consists of English letters (lower-case and upper-case), digits (
    <code>
     0-9
    </code>
    ),
    <code>
     ' '
    </code>
    ,
    <code>
     '+'
    </code>
    ,
    <code>
     '-'
    </code>
    , and
    <code>
     '.'
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 8 -->
<pre>/*
 * @lc app=leetcode id=8 lang=cpp
 *
 * [8] String to Integer (atoi)
 */

// @lc code=start
class Solution {
public:
    int myAtoi(string s) {
        int n = s.size();

        long long int ans=0;
        int neg=1;
        bool flag = true;

        for (int i = 0; i &lt; n; i++)
        {
            if(s[i] == &#x27; &#x27; &amp;&amp; flag){
                continue;
            }
            else if(s[i] == &#x27;-&#x27; &amp;&amp; flag){
                neg=-1;
                flag = false;
            }
            else if(s[i] == &#x27;+&#x27; &amp;&amp; flag){
                neg=1;
                flag = false;
            }
            else if(s[i]&gt;=&#x27;0&#x27; &amp;&amp; s[i]&lt;=&#x27;9&#x27;){
                ans=(ans*10) + s[i]-&#x27;0&#x27;;
                flag = false;
            }
            else{
                break;
            }
            if(neg*ans&gt;INT_MAX)return INT_MAX;
            else if(neg*ans&lt;INT_MIN) return INT_MIN;
        }
        return neg*ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 9. Palindrome Number
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer
   <code>
    x
   </code>
   , return
   <code>
    true
   </code>
   if
   <code>
    x
   </code>
   is palindrome integer.
  </p>
  <p>
   An integer is a
   <strong>
    palindrome
   </strong>
   when it reads the same backward as forward. For example,
   <code>
    121
   </code>
   is palindrome while
   <code>
    123
   </code>
   is not.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> x = 121
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> x = -121
<strong>Output:</strong> false
<strong>Explanation:</strong> From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> x = 10
<strong>Output:</strong> false
<strong>Explanation:</strong> Reads 01 from right to left. Therefore it is not a palindrome.
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> x = -101
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= x &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow up:
  </strong>
  Could you solve it without converting the integer to a string?
 </div>
</div>
</body></html>
<!-- Solution for Question 9 -->
<pre>/*
 * @lc app=leetcode id=9 lang=cpp
 *
 * [9] Palindrome Number
 */

// @lc code=start
class Solution {
public:
    bool isPalindrome(int x) {
       string t1=to_string(x);
       string t2=to_string(x);
       reverse(t2.begin(), t2.end());
       return t2==t1;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 10. Regular Expression Matching
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an input string
   <code>
    s
   </code>
   and a pattern
   <code>
    p
   </code>
   , implement regular expression matching with support for
   <code>
    '.'
   </code>
   and
   <code>
    '*'
   </code>
   where:
  </p>
  <ul>
   <li>
    <code>
     '.'
    </code>
    Matches any single character.​​​​
   </li>
   <li>
    <code>
     '*'
    </code>
    Matches zero or more of the preceding element.
   </li>
  </ul>
  <p>
   The matching should cover the
   <strong>
    entire
   </strong>
   input string (not partial).
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "aa", p = "a"
<strong>Output:</strong> false
<strong>Explanation:</strong> "a" does not match the entire string "aa".
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "aa", p = "a*"
<strong>Output:</strong> true
<strong>Explanation:</strong> '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "ab", p = ".*"
<strong>Output:</strong> true
<strong>Explanation:</strong> ".*" means "zero or more (*) of any character (.)".
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "aab", p = "c*a*b"
<strong>Output:</strong> true
<strong>Explanation:</strong> c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches "aab".
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "mississippi", p = "mis*is*p*."
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 20
    </code>
   </li>
   <li>
    <code>
     1 &lt;= p.length &lt;= 30
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    contains only lowercase English letters.
   </li>
   <li>
    <code>
     p
    </code>
    contains only lowercase English letters,
    <code>
     '.'
    </code>
    , and
    <code>
     '*'
    </code>
    .
   </li>
   <li>
    It is guaranteed for each appearance of the character
    <code>
     '*'
    </code>
    , there will be a previous valid character to match.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 10 -->
<pre>/*
 * @lc app=leetcode id=10 lang=cpp
 *
 * [10] Regular Expression Matching
 */

// @lc code=start
class Solution {
public:
    bool isMatch(string s, string p) {
        int m=s.length(),n=p.length();
        vector&lt;vector&lt;bool&gt;&gt;dp(m+1,vector&lt;bool&gt;(n+1,false));
        dp[0][0]=1;
        for(int i=1;i&lt;=m;i++){
            dp[i][0]=false;
        }
        for(int i=1;i&lt;=n;i++){
            if(p[i-1]==&#x27;*&#x27;){
                dp[0][i]=dp[0][i-2];
            }
            else{
                dp[0][i]=false;
            }
        }

        for(int i=1;i&lt;=m;i++){
            for(int j=1;j&lt;=n;j++){
                if(s[i-1]==p[j-1]||p[j-1]==&#x27;.&#x27;){
                    dp[i][j]=dp[i-1][j-1];
                }
                else if(p[j-1]==&#x27;*&#x27;){
                    if(dp[i][j-2]){
                        dp[i][j]=dp[i][j-2];
                    }
                    else if(p[j-2]==&#x27;.&#x27;||s[i-1]==p[j-2]){
                        dp[i][j]=dp[i-1][j];
                    }
                    else{
                        dp[i][j]=false;
                    }
                }
                else{
                    dp[i][j]=false;
                }
            }
        }
        for(auto y:dp){
            for(int x:y){
                cout&lt;&lt;x&lt;&lt;&#x27; &#x27;;
            }
            cout&lt;&lt;&#x27;\n&#x27;;
        }
        return dp[m][n];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 11. Container With Most Water
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given
   <code>
    n
   </code>
   non-negative integers
   <code>
    a
    <sub>
     1
    </sub>
    , a
    <sub>
     2
    </sub>
    , ..., a
    <sub>
     n
    </sub>
   </code>
   <sub>
   </sub>
   , where each represents a point at coordinate
   <code>
    (i, a
    <sub>
     i
    </sub>
    )
   </code>
   .
   <code>
    n
   </code>
   vertical lines are drawn such that the two endpoints of the line
   <code>
    i
   </code>
   is at
   <code>
    (i, a
    <sub>
     i
    </sub>
    )
   </code>
   and
   <code>
    (i, 0)
   </code>
   . Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.
  </p>
  <p>
   <strong>
    Notice
   </strong>
   that you may not slant the container.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/question_11.jpg" style="width: 600px; height: 287px;"/>
  <pre><strong>Input:</strong> height = [1,8,6,2,5,4,8,3,7]
<strong>Output:</strong> 49
<strong>Explanation:</strong> The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> height = [1,1]
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> height = [4,3,2,1,4]
<strong>Output:</strong> 16
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> height = [1,2,1]
<strong>Output:</strong> 2
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == height.length
    </code>
   </li>
   <li>
    <code>
     2 &lt;= n &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= height[i] &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 11 -->
<pre>/*
 * @lc app=leetcode id=11 lang=cpp
 *
 * [11] Container With Most Water
 */

// @lc code=start
class Solution {
public:
    int maxArea(vector&lt;int&gt;&amp; height) {
        int area=0;
        int i=0,j=height.size()-1;
        while(j&gt;i){
            cout&lt;&lt;i&lt;&lt;j&lt;&lt;&#x27;\n&#x27;;
            int h= min(height[i],height[j]);
            area = max(area,h*(j-i));
            while(h&gt;=height[i] &amp;&amp; j&gt;i){
                i++;
            }
            while(h&gt;=height[j] &amp;&amp; j&gt;i){
                j--;
            }
        }
        return area;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 12. Integer to Roman
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Roman numerals are represented by seven different symbols:
   <code>
    I
   </code>
   ,
   <code>
    V
   </code>
   ,
   <code>
    X
   </code>
   ,
   <code>
    L
   </code>
   ,
   <code>
    C
   </code>
   ,
   <code>
    D
   </code>
   and
   <code>
    M
   </code>
   .
  </p>
  <pre><strong>Symbol</strong>       <strong>Value</strong>
I             1
V             5
X             10
L             50
C             100
D             500
M             1000</pre>
  <p>
   For example,
   <code>
    2
   </code>
   is written as
   <code>
    II
   </code>
   in Roman numeral, just two one's added together.
   <code>
    12
   </code>
   is written as
   <code>
    XII
   </code>
   , which is simply
   <code>
    X + II
   </code>
   . The number
   <code>
    27
   </code>
   is written as
   <code>
    XXVII
   </code>
   , which is
   <code>
    XX + V + II
   </code>
   .
  </p>
  <p>
   Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not
   <code>
    IIII
   </code>
   . Instead, the number four is written as
   <code>
    IV
   </code>
   . Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as
   <code>
    IX
   </code>
   . There are six instances where subtraction is used:
  </p>
  <ul>
   <li>
    <code>
     I
    </code>
    can be placed before
    <code>
     V
    </code>
    (5) and
    <code>
     X
    </code>
    (10) to make 4 and 9.
   </li>
   <li>
    <code>
     X
    </code>
    can be placed before
    <code>
     L
    </code>
    (50) and
    <code>
     C
    </code>
    (100) to make 40 and 90.
   </li>
   <li>
    <code>
     C
    </code>
    can be placed before
    <code>
     D
    </code>
    (500) and
    <code>
     M
    </code>
    (1000) to make 400 and 900.
   </li>
  </ul>
  <p>
   Given an integer, convert it to a roman numeral.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = 3
<strong>Output:</strong> "III"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = 4
<strong>Output:</strong> "IV"
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = 9
<strong>Output:</strong> "IX"
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = 58
<strong>Output:</strong> "LVIII"
<strong>Explanation:</strong> L = 50, V = 5, III = 3.
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = 1994
<strong>Output:</strong> "MCMXCIV"
<strong>Explanation:</strong> M = 1000, CM = 900, XC = 90 and IV = 4.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= num &lt;= 3999
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 12 -->
<pre>/*
 * @lc app=leetcode id=12 lang=cpp
 *
 * [12] Integer to Roman
 */

// @lc code=start
class Solution {
public:
    string intToRoman(int num) {
    string a[4][10] = {{&quot;&quot;, &quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;, &quot;VIII&quot;, &quot;IX&quot;},
                           {&quot;&quot;, &quot;X&quot;, &quot;XX&quot;, &quot;XXX&quot;, &quot;XL&quot;, &quot;L&quot;, &quot;LX&quot;, &quot;LXX&quot;, &quot;LXXX&quot;, &quot;XC&quot;},
                           {&quot;&quot;, &quot;C&quot;, &quot;CC&quot;, &quot;CCC&quot;, &quot;CD&quot;, &quot;D&quot;, &quot;DC&quot;, &quot;DCC&quot;, &quot;DCCC&quot;, &quot;CM&quot;},
                           {&quot;&quot;, &quot;M&quot;, &quot;MM&quot;, &quot;MMM&quot;}
                          };
    string ans=&quot;&quot;;
    int count =0;
    while(num!=0)
    {
        int temp = num%10;
        ans=a[count++][temp]+ans;
        num=num/10;
    }
    return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 13. Roman to Integer
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Roman numerals are represented by seven different symbols:
   <code>
    I
   </code>
   ,
   <code>
    V
   </code>
   ,
   <code>
    X
   </code>
   ,
   <code>
    L
   </code>
   ,
   <code>
    C
   </code>
   ,
   <code>
    D
   </code>
   and
   <code>
    M
   </code>
   .
  </p>
  <pre><strong>Symbol</strong>       <strong>Value</strong>
I             1
V             5
X             10
L             50
C             100
D             500
M             1000</pre>
  <p>
   For example,
   <code>
    2
   </code>
   is written as
   <code>
    II
   </code>
   in Roman numeral, just two one's added together.
   <code>
    12
   </code>
   is written as
   <code>
    XII
   </code>
   , which is simply
   <code>
    X + II
   </code>
   . The number
   <code>
    27
   </code>
   is written as
   <code>
    XXVII
   </code>
   , which is
   <code>
    XX + V + II
   </code>
   .
  </p>
  <p>
   Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not
   <code>
    IIII
   </code>
   . Instead, the number four is written as
   <code>
    IV
   </code>
   . Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as
   <code>
    IX
   </code>
   . There are six instances where subtraction is used:
  </p>
  <ul>
   <li>
    <code>
     I
    </code>
    can be placed before
    <code>
     V
    </code>
    (5) and
    <code>
     X
    </code>
    (10) to make 4 and 9.
   </li>
   <li>
    <code>
     X
    </code>
    can be placed before
    <code>
     L
    </code>
    (50) and
    <code>
     C
    </code>
    (100) to make 40 and 90.
   </li>
   <li>
    <code>
     C
    </code>
    can be placed before
    <code>
     D
    </code>
    (500) and
    <code>
     M
    </code>
    (1000) to make 400 and 900.
   </li>
  </ul>
  <p>
   Given a roman numeral, convert it to an integer.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "III"
<strong>Output:</strong> 3
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "IV"
<strong>Output:</strong> 4
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "IX"
<strong>Output:</strong> 9
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "LVIII"
<strong>Output:</strong> 58
<strong>Explanation:</strong> L = 50, V= 5, III = 3.
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "MCMXCIV"
<strong>Output:</strong> 1994
<strong>Explanation:</strong> M = 1000, CM = 900, XC = 90 and IV = 4.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 15
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    contains only the characters
    <code>
     ('I', 'V', 'X', 'L', 'C', 'D', 'M')
    </code>
    .
   </li>
   <li>
    It is
    <strong>
     guaranteed
    </strong>
    that
    <code>
     s
    </code>
    is a valid roman numeral in the range
    <code>
     [1, 3999]
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 13 -->
<pre>/*
 * @lc app=leetcode id=13 lang=cpp
 *
 * [13] Roman to Integer
 */

// @lc code=start
class Solution {
public:
    int romanToInt(string s) {
        map&lt;char,int&gt;m= {{&#x27;I&#x27;,1},{&#x27;V&#x27;,5},{&#x27;X&#x27;,10},{&#x27;L&#x27;,50},{&#x27;C&#x27;,100},{&#x27;D&#x27;,500},{&#x27;M&#x27;,1000}};
        int ans=m[s.back()];
        for(int i=0;i&lt;s.size()-1;i++)
        {
            if(m[s[i+1]]&gt;m[s[i]])
            {
                ans=ans-m[s[i]];
            }
            else
            {
                ans=ans+m[s[i]];
            }
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 14. Longest Common Prefix
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Write a function to find the longest common prefix string amongst an array of strings.
  </p>
  <p>
   If there is no common prefix, return an empty string
   <code>
    ""
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> strs = ["flower","flow","flight"]
<strong>Output:</strong> "fl"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> strs = ["dog","racecar","car"]
<strong>Output:</strong> ""
<strong>Explanation:</strong> There is no common prefix among the input strings.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= strs.length &lt;= 200
    </code>
   </li>
   <li>
    <code>
     0 &lt;= strs[i].length &lt;= 200
    </code>
   </li>
   <li>
    <code>
     strs[i]
    </code>
    consists of only lower-case English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 14 -->
<pre>/*
 * @lc app=leetcode id=14 lang=cpp
 *
 * [14] Longest Common Prefix
 */

// @lc code=start
class Solution {
public:
    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {
        sort(strs.begin(), strs.end());
        string s1=strs[0];
        string ans=&quot;&quot;;
        string s2=strs[strs.size()-1];
        for(int i=0; i&lt;s1.size(); i++){
            if(s1[i]==s2[i]){
                ans=ans+s1[i];
            }
            else break;
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 15. 3Sum
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array nums, return all the triplets
   <code>
    [nums[i], nums[j], nums[k]]
   </code>
   such that
   <code>
    i != j
   </code>
   ,
   <code>
    i != k
   </code>
   , and
   <code>
    j != k
   </code>
   , and
   <code>
    nums[i] + nums[j] + nums[k] == 0
   </code>
   .
  </p>
  <p>
   Notice that the solution set must not contain duplicate triplets.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [-1,0,1,2,-1,-4]
<strong>Output:</strong> [[-1,-1,2],[-1,0,1]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = []
<strong>Output:</strong> []
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [0]
<strong>Output:</strong> []
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= nums.length &lt;= 3000
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      5
     </sup>
     &lt;= nums[i] &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 15 -->
<pre>/*
 * @lc app=leetcode id=15 lang=cpp
 *
 * [15] 3Sum
 */

// @lc code=start
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());
        vector&lt;vector&lt;int&gt;&gt;ans;
        for(int i = 0; i &lt; nums.size();i++){
            int target=nums[i];
            int start= i+1;
            int end = nums.size()-1;
            while(start&lt;end){
                if(nums[start]+nums[end]+target==0){
                    ans.push_back({nums[start],nums[end],target});
                    int x=nums[start];
                    while(start&lt;end &amp;&amp; x==nums[start]){
                        start++;
                    }
                    x=nums[end];
                    while(start&lt;end &amp;&amp; x==nums[end]){
                        end--;
                    }
                }
                else if(nums[start]+nums[end]+target&gt;0){
                    end--;
                }
                else if(nums[start]+nums[end]+target&lt;0){
                    start++;
                }
            }
            while(i+1&lt;end &amp;&amp; nums[i]==nums[i+1] ){
                i++;
            }
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 16. 3Sum Closest
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   of length
   <code>
    n
   </code>
   and an integer
   <code>
    target
   </code>
   , find three integers in
   <code>
    nums
   </code>
   such that the sum is closest to
   <code>
    target
   </code>
   .
  </p>
  <p>
   Return
   <em>
    the sum of the three integers
   </em>
   .
  </p>
  <p>
   You may assume that each input would have exactly one solution.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [-1,2,1,-4], target = 1
<strong>Output:</strong> 2
<strong>Explanation:</strong> The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [0,0,0], target = 1
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     3 &lt;= nums.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     -1000 &lt;= nums[i] &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= target &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 16 -->
<pre>/*
 * @lc app=leetcode id=16 lang=cpp
 *
 * [16] 3Sum Closest
 */

// @lc code=start
class Solution {
public:
    int threeSumClosest(vector&lt;int&gt;&amp; nums, int total) {
        sort(nums.begin(), nums.end());
        int ans=nums[0]+nums[1]+nums[2];
        for(int i = 0; i &lt; nums.size();i++){
            int target=nums[i];
            int start=i+1;
            int end=nums.size()-1;
            while(start &lt; end ){
                int sum=nums[start]+nums[end]+target;
                if(sum==total)
                {
                    return sum;
                }
                if(abs(ans-total)&gt;abs(sum-total)) ans=sum;
                else if(sum&gt;total)
                {
                    end--;
                }
                else if(sum&lt;total)
                {
                    start++;
                }
            }
            while(i+1&lt;end &amp;&amp; nums[i]==nums[i+1])
            {
                i++;
            }
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 17. Letter Combinations of a Phone Number
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string containing digits from
   <code>
    2-9
   </code>
   inclusive, return all possible letter combinations that the number could represent. Return the answer in
   <strong>
    any order
   </strong>
   .
  </p>
  <p>
   A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
  </p>
  <p>
   <img src="./output_files/200px-Telephone-keypad2.svg.png" style="width: 200px; height: 162px;"/>
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> digits = "23"
<strong>Output:</strong> ["ad","ae","af","bd","be","bf","cd","ce","cf"]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> digits = ""
<strong>Output:</strong> []
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> digits = "2"
<strong>Output:</strong> ["a","b","c"]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= digits.length &lt;= 4
    </code>
   </li>
   <li>
    <code>
     digits[i]
    </code>
    is a digit in the range
    <code>
     ['2', '9']
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 17 -->
<pre>/*
 * @lc app=leetcode id=17 lang=cpp
 *
 * [17] Letter Combinations of a Phone Number
 */

// @lc code=start
class Solution {
public:
    vector&lt;string&gt; a{&quot; &quot;,&quot; &quot;,&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;,&quot;jkl&quot;,&quot;mno&quot;,&quot;pqrs&quot;,&quot;tuv&quot;,&quot;wxyz&quot;};
    vector&lt;string&gt; b;
    void ans(string digits,int index,string c)
    {
         if(index&gt;=digits.size())
         {
             b.push_back(c);
             return;
         }
         for(int i=0;i&lt;a[digits[index]-&#x27;0&#x27;].length();i++)
         {
             c=c+a[digits[index]-&#x27;0&#x27;][i];
             ans(digits,index+1,c);
             c=c.substr(0,c.length()-1);
         }
    }
    
    vector&lt;string&gt; letterCombinations(string digits) {
        int index=0;
        if(digits==&quot;&quot;)
        {
            return {};
        }
        ans(digits,index,&quot;&quot;);
        return b;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 18. 4Sum
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array
   <code>
    nums
   </code>
   of
   <code>
    n
   </code>
   integers, return
   <em>
    an array of all the
    <strong>
     unique
    </strong>
    quadruplets
   </em>
   <code>
    [nums[a], nums[b], nums[c], nums[d]]
   </code>
   such that:
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= a, b, c, d &lt; n
    </code>
   </li>
   <li>
    <code>
     a
    </code>
    ,
    <code>
     b
    </code>
    ,
    <code>
     c
    </code>
    , and
    <code>
     d
    </code>
    are
    <strong>
     distinct
    </strong>
    .
   </li>
   <li>
    <code>
     nums[a] + nums[b] + nums[c] + nums[d] == target
    </code>
   </li>
  </ul>
  <p>
   You may return the answer in
   <strong>
    any order
   </strong>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,0,-1,0,-2,2], target = 0
<strong>Output:</strong> [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,2,2,2,2], target = 8
<strong>Output:</strong> [[2,2,2,2]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 200
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      9
     </sup>
     &lt;= nums[i] &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      9
     </sup>
     &lt;= target &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 18 -->
<pre>/*
 * @lc app=leetcode id=18 lang=cpp
 *
 * [18] 4Sum
 */

// @lc code=start
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int total) {
        sort(nums.begin(), nums.end());
        vector&lt;vector&lt;int&gt;&gt;ans;
        if(nums.size()&lt;4) return ans;
        for(int k=0;k&lt;nums.size();k++){
            int initial = nums[k];
            for(int i = k+1; i &lt; nums.size();i++){
                int target=nums[i];
                int start=i+1;
                int end=nums.size()-1;
                while(start &lt; end ){
                    int sum1=nums[start]+nums[end];
                    int sum2=target+initial;
                    long long sum3=(long long) sum1+ (long long) sum2;
                    if(sum3==total){
                        ans.push_back({target,nums[start],nums[end],initial});
                        int x=nums[start];
                        while(start &lt; end &amp;&amp; x==nums[start])
                        start++;
                        x=nums[end];
                        while(start &lt; end &amp;&amp; x==nums[end])
                        end--;
                    }
                    else if(sum3&gt;total){
                        end--;
                    }
                    else if(sum3&lt;total){
                        start++;
                    }
                }
                while(i+1&lt;end &amp;&amp; nums[i]==nums[i+1]){
                    i++;
                }
            }
                while(k+1&lt;nums.size() &amp;&amp; nums[k]==nums[k+1]){
                    k++;
                }
            }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 19. Remove Nth Node From End of List
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    head
   </code>
   of a linked list, remove the
   <code>
    n
    <sup>
     th
    </sup>
   </code>
   node from the end of the list and return its head.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/remove_ex1.jpg" style="width: 542px; height: 222px;"/>
  <pre><strong>Input:</strong> head = [1,2,3,4,5], n = 2
<strong>Output:</strong> [1,2,3,5]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> head = [1], n = 1
<strong>Output:</strong> []
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> head = [1,2], n = 1
<strong>Output:</strong> [1]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the list is
    <code>
     sz
    </code>
    .
   </li>
   <li>
    <code>
     1 &lt;= sz &lt;= 30
    </code>
   </li>
   <li>
    <code>
     0 &lt;= Node.val &lt;= 100
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= sz
    </code>
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   Could you do this in one pass?
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 19 -->
<pre>/*
 * @lc app=leetcode id=19 lang=cpp
 *
 * [19] Remove Nth Node From End of List
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode *fast=head,*slow=head;
        for(int i=0; i&lt;n; i++)
        {
            fast=fast-&gt;next;
        }
        if(fast==nullptr)
        {
            head=head-&gt;next;
            return head;
        }
        while(fast-&gt;next!=NULL)
        {
            fast=fast-&gt;next;
            slow=slow-&gt;next;
        }
        slow-&gt;next=slow-&gt;next-&gt;next;
        return head;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 20. Valid Parentheses
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    s
   </code>
   containing just the characters
   <code>
    '('
   </code>
   ,
   <code>
    ')'
   </code>
   ,
   <code>
    '{'
   </code>
   ,
   <code>
    '}'
   </code>
   ,
   <code>
    '['
   </code>
   and
   <code>
    ']'
   </code>
   , determine if the input string is valid.
  </p>
  <p>
   An input string is valid if:
  </p>
  <ol>
   <li>
    Open brackets must be closed by the same type of brackets.
   </li>
   <li>
    Open brackets must be closed in the correct order.
   </li>
  </ol>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "()"
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "()[]{}"
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "(]"
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "([)]"
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "{[]}"
<strong>Output:</strong> true
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consists of parentheses only
    <code>
     '()[]{}'
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 20 -->
<pre>/*
 * @lc app=leetcode id=20 lang=cpp
 *
 * [20] Valid Parentheses
 */

// @lc code=start
class Solution {
public:
    bool isValid(string s) {
        stack&lt;char&gt;a;
        for(int i = 0; i &lt; s.length(); i++) {
            if(!a.empty() &amp;&amp; ((a.top()==&#x27;(&#x27; &amp;&amp; s[i]==&#x27;)&#x27;) ||(a.top()==&#x27;[&#x27; &amp;&amp; s[i]==&#x27;]&#x27;) ||(a.top()==&#x27;{&#x27; &amp;&amp; s[i]==&#x27;}&#x27;)))
            {
                a.pop();
            }
            else
            a.push(s[i]);
        }
        if(a.empty()) return true;
        return false;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 21. Merge Two Sorted Lists
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Merge two sorted linked lists and return it as a
   <strong>
    sorted
   </strong>
   list. The list should be made by splicing together the nodes of the first two lists.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/merge_ex1.jpg" style="width: 662px; height: 302px;"/>
  <pre><strong>Input:</strong> l1 = [1,2,4], l2 = [1,3,4]
<strong>Output:</strong> [1,1,2,3,4,4]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> l1 = [], l2 = []
<strong>Output:</strong> []
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> l1 = [], l2 = [0]
<strong>Output:</strong> [0]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in both lists is in the range
    <code>
     [0, 50]
    </code>
    .
   </li>
   <li>
    <code>
     -100 &lt;= Node.val &lt;= 100
    </code>
   </li>
   <li>
    Both
    <code>
     l1
    </code>
    and
    <code>
     l2
    </code>
    are sorted in
    <strong>
     non-decreasing
    </strong>
    order.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 21 -->
<pre>/*
 * @lc app=leetcode id=21 lang=cpp
 *
 * [21] Merge Two Sorted Lists
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
       if(l1==NULL &amp;&amp; l2==NULL) return NULL;
       if(l1==NULL ) return l2;
       if(l2==NULL ) return l1;
       ListNode * node;
       if(l1-&gt;val&gt;l2-&gt;val){
            node = new ListNode(l2-&gt;val);
            node-&gt;next=mergeTwoLists(l1,l2-&gt;next);
       }
       else{
            node = new ListNode(l1-&gt;val);
            node-&gt;next=mergeTwoLists(l1-&gt;next,l2);
       }
       return node;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 22. Generate Parentheses
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given
   <code>
    n
   </code>
   pairs of parentheses, write a function to
   <em>
    generate all combinations of well-formed parentheses
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 3
<strong>Output:</strong> ["((()))","(()())","(())()","()(())","()()()"]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1
<strong>Output:</strong> ["()"]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 8
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 22 -->
<pre>/*
 * @lc app=leetcode id=22 lang=cpp
 *
 * [22] Generate Parentheses
 */

// @lc code=start
class Solution {
public:
    void generate(vector&lt;string&gt;&amp;ans,string s,int open,int close) {
        if(open==0 &amp;&amp; close==0)
        {
            ans.push_back(s);
            return;
        }
        if(open&lt;0 || close&lt;0)
        {
            return;
        }
        if(open&lt;=close)
        generate(ans,s+&quot;(&quot;,open-1,close);
        generate(ans,s+&quot;)&quot;,open,close-1);

    }
    vector&lt;string&gt; generateParenthesis(int n) {
        vector&lt;string&gt;ans;
        string s=&quot;&quot;;
        generate(ans,s,n,n);
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 23. Merge k Sorted Lists
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an array of
   <code>
    k
   </code>
   linked-lists
   <code>
    lists
   </code>
   , each linked-list is sorted in ascending order.
  </p>
  <p>
   <em>
    Merge all the linked-lists into one sorted linked-list and return it.
   </em>
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> lists = [[1,4,5],[1,3,4],[2,6]]
<strong>Output:</strong> [1,1,2,3,4,4,5,6]
<strong>Explanation:</strong> The linked-lists are:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
merging them into one sorted list:
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> lists = []
<strong>Output:</strong> []
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> lists = [[]]
<strong>Output:</strong> []
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     k == lists.length
    </code>
   </li>
   <li>
    <code>
     0 &lt;= k &lt;= 10^4
    </code>
   </li>
   <li>
    <code>
     0 &lt;= lists[i].length &lt;= 500
    </code>
   </li>
   <li>
    <code>
     -10^4 &lt;= lists[i][j] &lt;= 10^4
    </code>
   </li>
   <li>
    <code>
     lists[i]
    </code>
    is sorted in
    <strong>
     ascending order
    </strong>
    .
   </li>
   <li>
    The sum of
    <code>
     lists[i].length
    </code>
    won't exceed
    <code>
     10^4
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 23 -->
<pre>/*
 * @lc app=leetcode id=23 lang=cpp
 *
 * [23] Merge k Sorted Lists
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) {
        if(lists.size() == 0) return NULL;
        vector&lt;int&gt;ans;
        cout&lt;&lt;lists.size();
        for(int i = 0; i &lt; lists.size();i++){
            if(lists[i]!=NULL){
            ListNode *temp= lists[i];
            while(temp!=NULL){
                ans.insert(lower_bound(ans.begin(),ans.end(),temp-&gt;val),temp-&gt;val);
                temp=temp-&gt;next;
            }
            }
        }
        if(ans.size()==0) return NULL;
        ListNode *head=new ListNode(ans[0]);
        ListNode *temp = head;

        for (int i = 1; i &lt; ans.size(); i++) {
            temp-&gt;next = new ListNode(ans[i]);
            temp = temp-&gt;next;
        }

        return head;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 24. Swap Nodes in Pairs
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/swap_ex1.jpg" style="width: 422px; height: 222px;"/>
  <pre><strong>Input:</strong> head = [1,2,3,4]
<strong>Output:</strong> [2,1,4,3]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> head = []
<strong>Output:</strong> []
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> head = [1]
<strong>Output:</strong> [1]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the list is in the range
    <code>
     [0, 100]
    </code>
    .
   </li>
   <li>
    <code>
     0 &lt;= Node.val &lt;= 100
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 24 -->
<pre>/*
 * @lc app=leetcode id=24 lang=cpp
 *
 * [24] Swap Nodes in Pairs
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head!=NULL &amp;&amp; head-&gt;next!=NULL){
            swap(head-&gt;val, head-&gt;next-&gt;val);
            head-&gt;next-&gt;next= swapPairs(head-&gt;next-&gt;next);
        }
        return head;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 25. Reverse Nodes in k-Group
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a linked list, reverse the nodes of a linked list
   <em>
    k
   </em>
   at a time and return its modified list.
  </p>
  <p>
   <em>
    k
   </em>
   is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of
   <em>
    k
   </em>
   then left-out nodes, in the end, should remain as it is.
  </p>
  <p>
   You may not alter the values in the list's nodes, only nodes themselves may be changed.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/reverse_ex1.jpg" style="width: 542px; height: 222px;"/>
  <pre><strong>Input:</strong> head = [1,2,3,4,5], k = 2
<strong>Output:</strong> [2,1,4,3,5]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/reverse_ex2.jpg" style="width: 542px; height: 222px;"/>
  <pre><strong>Input:</strong> head = [1,2,3,4,5], k = 3
<strong>Output:</strong> [3,2,1,4,5]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> head = [1,2,3,4,5], k = 1
<strong>Output:</strong> [1,2,3,4,5]
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> head = [1], k = 1
<strong>Output:</strong> [1]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the list is in the range
    <code>
     sz
    </code>
    .
   </li>
   <li>
    <code>
     1 &lt;= sz &lt;= 5000
    </code>
   </li>
   <li>
    <code>
     0 &lt;= Node.val &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     1 &lt;= k &lt;= sz
    </code>
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow-up:
  </strong>
  Can you solve the problem in O(1) extra memory space?
 </div>
</div>
</body></html>
<!-- Solution for Question 25 -->
<pre>/*
 * @lc app=leetcode id=25 lang=cpp
 *
 * [25] Reverse Nodes in k-Group
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt;a;
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode*temp=head;
        while(temp!=NULL){
            a.push_back(temp-&gt;val);
            temp=temp-&gt;next;
        }
        temp=head;
        int i=0;
        while(i+k&lt;=a.size()){
            reverse(a.begin()+i, a.begin()+k+i);
            i=i+k;
        }
        i=0;
        while(temp!=NULL){
            temp-&gt;val=a[i++];
            temp=temp-&gt;next;
        }
        return head;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 26. Remove Duplicates from Sorted Array
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   sorted in
   <strong>
    non-decreasing order
   </strong>
   , remove the duplicates
   <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">
    <strong>
     in-place
    </strong>
   </a>
   such that each unique element appears only
   <strong>
    once
   </strong>
   . The
   <strong>
    relative order
   </strong>
   of the elements should be kept the
   <strong>
    same
   </strong>
   .
  </p>
  <p>
   Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the
   <strong>
    first part
   </strong>
   of the array
   <code>
    nums
   </code>
   . More formally, if there are
   <code>
    k
   </code>
   elements after removing the duplicates, then the first
   <code>
    k
   </code>
   elements of
   <code>
    nums
   </code>
   should hold the final result. It does not matter what you leave beyond the first
   <code>
    k
   </code>
   elements.
  </p>
  <p>
   Return
   <code>
    k
   </code>
   <em>
    after placing the final result in the first
   </em>
   <code>
    k
   </code>
   <em>
    slots of
   </em>
   <code>
    nums
   </code>
   .
  </p>
  <p>
   Do
   <strong>
    not
   </strong>
   allocate extra space for another array. You must do this by
   <strong>
    modifying the input array
    <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">
     in-place
    </a>
   </strong>
   with O(1) extra memory.
  </p>
  <p>
   <strong>
    Custom Judge:
   </strong>
  </p>
  <p>
   The judge will test your solution with the following code:
  </p>
  <pre>int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i &lt; k; i++) {
    assert nums[i] == expectedNums[i];
}
</pre>
  <p>
   If all assertions pass, then your solution will be
   <strong>
    accepted
   </strong>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,1,2]
<strong>Output:</strong> 2, nums = [1,2,_]
<strong>Explanation:</strong> Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [0,0,1,1,1,2,2,3,3,4]
<strong>Output:</strong> 5, nums = [0,1,2,3,4,_,_,_,_,_]
<strong>Explanation:</strong> Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= nums.length &lt;= 3 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -100 &lt;= nums[i] &lt;= 100
    </code>
   </li>
   <li>
    <code>
     nums
    </code>
    is sorted in
    <strong>
     non-decreasing
    </strong>
    order.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 26 -->
<pre>/*
 * @lc app=leetcode id=26 lang=cpp
 *
 * [26] Remove Duplicates from Sorted Array
 */

// @lc code=start
class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int i = 1;
        for(int x:nums)
        {
            if(x&gt;nums[i-1])
            {
                nums[i++]=x;
            }
        }
        return i;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 27. Remove Element
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   and an integer
   <code>
    val
   </code>
   , remove all occurrences of
   <code>
    val
   </code>
   in
   <code>
    nums
   </code>
   <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">
    <strong>
     in-place
    </strong>
   </a>
   . The relative order of the elements may be changed.
  </p>
  <p>
   Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the
   <strong>
    first part
   </strong>
   of the array
   <code>
    nums
   </code>
   . More formally, if there are
   <code>
    k
   </code>
   elements after removing the duplicates, then the first
   <code>
    k
   </code>
   elements of
   <code>
    nums
   </code>
   should hold the final result. It does not matter what you leave beyond the first
   <code>
    k
   </code>
   elements.
  </p>
  <p>
   Return
   <code>
    k
   </code>
   <em>
    after placing the final result in the first
   </em>
   <code>
    k
   </code>
   <em>
    slots of
   </em>
   <code>
    nums
   </code>
   .
  </p>
  <p>
   Do
   <strong>
    not
   </strong>
   allocate extra space for another array. You must do this by
   <strong>
    modifying the input array
    <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">
     in-place
    </a>
   </strong>
   with O(1) extra memory.
  </p>
  <p>
   <strong>
    Custom Judge:
   </strong>
  </p>
  <p>
   The judge will test your solution with the following code:
  </p>
  <pre>int[] nums = [...]; // Input array
int val = ...; // Value to remove
int[] expectedNums = [...]; // The expected answer with correct length.
                            // It is sorted with no values equaling val.

int k = removeElement(nums, val); // Calls your implementation

assert k == expectedNums.length;
sort(nums, 0, k); // Sort the first k elements of nums
for (int i = 0; i &lt; actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
</pre>
  <p>
   If all assertions pass, then your solution will be
   <strong>
    accepted
   </strong>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,2,2,3], val = 3
<strong>Output:</strong> 2, nums = [2,2,_,_]
<strong>Explanation:</strong> Your function should return k = 2, with the first two elements of nums being 2.
It does not matter what you leave beyond the returned k (hence they are underscores).
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [0,1,2,2,3,0,4,2], val = 2
<strong>Output:</strong> 5, nums = [0,1,4,0,3,_,_,_]
<strong>Explanation:</strong> Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.
Note that the five elements can be returned in any order.
It does not matter what you leave beyond the returned k (hence they are underscores).
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= nums.length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     0 &lt;= nums[i] &lt;= 50
    </code>
   </li>
   <li>
    <code>
     0 &lt;= val &lt;= 100
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 27 -->
<pre>/*
 * @lc app=leetcode id=27 lang=cpp
 *
 * [27] Remove Element
 */

// @lc code=start
class Solution {
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) {
        int i=0;
        for(int x:nums)
        {
            if(x!=val)
            {
                nums[i++]=x;
            }
        }
        return i;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 28. Implement strStr()
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Implement
   <a href="http://www.cplusplus.com/reference/cstring/strstr/" target="_blank">
    strStr()
   </a>
   .
  </p>
  <p>
   Return the index of the first occurrence of needle in haystack, or
   <code>
    -1
   </code>
   if
   <code>
    needle
   </code>
   is not part of
   <code>
    haystack
   </code>
   .
  </p>
  <p>
   <strong>
    Clarification:
   </strong>
  </p>
  <p>
   What should we return when
   <code>
    needle
   </code>
   is an empty string? This is a great question to ask during an interview.
  </p>
  <p>
   For the purpose of this problem, we will return 0 when
   <code>
    needle
   </code>
   is an empty string. This is consistent to C's
   <a href="http://www.cplusplus.com/reference/cstring/strstr/" target="_blank">
    strstr()
   </a>
   and Java's
   <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)" target="_blank">
    indexOf()
   </a>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> haystack = "hello", needle = "ll"
<strong>Output:</strong> 2
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> haystack = "aaaaa", needle = "bba"
<strong>Output:</strong> -1
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> haystack = "", needle = ""
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= haystack.length, needle.length &lt;= 5 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     haystack
    </code>
    and
    <code>
     needle
    </code>
    consist of only lower-case English characters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 28 -->
<pre>/*
 * @lc app=leetcode id=28 lang=cpp
 *
 * [28] Find the Index of the First Occurrence in a String
 */

// @lc code=start
class Solution {
public:
    int strStr(string haystack, string needle) {
        int m=haystack.size();
        int n=needle.size();
        for(int i=0; i&lt;m-n+1; i++){
            if(haystack.substr(i,n)==needle){
                return i;
            }
        }
        return -1;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 29. Divide Two Integers
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two integers
   <code>
    dividend
   </code>
   and
   <code>
    divisor
   </code>
   , divide two integers without using multiplication, division, and mod operator.
  </p>
  <p>
   Return the quotient after dividing
   <code>
    dividend
   </code>
   by
   <code>
    divisor
   </code>
   .
  </p>
  <p>
   The integer division should truncate toward zero, which means losing its fractional part. For example,
   <code>
    truncate(8.345) = 8
   </code>
   and
   <code>
    truncate(-2.7335) = -2
   </code>
   .
  </p>
  <p>
   <strong>
    Note:
   </strong>
   Assume we are dealing with an environment that could only store integers within the
   <strong>
    32-bit
   </strong>
   signed integer range:
   <code>
    [−2
    <sup>
     31
    </sup>
    , 2
    <sup>
     31
    </sup>
    − 1]
   </code>
   . For this problem, assume that your function
   <strong>
    returns
   </strong>
   <code>
    2
    <sup>
     31
    </sup>
    − 1
   </code>
   <strong>
    when the division result overflows
   </strong>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> dividend = 10, divisor = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> 10/3 = truncate(3.33333..) = 3.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> dividend = 7, divisor = -3
<strong>Output:</strong> -2
<strong>Explanation:</strong> 7/-3 = truncate(-2.33333..) = -2.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> dividend = 0, divisor = 1
<strong>Output:</strong> 0
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> dividend = 1, divisor = 1
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= dividend, divisor &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
   <li>
    <code>
     divisor != 0
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 29 -->
<pre>/*
 * @lc app=leetcode id=29 lang=cpp
 *
 * [29] Divide Two Integers
 */

// @lc code=start
class Solution {
public:
    int divide(int dividend, int divisor) {
        if(dividend == INT_MAX &amp;&amp; divisor == INT_MIN) return 0;
        if(dividend==0) return 0;
        if(divisor==0) return INT_MAX;
        long long ans=double(exp(log(fabs(dividend))-log(fabs(divisor))))+0.00001;
        if((dividend&lt;0)^(divisor&lt;0)) ans=-ans;
        if(ans&gt;INT_MAX) return INT_MAX;
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 30. Substring with Concatenation of All Words
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given a string
   <code>
    s
   </code>
   and an array of strings
   <code>
    words
   </code>
   of
   <strong>
    the same length
   </strong>
   . Return all starting indices of substring(s) in
   <code>
    s
   </code>
   that is a concatenation of each word in
   <code>
    words
   </code>
   <strong>
    exactly once
   </strong>
   ,
   <strong>
    in any order
   </strong>
   , and
   <strong>
    without any intervening characters
   </strong>
   .
  </p>
  <p>
   You can return the answer in
   <strong>
    any order
   </strong>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "barfoothefoobarman", words = ["foo","bar"]
<strong>Output:</strong> [0,9]
<strong>Explanation:</strong> Substrings starting at index 0 and 9 are "barfoo" and "foobar" respectively.
The output order does not matter, returning [9,0] is fine too.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "wordgoodgoodgoodbestword", words = ["word","good","best","word"]
<strong>Output:</strong> []
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "barfoofoobarthefoobarman", words = ["bar","foo","the"]
<strong>Output:</strong> [6,9,12]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consists of lower-case English letters.
   </li>
   <li>
    <code>
     1 &lt;= words.length &lt;= 5000
    </code>
   </li>
   <li>
    <code>
     1 &lt;= words[i].length &lt;= 30
    </code>
   </li>
   <li>
    <code>
     words[i]
    </code>
    consists of lower-case English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 30 -->
<pre>/*
 * @lc app=leetcode id=30 lang=cpp
 *
 * [30] Substring with Concatenation of All Words
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 31. Next Permutation
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Implement
   <strong>
    next permutation
   </strong>
   , which rearranges numbers into the lexicographically next greater permutation of numbers.
  </p>
  <p>
   If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).
  </p>
  <p>
   The replacement must be
   <strong>
    <a href="http://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">
     in place
    </a>
   </strong>
   and use only constant extra memory.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> [1,3,2]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,2,1]
<strong>Output:</strong> [1,2,3]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,1,5]
<strong>Output:</strong> [1,5,1]
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1]
<strong>Output:</strong> [1]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     0 &lt;= nums[i] &lt;= 100
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 31 -->
<pre>/*
 * @lc app=leetcode id=31 lang=cpp
 *
 * [31] Next Permutation
 */

// @lc code=start
class Solution {
public:
    void nextPermutation(vector&lt;int&gt;&amp; a) {
        //find a element that is greater than the previous
        int n=a.size(),l,k;
        for(k=n-2;k&gt;=0;k--){
            if(a[k+1]&gt;a[k]){
                break;
            }
        }
        //else reverse
        if(k&lt;0){
            reverse(a.begin(),a.end());
        }
        //find a element that is greater than the element of k index
        else{
            for(l=n-1;l&gt;k;l--){
                if(a[l]&gt;a[k]) break;
            }
            //swap those element and reverse
            swap(a[k],a[l]);
            reverse(a.begin()+k+1,a.end());
        }
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 32. Longest Valid Parentheses
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string containing just the characters
   <code>
    '('
   </code>
   and
   <code>
    ')'
   </code>
   , find the length of the longest valid (well-formed) parentheses substring.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "(()"
<strong>Output:</strong> 2
<strong>Explanation:</strong> The longest valid parentheses substring is "()".
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = ")()())"
<strong>Output:</strong> 4
<strong>Explanation:</strong> The longest valid parentheses substring is "()()".
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = ""
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= s.length &lt;= 3 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     s[i]
    </code>
    is
    <code>
     '('
    </code>
    , or
    <code>
     ')'
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 32 -->
<pre>/*
 * @lc app=leetcode id=32 lang=cpp
 *
 * [32] Longest Valid Parentheses
 */

// @lc code=start
class Solution {
public:
    int longestValidParentheses(string s) {
        stack&lt;int&gt;q;
        int maxx=0,count;
        for(int i = 0; i &lt; s.length();i++){
            if(s[i] == &#x27;(&#x27;) q.push(i);
            else if(!q.empty()){
                s[q.top()] = &#x27;1&#x27;;
                s[i]=&#x27;1&#x27;;
                q.pop();
            }
        }
        cout&lt;&lt;s;
        for(int i = 0; i &lt; s.length();i++){
            if(s[i]!=&#x27;1&#x27;){
                maxx=max(maxx,count);
                count=0;
            }
            else{
                count++;
            }
        }
        return max(maxx,count);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 33. Search in Rotated Sorted Array
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   There is an integer array
   <code>
    nums
   </code>
   sorted in ascending order (with
   <strong>
    distinct
   </strong>
   values).
  </p>
  <p>
   Prior to being passed to your function,
   <code>
    nums
   </code>
   is
   <strong>
    rotated
   </strong>
   at an unknown pivot index
   <code>
    k
   </code>
   (
   <code>
    0 &lt;= k &lt; nums.length
   </code>
   ) such that the resulting array is
   <code>
    [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]
   </code>
   (
   <strong>
    0-indexed
   </strong>
   ). For example,
   <code>
    [0,1,2,4,5,6,7]
   </code>
   might be rotated at pivot index
   <code>
    3
   </code>
   and become
   <code>
    [4,5,6,7,0,1,2]
   </code>
   .
  </p>
  <p>
   Given the array
   <code>
    nums
   </code>
   <strong>
    after
   </strong>
   the rotation and an integer
   <code>
    target
   </code>
   , return
   <em>
    the index of
   </em>
   <code>
    target
   </code>
   <em>
    if it is in
   </em>
   <code>
    nums
   </code>
   <em>
    , or
   </em>
   <code>
    -1
   </code>
   <em>
    if it is not in
   </em>
   <code>
    nums
   </code>
   .
  </p>
  <p>
   You must write an algorithm with
   <code>
    O(log n)
   </code>
   runtime complexity.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 0
<strong>Output:</strong> 4
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2], target = 3
<strong>Output:</strong> -1
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1], target = 0
<strong>Output:</strong> -1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 5000
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= nums[i] &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    All values of
    <code>
     nums
    </code>
    are
    <strong>
     unique
    </strong>
    .
   </li>
   <li>
    <code>
     nums
    </code>
    is guaranteed to be rotated at some pivot.
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= target &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 33 -->
<pre>/*
 * @lc app=leetcode id=33 lang=cpp
 *
 * [33] Search in Rotated Sorted Array
 */

// @lc code=start
class Solution {
public:
    int search(vector&lt;int&gt;&amp; a, int target) {
        int start = 0, end=a.size()-1;
        while(start &lt;=  end)
        {
            int mid=(start+end)/2;
            if (target == a[mid]) return mid;
            if(a[start]&lt;= a[mid])
            {
            if(a[start] &lt;= target &amp;&amp; target &lt;= a[mid])
                end=mid-1;
            else
                start = mid+1;
            }
            else
            {
            if(a[mid] &lt;= target &amp;&amp; target &lt;= a[end])
                start = mid+1;
            else
                end= mid-1;
            }
            }
            return -1;
        }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 34. Find First and Last Position of Element in Sorted Array
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of integers
   <code>
    nums
   </code>
   sorted in ascending order, find the starting and ending position of a given
   <code>
    target
   </code>
   value.
  </p>
  <p>
   If
   <code>
    target
   </code>
   is not found in the array, return
   <code>
    [-1, -1]
   </code>
   .
  </p>
  <p>
   You must write an algorithm with
   <code>
    O(log n)
   </code>
   runtime complexity.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [5,7,7,8,8,10], target = 8
<strong>Output:</strong> [3,4]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [5,7,7,8,8,10], target = 6
<strong>Output:</strong> [-1,-1]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [], target = 0
<strong>Output:</strong> [-1,-1]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= nums.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      9
     </sup>
     &lt;= nums[i] &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
   <li>
    <code>
     nums
    </code>
    is a non-decreasing array.
   </li>
   <li>
    <code>
     -10
     <sup>
      9
     </sup>
     &lt;= target &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 34 -->
<pre>/*
 * @lc app=leetcode id=34 lang=cpp
 *
 * [34] Find First and Last Position of Element in Sorted Array
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; a, int target) {

    int start = 0 , end= a.size()-1;
    int left=-1,right=-1;
    while(start &lt;= end)
    {
        int mid=(start+end)/2;
        if(a[mid]&gt;target)
        {
            end=mid-1;
        }
        else if(a[mid]&lt;target)
        {
            start=mid+1;
        }
        else
        {
            left=mid;
            end=mid-1;
        }
    }

     start = 0 ;
     end= a.size()-1;
    while(start &lt;= end)
    {
        int mid=(start+end)/2;
        if(a[mid]&gt;target)
        {
            end=mid-1;
        }
        else if(a[mid]&lt;target)
        {
            start=mid+1;
        }
        else
        {
            right=mid;
            start=mid+1;
        }
    }
    return {left,right};
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 35. Search Insert Position
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
  </p>
  <p>
   You must write an algorithm with
   <code>
    O(log n)
   </code>
   runtime complexity.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,3,5,6], target = 5
<strong>Output:</strong> 2
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,3,5,6], target = 2
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,3,5,6], target = 7
<strong>Output:</strong> 4
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,3,5,6], target = 0
<strong>Output:</strong> 0
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1], target = 0
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= nums[i] &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     nums
    </code>
    contains
    <strong>
     distinct
    </strong>
    values sorted in
    <strong>
     ascending
    </strong>
    order.
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= target &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 35 -->
<pre>/*
 * @lc app=leetcode id=35 lang=cpp
 *
 * [35] Search Insert Position
 */

// @lc code=start
class Solution {
public:
    int searchInsert(vector&lt;int&gt;&amp; a, int target) {
        return lower_bound(a.begin(), a.end(), target) - a.begin();
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 36. Valid Sudoku
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Determine if a
   <code>
    9 x 9
   </code>
   Sudoku board is valid. Only the filled cells need to be validated
   <strong>
    according to the following rules
   </strong>
   :
  </p>
  <ol>
   <li>
    Each row must contain the digits
    <code>
     1-9
    </code>
    without repetition.
   </li>
   <li>
    Each column must contain the digits
    <code>
     1-9
    </code>
    without repetition.
   </li>
   <li>
    Each of the nine
    <code>
     3 x 3
    </code>
    sub-boxes of the grid must contain the digits
    <code>
     1-9
    </code>
    without repetition.
   </li>
  </ol>
  <p>
   <strong>
    Note:
   </strong>
  </p>
  <ul>
   <li>
    A Sudoku board (partially filled) could be valid but is not necessarily solvable.
   </li>
   <li>
    Only the filled cells need to be validated according to the mentioned rules.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img src="./output_files/Sudoku-by-L2G-20050714.svg.png" style="height:250px; width:250px"/>
  <pre><strong>Input:</strong> board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
<strong>Output:</strong> false
<strong>Explanation:</strong> Same as Example 1, except with the <strong>5</strong> in the top left corner being modified to <strong>8</strong>. Since there are two 8's in the top left 3x3 sub-box, it is invalid.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     board.length == 9
    </code>
   </li>
   <li>
    <code>
     board[i].length == 9
    </code>
   </li>
   <li>
    <code>
     board[i][j]
    </code>
    is a digit
    <code>
     1-9
    </code>
    or
    <code>
     '.'
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 36 -->
<pre>/*
 * @lc app=leetcode id=36 lang=cpp
 *
 * [36] Valid Sudoku
 */

// @lc code=start
class Solution {
public:
    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        int row[9][9]={0},col[9][9]={0},grid[9][9]={0};

        for(int i = 0; i &lt; 9;i++){
            for(int j = 0; j &lt; 9; j++){
                if(board[i][j]!=&#x27;.&#x27;){
                    int num = board[i][j]-&#x27;1&#x27;;
                    int grid_number= i/3*3 + j/3;
                    if(row[i][num] || col[j][num] || grid[grid_number][num]) return 0;
                    row[i][num] = col[j][num] = grid[grid_number][num] =1;
                }
            }
        }
        return 1;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 38. Count and Say
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   The
   <strong>
    count-and-say
   </strong>
   sequence is a sequence of digit strings defined by the recursive formula:
  </p>
  <ul>
   <li>
    <code>
     countAndSay(1) = "1"
    </code>
   </li>
   <li>
    <code>
     countAndSay(n)
    </code>
    is the way you would "say" the digit string from
    <code>
     countAndSay(n-1)
    </code>
    , which is then converted into a different digit string.
   </li>
  </ul>
  <p>
   To determine how you "say" a digit string, split it into the
   <strong>
    minimal
   </strong>
   number of groups so that each group is a contiguous section all of the
   <strong>
    same character.
   </strong>
   Then for each group, say the number of characters, then say the character. To convert the saying into a digit string, replace the counts with a number and concatenate every saying.
  </p>
  <p>
   For example, the saying and conversion for digit string
   <code>
    "3322251"
   </code>
   :
  </p>
  <img alt="" src="./output_files/countandsay.jpg" style="width: 581px; height: 172px;"/>
  <p>
   Given a positive integer
   <code>
    n
   </code>
   , return
   <em>
    the
   </em>
   <code>
    n
    <sup>
     th
    </sup>
   </code>
   <em>
    term of the
    <strong>
     count-and-say
    </strong>
    sequence
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1
<strong>Output:</strong> "1"
<strong>Explanation:</strong> This is the base case.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 4
<strong>Output:</strong> "1211"
<strong>Explanation:</strong>
countAndSay(1) = "1"
countAndSay(2) = say "1" = one 1 = "11"
countAndSay(3) = say "11" = two 1's = "21"
countAndSay(4) = say "21" = one 2 + one 1 = "12" + "11" = "1211"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 30
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 38 -->
<pre>/*
 * @lc app=leetcode id=38 lang=cpp
 *
 * [38] Count and Say
 */

// @lc code=start
class Solution {
public:
    string countAndSay(int n) {
        if(n==1)
        {
            return &quot;1&quot;;
        }
        if(n==2)
        {
            return &quot;11&quot;;
        }

        string temp = &quot;11&quot;;
        for(int i=2; i&lt;n; i++)
        {
            temp=temp+&quot;&amp;&quot;;
            string str=&quot;&quot;;
            int count = 1;
            for(int j=1;j&lt;temp.length();j++)
            {
                if(temp[j]!=temp[j-1])
                {
                    str=str+to_string(count)+temp[j-1];
                    count=1;
                }
                else
                {
                    count++;
                }
            }
            temp = str;
            //cout&lt;&lt;temp;
        }
        return temp;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 39. Combination Sum
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of
   <strong>
    distinct
   </strong>
   integers
   <code>
    candidates
   </code>
   and a target integer
   <code>
    target
   </code>
   , return
   <em>
    a list of all
    <strong>
     unique combinations
    </strong>
    of
   </em>
   <code>
    candidates
   </code>
   <em>
    where the chosen numbers sum to
   </em>
   <code>
    target
   </code>
   <em>
    .
   </em>
   You may return the combinations in
   <strong>
    any order
   </strong>
   .
  </p>
  <p>
   The
   <strong>
    same
   </strong>
   number may be chosen from
   <code>
    candidates
   </code>
   an
   <strong>
    unlimited number of times
   </strong>
   . Two combinations are unique if the frequency of at least one of the chosen numbers is different.
  </p>
  <p>
   It is
   <strong>
    guaranteed
   </strong>
   that the number of unique combinations that sum up to
   <code>
    target
   </code>
   is less than
   <code>
    150
   </code>
   combinations for the given input.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> candidates = [2,3,6,7], target = 7
<strong>Output:</strong> [[2,2,3],[7]]
<strong>Explanation:</strong>
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> candidates = [2,3,5], target = 8
<strong>Output:</strong> [[2,2,2,2],[2,3,3],[3,5]]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> candidates = [2], target = 1
<strong>Output:</strong> []
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> candidates = [1], target = 1
<strong>Output:</strong> [[1]]
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> candidates = [1], target = 2
<strong>Output:</strong> [[1,1]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= candidates.length &lt;= 30
    </code>
   </li>
   <li>
    <code>
     1 &lt;= candidates[i] &lt;= 200
    </code>
   </li>
   <li>
    All elements of
    <code>
     candidates
    </code>
    are
    <strong>
     distinct
    </strong>
    .
   </li>
   <li>
    <code>
     1 &lt;= target &lt;= 500
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 39 -->
<pre>/*
 * @lc app=leetcode id=39 lang=cpp
 *
 * [39] Combination Sum
 */

// @lc code=start
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt;a;
    void generate(vector&lt;int&gt;b,vector&lt;int&gt;&amp; candidates, int target,int i)
    {
        if(target == 0){
            a.push_back(b);
            return;
        }
        if(i==candidates.size() || target&lt;0) return;
        b.push_back(candidates[i]);
        generate(b,candidates,target-candidates[i],i);
        b.pop_back();
        generate(b,candidates,target,i+1);
    }
    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {
        vector&lt;int&gt;b;
        generate(b,candidates,target,0);
        return a;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 40. Combination Sum II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a collection of candidate numbers (
   <code>
    candidates
   </code>
   ) and a target number (
   <code>
    target
   </code>
   ), find all unique combinations in
   <code>
    candidates
   </code>
   where the candidate numbers sum to
   <code>
    target
   </code>
   .
  </p>
  <p>
   Each number in
   <code>
    candidates
   </code>
   may only be used
   <strong>
    once
   </strong>
   in the combination.
  </p>
  <p>
   <strong>
    Note:
   </strong>
   The solution set must not contain duplicate combinations.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> candidates = [10,1,2,7,6,1,5], target = 8
<strong>Output:</strong> 
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> candidates = [2,5,2,1,2], target = 5
<strong>Output:</strong> 
[
[1,2,2],
[5]
]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= candidates.length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     1 &lt;= candidates[i] &lt;= 50
    </code>
   </li>
   <li>
    <code>
     1 &lt;= target &lt;= 30
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 40 -->
<pre>/*
 * @lc app=leetcode id=40 lang=cpp
 *
 * [40] Combination Sum II
 */

// @lc code=start
class Solution {
public:
vector&lt;vector&lt;int&gt;&gt;a;
vector&lt;int&gt; b;
void ans(int i,int n,vector&lt;int&gt;&amp;candidates,int target)
{
    if(target==0)
    {
        a.push_back(b);
        return ;
    }
    if(i==n||target&lt;0)
    {
        return;
    }
    for(int j=i;j&lt;n;j++)
    {
        if(target-candidates[j]&lt;0)
        break;
        b.push_back(candidates[j]);
        ans(j+1,n,candidates,target-candidates[j]);
        b.pop_back();
        while (j + 1 &lt; n &amp;&amp; candidates[j] == candidates[j + 1]) j++;
    }
}
    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) {
        int i=0;
        int sum=0;
        int n=candidates.size();
        sort(candidates.begin(),candidates.end());
        ans(i,n,candidates,target);
        return a;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 41. First Missing Positive
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an unsorted integer array
   <code>
    nums
   </code>
   , return the smallest missing positive integer.
  </p>
  <p>
   You must implement an algorithm that runs in
   <code>
    O(n)
   </code>
   time and uses constant extra space.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,0]
<strong>Output:</strong> 3
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,4,-1,1]
<strong>Output:</strong> 2
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [7,8,9,11,12]
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 5 * 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= nums[i] &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 41 -->
<pre>/*
 * @lc app=leetcode id=41 lang=cpp
 *
 * [41] First Missing Positive
 */

// @lc code=start
class Solution {
public:
    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {
        int n=nums.size();
        unordered_map&lt;int,int&gt; m;

        for(auto num:nums){
            if(1&lt;=num &amp;&amp; num&lt;=n){

            m[num]++;
            }
        }

        for(int i=1;i&lt;=n;i++){
            if(m[i]==0){
                return i;
            }
        }
        return n+1;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 42. Trapping Rain Water
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given
   <code>
    n
   </code>
   non-negative integers representing an elevation map where the width of each bar is
   <code>
    1
   </code>
   , compute how much water it can trap after raining.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img src="./output_files/rainwatertrap.png" style="width: 412px; height: 161px;"/>
  <pre><strong>Input:</strong> height = [0,1,0,2,1,0,1,3,2,1,2,1]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> height = [4,2,0,3,2,5]
<strong>Output:</strong> 9
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == height.length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 2 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= height[i] &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 42 -->
<pre>/*
 * @lc app=leetcode id=42 lang=cpp
 *
 * [42] Trapping Rain Water
 */

// @lc code=start
class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int ans=0;
        if(height.size()==1)
        {
            return ans;
        }
        vector&lt;int&gt;left(height.size(),0);
        vector&lt;int&gt;right(height.size(),0);
        int n=height.size();
        left[0]=height[0];
        right[n-1]=height[n-1];
        //maxx from right and left
        for(int i=1;i&lt;n-1;i++)
        {
            left[i]=max(left[i-1],height[i]);
            right[n-i-1]=max(right[n-i],height[n-i-1 ]);
        }
        left[n-1]=max(left[n-2],height[n-1]);
        right[0]=max(right[1],height[0]);
        for(int i=0;i&lt;n;i++)
        {
            ans=ans+min(right[i],left[i])-height[i];
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 43. Multiply Strings
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two non-negative integers
   <code>
    num1
   </code>
   and
   <code>
    num2
   </code>
   represented as strings, return the product of
   <code>
    num1
   </code>
   and
   <code>
    num2
   </code>
   , also represented as a string.
  </p>
  <p>
   <strong>
    Note:
   </strong>
   You must not use any built-in BigInteger library or convert the inputs to integer directly.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> num1 = "2", num2 = "3"
<strong>Output:</strong> "6"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> num1 = "123", num2 = "456"
<strong>Output:</strong> "56088"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= num1.length, num2.length &lt;= 200
    </code>
   </li>
   <li>
    <code>
     num1
    </code>
    and
    <code>
     num2
    </code>
    consist of digits only.
   </li>
   <li>
    Both
    <code>
     num1
    </code>
    and
    <code>
     num2
    </code>
    do not contain any leading zero, except the number
    <code>
     0
    </code>
    itself.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 43 -->
<pre>/*
 * @lc app=leetcode id=43 lang=cpp
 *
 * [43] Multiply Strings
 */

// @lc code=start
class Solution {
public:
    string multiply(string num1, string num2) {
        if(num1==&quot;0&quot;|| num2==&quot;0&quot;) return &quot;0&quot;;
        vector&lt;int&gt;ans(num1.length()+num2.length(),0);
        for(int i=num1.length()-1; i&gt;=0;i--){
            for(int j=num2.length()-1; j&gt;=0;j--){
                ans[i+j+1]+=(num1[i]-&#x27;0&#x27;)*(num2[j]-&#x27;0&#x27;);
                ans[i+j]+=ans[i+j+1]/10;
                ans[i+j+1]=ans[i+j+1]%10;
            }
        }

        int i=0;
        string result=&quot;&quot;;
        while(ans[i]==0) i++;
        while(i&lt;ans.size()) result+=to_string(ans[i++]);
        return result;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 44. Wildcard Matching
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an input string (
   <code>
    s
   </code>
   ) and a pattern (
   <code>
    p
   </code>
   ), implement wildcard pattern matching with support for
   <code>
    '?'
   </code>
   and
   <code>
    '*'
   </code>
   where:
  </p>
  <ul>
   <li>
    <code>
     '?'
    </code>
    Matches any single character.
   </li>
   <li>
    <code>
     '*'
    </code>
    Matches any sequence of characters (including the empty sequence).
   </li>
  </ul>
  <p>
   The matching should cover the
   <strong>
    entire
   </strong>
   input string (not partial).
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "aa", p = "a"
<strong>Output:</strong> false
<strong>Explanation:</strong> "a" does not match the entire string "aa".
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "aa", p = "*"
<strong>Output:</strong> true
<strong>Explanation:</strong> '*' matches any sequence.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "cb", p = "?a"
<strong>Output:</strong> false
<strong>Explanation:</strong> '?' matches 'c', but the second letter is 'a', which does not match 'b'.
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "adceb", p = "*a*b"
<strong>Output:</strong> true
<strong>Explanation:</strong> The first '*' matches the empty sequence, while the second '*' matches the substring "dce".
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "acdcb", p = "a*c?b"
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= s.length, p.length &lt;= 2000
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    contains only lowercase English letters.
   </li>
   <li>
    <code>
     p
    </code>
    contains only lowercase English letters,
    <code>
     '?'
    </code>
    or
    <code>
     '*'
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 44 -->
<pre>/*
 * @lc app=leetcode id=44 lang=cpp
 *
 * [44] Wildcard Matching
 */

// @lc code=start
class Solution {
public:
    bool isMatch(string s, string p) {
        int m=s.length(),n=p.length();
        vector&lt;vector&lt;bool&gt;&gt;dp(m+1,vector&lt;bool&gt;(n+1,false));
        dp[0][0]=1;
        for(int i=1;i&lt;=m;i++){
            dp[i][0]=false;
        }
        for(int i=1;i&lt;=n;i++){
            if(p[i-1]==&#x27;*&#x27;){
                dp[0][i]=dp[0][i-2];
            }
            else{
                dp[0][i]=false;
            }
        }

        for(int i=1;i&lt;=m;i++){
            for(int j=1;j&lt;=n;j++){
                if(s[i-1]==p[j-1]||p[j-1]==&#x27;?&#x27;){
                    dp[i][j]=dp[i-1][j-1];
                }
                else if(p[j-1]==&#x27;*&#x27;){
                    if(dp[i][j-2]){
                        dp[i][j]=dp[i][j-2];
                    }
                    else if(p[j-2]==&#x27;?&#x27;||s[i-1]==p[j-2]){
                        dp[i][j]=dp[i-1][j];
                    }
                    else{
                        dp[i][j]=false;
                    }
                }
                else{
                    dp[i][j]=false;
                }
            }
        }
        for(auto y:dp){
            for(int x:y){
                cout&lt;&lt;x&lt;&lt;&#x27; &#x27;;
            }
            cout&lt;&lt;&#x27;\n&#x27;;
        }
        return dp[m][n];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 45. Jump Game II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of non-negative integers
   <code>
    nums
   </code>
   , you are initially positioned at the first index of the array.
  </p>
  <p>
   Each element in the array represents your maximum jump length at that position.
  </p>
  <p>
   Your goal is to reach the last index in the minimum number of jumps.
  </p>
  <p>
   You can assume that you can always reach the last index.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,3,1,1,4]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,3,0,1,4]
<strong>Output:</strong> 2
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= nums[i] &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 45 -->
<pre>/*
 * @lc app=leetcode id=45 lang=cpp
 *
 * [45] Jump Game II
 */

// @lc code=start
class Solution {
public:
    int jump(vector&lt;int&gt;&amp; nums) {
        int n=nums.size();
        vector&lt;int&gt; dp(nums.size()+1,10000);
        dp[0]=0;
        for(int i=0;i&lt;n;i++){
            if(i+nums[i]&gt;n){
            dp[n-1]=min(dp[n-1],dp[i]+1);
            break;
            }
            for(int j=i+1;j&lt;=nums[i]+i;j++){
                dp[j]=min(dp[j],dp[i]+1);
            }
        }

        return dp[n-1];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 46. Permutations
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array
   <code>
    nums
   </code>
   of distinct integers, return
   <em>
    all the possible permutations
   </em>
   . You can return the answer in
   <strong>
    any order
   </strong>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [0,1]
<strong>Output:</strong> [[0,1],[1,0]]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1]
<strong>Output:</strong> [[1]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 6
    </code>
   </li>
   <li>
    <code>
     -10 &lt;= nums[i] &lt;= 10
    </code>
   </li>
   <li>
    All the integers of
    <code>
     nums
    </code>
    are
    <strong>
     unique
    </strong>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 46 -->
<pre>/*
 * @lc app=leetcode id=46 lang=cpp
 *
 * [46] Permutations
 */

// @lc code=start
class Solution {
public:
vector&lt;vector&lt;int&gt;&gt;a;
void generate(vector&lt;int&gt;&amp; nums,int j){
    if(j==nums.size()-1){
        a.push_back(nums);
        return;
    }
    for(int i=j; i&lt;nums.size();i++){
        swap(nums[i],nums[j]);
        generate(nums,j+1);
        swap(nums[i],nums[j]);
    }
}
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {
        generate(nums,0);
        return a;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 47. Permutations II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a collection of numbers,
   <code>
    nums
   </code>
   , that might contain duplicates, return
   <em>
    all possible unique permutations
    <strong>
     in any order
    </strong>
    .
   </em>
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,1,2]
<strong>Output:</strong>
[[1,1,2],
 [1,2,1],
 [2,1,1]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 8
    </code>
   </li>
   <li>
    <code>
     -10 &lt;= nums[i] &lt;= 10
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 47 -->
<pre>/*
 * @lc app=leetcode id=47 lang=cpp
 *
 * [47] Permutations II
 */

// @lc code=start
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 48. Rotate Image
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an
   <code>
    n x n
   </code>
   2D
   <code>
    matrix
   </code>
   representing an image, rotate the image by
   <strong>
    90
   </strong>
   degrees (clockwise).
  </p>
  <p>
   You have to rotate the image
   <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">
    <strong>
     in-place
    </strong>
   </a>
   , which means you have to modify the input 2D matrix directly.
   <strong>
    DO NOT
   </strong>
   allocate another 2D matrix and do the rotation.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/mat1.jpg" style="width: 642px; height: 242px;"/>
  <pre><strong>Input:</strong> matrix = [[1,2,3],[4,5,6],[7,8,9]]
<strong>Output:</strong> [[7,4,1],[8,5,2],[9,6,3]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/mat2.jpg" style="width: 800px; height: 321px;"/>
  <pre><strong>Input:</strong> matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
<strong>Output:</strong> [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> matrix = [[1]]
<strong>Output:</strong> [[1]]
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> matrix = [[1,2],[3,4]]
<strong>Output:</strong> [[3,1],[4,2]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     matrix.length == n
    </code>
   </li>
   <li>
    <code>
     matrix[i].length == n
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 20
    </code>
   </li>
   <li>
    <code>
     -1000 &lt;= matrix[i][j] &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 48 -->
<pre>/*
 * @lc app=leetcode id=48 lang=cpp
 *
 * [48] Rotate Image
 */

// @lc code=start
class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; a) {
        for(int i = 0; i &lt; a.size();i++){
            for(int j = 0; j &lt;= i;j++){
                swap(a[i][j],a[j][i]);
            }
        }
        for(int i = 0; i &lt; a.size();i++){
            for(int j = 0; j &lt; a[i].size()/2;j++){
                swap(a[i][j],a[i][a[i].size()-j-1]);
        }
    }
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 49. Group Anagrams
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of strings
   <code>
    strs
   </code>
   , group
   <strong>
    the anagrams
   </strong>
   together. You can return the answer in
   <strong>
    any order
   </strong>
   .
  </p>
  <p>
   An
   <strong>
    Anagram
   </strong>
   is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> strs = ["eat","tea","tan","ate","nat","bat"]
<strong>Output:</strong> [["bat"],["nat","tan"],["ate","eat","tea"]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> strs = [""]
<strong>Output:</strong> [[""]]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> strs = ["a"]
<strong>Output:</strong> [["a"]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= strs.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= strs[i].length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     strs[i]
    </code>
    consists of lowercase English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 49 -->
<pre>/*
 * @lc app=leetcode id=49 lang=cpp
 *
 * [49] Group Anagrams
 */

// @lc code=start
class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {
        map&lt;string,vector&lt;string&gt;&gt;m;
        for(auto x:strs)
        {
            string s=x;
            sort(s.begin(),s.end());
            m[s].push_back(x);
        }
        vector&lt;vector&lt;string&gt;&gt;ans;
        for(auto x:m)
        {
            ans.push_back(x.second);
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 50. Pow(x, n)
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Implement
   <a href="http://www.cplusplus.com/reference/valarray/pow/" target="_blank">
    pow(x, n)
   </a>
   , which calculates
   <code>
    x
   </code>
   raised to the power
   <code>
    n
   </code>
   (i.e.,
   <code>
    x
    <sup>
     n
    </sup>
   </code>
   ).
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> x = 2.00000, n = 10
<strong>Output:</strong> 1024.00000
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> x = 2.10000, n = 3
<strong>Output:</strong> 9.26100
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> x = 2.00000, n = -2
<strong>Output:</strong> 0.25000
<strong>Explanation:</strong> 2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     -100.0 &lt; x &lt; 100.0
    </code>
   </li>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= n &lt;= 2
     <sup>
      31
     </sup>
     -1
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= x
     <sup>
      n
     </sup>
     &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 50 -->
<pre>/*
 * @lc app=leetcode id=50 lang=cpp
 *
 * [50] Pow(x, n)
 */

// @lc code=start
class Solution {
public:
    double myPow(double x, int n) {
        int sign =1;
        if(x&lt;0 &amp;&amp; n%2!=0) sign =-1;
        return sign*exp(log(abs(x))*n);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 51. N-Queens
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   The
   <strong>
    n-queens
   </strong>
   puzzle is the problem of placing
   <code>
    n
   </code>
   queens on an
   <code>
    n x n
   </code>
   chessboard such that no two queens attack each other.
  </p>
  <p>
   Given an integer
   <code>
    n
   </code>
   , return
   <em>
    all distinct solutions to the
    <strong>
     n-queens puzzle
    </strong>
   </em>
   . You may return the answer in
   <strong>
    any order
   </strong>
   .
  </p>
  <p>
   Each solution contains a distinct board configuration of the n-queens' placement, where
   <code>
    'Q'
   </code>
   and
   <code>
    '.'
   </code>
   both indicate a queen and an empty space, respectively.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/queens.jpg" style="width: 600px; height: 268px;"/>
  <pre><strong>Input:</strong> n = 4
<strong>Output:</strong> [[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
<strong>Explanation:</strong> There exist two distinct solutions to the 4-queens puzzle as shown above
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1
<strong>Output:</strong> [["Q"]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 9
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 51 -->
<pre>/*
 * @lc app=leetcode id=51 lang=cpp
 *
 * [51] N-Queens
 */

// @lc code=start
class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt;ans;
    void backtrack(vector&lt;string&gt;a,int col,int n){
        if(col==n){
            ans.push_back(a);
            return;
        }
        for(int i=0;i&lt;n;i++){
            if(valid(a,i,col)){
                a[i][col]=&#x27;Q&#x27;;
                backtrack(a,col+1,n);
                a[i][col]=&#x27;.&#x27;;
            }
        }
    }
    bool valid(vector&lt;string&gt;&amp;a,int row,int col){
        int n=a.size();

        for(int i=1;i&lt;=col;i++){
            if(a[row][col-i]==&#x27;Q&#x27;) return false;
        }

        for(int i=1;row-i&gt;=0 &amp;&amp; col-i&gt;=0 ;i++){
            if(a[row-i][col-i]==&#x27;Q&#x27;) return false;
        }
        for(int i=1;row+i&lt;n &amp;&amp; col-i&gt;=0 ;i++){
            if(a[row+i][col-i]==&#x27;Q&#x27;) return false;
        }
        return true;
    }
    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {
        vector&lt;string&gt;a(n,string(n,&#x27;.&#x27;));
        backtrack(a,0,n);
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 52. N-Queens II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   The
   <strong>
    n-queens
   </strong>
   puzzle is the problem of placing
   <code>
    n
   </code>
   queens on an
   <code>
    n x n
   </code>
   chessboard such that no two queens attack each other.
  </p>
  <p>
   Given an integer
   <code>
    n
   </code>
   , return
   <em>
    the number of distinct solutions to the
    <strong>
     n-queens puzzle
    </strong>
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/queens.jpg" style="width: 600px; height: 268px;"/>
  <pre><strong>Input:</strong> n = 4
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are two distinct solutions to the 4-queens puzzle as shown.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 9
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 52 -->
<pre>/*
 * @lc app=leetcode id=52 lang=cpp
 *
 * [52] N-Queens II
 */

// @lc code=start
class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt;ans;
    void backtrack(vector&lt;string&gt;a,int col,int n){
        if(col==n){
            ans.push_back(a);
            return;
        }
        for(int i=0;i&lt;n;i++){
            if(valid(a,i,col)){
                a[i][col]=&#x27;Q&#x27;;
                backtrack(a,col+1,n);
                a[i][col]=&#x27;.&#x27;;
            }
        }
    }
    bool valid(vector&lt;string&gt;&amp;a,int row,int col){
        int n=a.size();

        for(int i=1;i&lt;=col;i++){
            if(a[row][col-i]==&#x27;Q&#x27;) return false;
        }

        for(int i=1;row-i&gt;=0 &amp;&amp; col-i&gt;=0 ;i++){
            if(a[row-i][col-i]==&#x27;Q&#x27;) return false;
        }
        for(int i=1;row+i&lt;n &amp;&amp; col-i&gt;=0 ;i++){
            if(a[row+i][col-i]==&#x27;Q&#x27;) return false;
        }
        return true;
    }
    int totalNQueens(int n) {
        vector&lt;string&gt;a(n,string(n,&#x27;.&#x27;));
        backtrack(a,0,n);
        return ans.size();
    }

};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 53. Maximum Subarray
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   , find the contiguous subarray (containing at least one number) which has the largest sum and return
   <em>
    its sum
   </em>
   .
  </p>
  <p>
   A
   <strong>
    subarray
   </strong>
   is a
   <strong>
    contiguous
   </strong>
   part of an array.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [-2,1,-3,4,-1,2,1,-5,4]
<strong>Output:</strong> 6
<strong>Explanation:</strong> [4,-1,2,1] has the largest sum = 6.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1]
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [5,4,-1,7,8]
<strong>Output:</strong> 23
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 3 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      5
     </sup>
     &lt;= nums[i] &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   If you have figured out the
   <code>
    O(n)
   </code>
   solution, try coding another solution using the
   <strong>
    divide and conquer
   </strong>
   approach, which is more subtle.
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 53 -->
<pre>/*
 * @lc app=leetcode id=53 lang=cpp
 *
 * [53] Maximum Subarray
 */

// @lc code=start
class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int max_so_far=INT_MIN,sum=0;
        for(int i=0;i&lt;nums.size();i++)
        {
            sum=sum + nums[i];
            if(sum&gt;max_so_far)
            {
                max_so_far=sum;
            }
            if(sum&lt;0)
            {
                sum=0;
            }
        }
        return max_so_far;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 54. Spiral Matrix
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an
   <code>
    m x n
   </code>
   <code>
    matrix
   </code>
   , return
   <em>
    all elements of the
   </em>
   <code>
    matrix
   </code>
   <em>
    in spiral order
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/spiral1.jpg" style="width: 242px; height: 242px;"/>
  <pre><strong>Input:</strong> matrix = [[1,2,3],[4,5,6],[7,8,9]]
<strong>Output:</strong> [1,2,3,6,9,8,7,4,5]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/spiral.jpg" style="width: 322px; height: 242px;"/>
  <pre><strong>Input:</strong> matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
<strong>Output:</strong> [1,2,3,4,8,12,11,10,9,5,6,7]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == matrix.length
    </code>
   </li>
   <li>
    <code>
     n == matrix[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m, n &lt;= 10
    </code>
   </li>
   <li>
    <code>
     -100 &lt;= matrix[i][j] &lt;= 100
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 54 -->
<pre>/*
 * @lc app=leetcode id=54 lang=cpp
 *
 * [54] Spiral Matrix
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        vector&lt;int&gt;ans;
        int m=matrix.size();
        int n=matrix[0].size();
        int r1=0,r2=m-1,c1=0,c2=n-1;
        int val=1;
        while(r1&lt;=r2 &amp;&amp; c1&lt;=c2) {
            for(int i=c1; i&lt;=c2;i++){
                ans.push_back(matrix[r1][i]);
            }

            for(int i=r1+1; i&lt;=r2;i++){
                ans.push_back(matrix[i][c2]);
            }

            if(r1&lt;r2 &amp;&amp; c1&lt;c2) {
                for(int i=c2-1;i&gt;c1;i--){
                    ans.push_back(matrix[r2][i]);
                }

                for(int i=r2;i&gt;r1;i--){
                    ans.push_back(matrix[i][c1]);
                }
            }
            r2--;
            c2--;
            r1++;
            c1++;
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 55. Jump Game
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an integer array
   <code>
    nums
   </code>
   . You are initially positioned at the array's
   <strong>
    first index
   </strong>
   , and each element in the array represents your maximum jump length at that position.
  </p>
  <p>
   Return
   <code>
    true
   </code>
   <em>
    if you can reach the last index, or
   </em>
   <code>
    false
   </code>
   <em>
    otherwise
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,3,1,1,4]
<strong>Output:</strong> true
<strong>Explanation:</strong> Jump 1 step from index 0 to 1, then 3 steps to the last index.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,2,1,0,4]
<strong>Output:</strong> false
<strong>Explanation:</strong> You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= nums[i] &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 55 -->
<pre>/*
 * @lc app=leetcode id=55 lang=cpp
 *
 * [55] Jump Game
 */

// @lc code=start
class Solution {
public:
    bool canJump(vector&lt;int&gt;&amp; nums) {
        int minjumps = 0;
        for(int i=nums.size()-2; i&gt;=0;i--)
        {
            minjumps++;
            if(nums[i]&gt;=minjumps)
            {
                minjumps=0;
            }
        }
        if(minjumps==0)
        {
            return true;
        }
        return false;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 56. Merge Intervals
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of
   <code>
    intervals
   </code>
   where
   <code>
    intervals[i] = [start
    <sub>
     i
    </sub>
    , end
    <sub>
     i
    </sub>
    ]
   </code>
   , merge all overlapping intervals, and return
   <em>
    an array of the non-overlapping intervals that cover all the intervals in the input
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> intervals = [[1,3],[2,6],[8,10],[15,18]]
<strong>Output:</strong> [[1,6],[8,10],[15,18]]
<strong>Explanation:</strong> Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> intervals = [[1,4],[4,5]]
<strong>Output:</strong> [[1,5]]
<strong>Explanation:</strong> Intervals [1,4] and [4,5] are considered overlapping.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= intervals.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     intervals[i].length == 2
    </code>
   </li>
   <li>
    <code>
     0 &lt;= start
     <sub>
      i
     </sub>
     &lt;= end
     <sub>
      i
     </sub>
     &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 56 -->
<pre>/*
 * @lc app=leetcode id=56 lang=cpp
 *
 * [56] Merge Intervals
 */

// @lc code=start
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
        vector&lt;vector&lt;int&gt;&gt;answer ;
        if(intervals.size()&lt;2)
        {
            return intervals;
        }
        sort(intervals.begin(),intervals.end());
        answer.push_back(intervals[0]);
        int len=1;
        for(int i=1;i&lt;intervals.size();i++) {
            if(intervals[i][0]&lt;=answer[len-1][1])
            {
                answer[len-1][1]=max(intervals[i][1],answer[len-1][1]);
            }
            else
            {
                answer.push_back(intervals[i]);
                len++;
            }
        }
        return answer;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 57. Insert Interval
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an array of non-overlapping intervals
   <code>
    intervals
   </code>
   where
   <code>
    intervals[i] = [start
    <sub>
     i
    </sub>
    , end
    <sub>
     i
    </sub>
    ]
   </code>
   represent the start and the end of the
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   interval and
   <code>
    intervals
   </code>
   is sorted in ascending order by
   <code>
    start
    <sub>
     i
    </sub>
   </code>
   . You are also given an interval
   <code>
    newInterval = [start, end]
   </code>
   that represents the start and end of another interval.
  </p>
  <p>
   Insert
   <code>
    newInterval
   </code>
   into
   <code>
    intervals
   </code>
   such that
   <code>
    intervals
   </code>
   is still sorted in ascending order by
   <code>
    start
    <sub>
     i
    </sub>
   </code>
   and
   <code>
    intervals
   </code>
   still does not have any overlapping intervals (merge overlapping intervals if necessary).
  </p>
  <p>
   Return
   <code>
    intervals
   </code>
   <em>
    after the insertion
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> intervals = [[1,3],[6,9]], newInterval = [2,5]
<strong>Output:</strong> [[1,5],[6,9]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
<strong>Output:</strong> [[1,2],[3,10],[12,16]]
<strong>Explanation:</strong> Because the new interval <code>[4,8]</code> overlaps with <code>[3,5],[6,7],[8,10]</code>.</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> intervals = [], newInterval = [5,7]
<strong>Output:</strong> [[5,7]]
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> intervals = [[1,5]], newInterval = [2,3]
<strong>Output:</strong> [[1,5]]
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> intervals = [[1,5]], newInterval = [2,7]
<strong>Output:</strong> [[1,7]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= intervals.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     intervals[i].length == 2
    </code>
   </li>
   <li>
    <code>
     0 &lt;= start
     <sub>
      i
     </sub>
     &lt;= end
     <sub>
      i
     </sub>
     &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     intervals
    </code>
    is sorted by
    <code>
     start
     <sub>
      i
     </sub>
    </code>
    in
    <strong>
     ascending
    </strong>
    order.
   </li>
   <li>
    <code>
     newInterval.length == 2
    </code>
   </li>
   <li>
    <code>
     0 &lt;= start &lt;= end &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 57 -->
<pre>/*
 * @lc app=leetcode id=57 lang=cpp
 *
 * [57] Insert Interval
 */

// @lc code=start
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) {
        vector&lt;vector&lt;int&gt;&gt;answer ;
        intervals.push_back(newInterval);
        if(intervals.size()&lt;2)
        {
            return intervals;
        }
        sort(intervals.begin(),intervals.end());
        answer.push_back(intervals[0]);
        int len=1;
        for(int i=1;i&lt;intervals.size();i++) {
            if(intervals[i][0]&lt;=answer[len-1][1])
            {
                answer[len-1][1]=max(intervals[i][1],answer[len-1][1]);
            }
            else
            {
                answer.push_back(intervals[i]);
                len++;
            }
        }
        return answer;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 58. Length of Last Word
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    s
   </code>
   consisting of some words separated by some number of spaces, return
   <em>
    the length of the
    <strong>
     last
    </strong>
    word in the string.
   </em>
  </p>
  <p>
   A
   <strong>
    word
   </strong>
   is a maximal substring consisting of non-space characters only.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "Hello World"
<strong>Output:</strong> 5
<strong>Explanation:</strong> The last word is "World" with length 5.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "   fly me   to   the moon  "
<strong>Output:</strong> 4
<strong>Explanation:</strong> The last word is "moon" with length 4.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "luffy is still joyboy"
<strong>Output:</strong> 6
<strong>Explanation:</strong> The last word is "joyboy" with length 6.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consists of only English letters and spaces
    <code>
     ' '
    </code>
    .
   </li>
   <li>
    There will be at least one word in
    <code>
     s
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 58 -->
<pre>/*
 * @lc app=leetcode id=58 lang=cpp
 *
 * [58] Length of Last Word
 */

// @lc code=start
class Solution {
public:
    int lengthOfLastWord(string s) {
        int start,end,count=0;
        for(int i=s.length()-1; i&gt;=0;i--){
            if(isalpha(s[i]) &amp;&amp; count==0)
            {
                count=1;
                start=i;
            }
            if(count==1 &amp;&amp; s[i]==&#x27; &#x27;){
                return start-i;
            }
        }
        return start+1;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 59. Spiral Matrix II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a positive integer
   <code>
    n
   </code>
   , generate an
   <code>
    n x n
   </code>
   <code>
    matrix
   </code>
   filled with elements from
   <code>
    1
   </code>
   to
   <code>
    n
    <sup>
     2
    </sup>
   </code>
   in spiral order.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/spiraln.jpg" style="width: 242px; height: 242px;"/>
  <pre><strong>Input:</strong> n = 3
<strong>Output:</strong> [[1,2,3],[8,9,4],[7,6,5]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1
<strong>Output:</strong> [[1]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 20
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 59 -->
<pre>/*
 * @lc app=leetcode id=59 lang=cpp
 *
 * [59] Spiral Matrix II
 */

// @lc code=start
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) {
        vector&lt;vector&lt;int&gt;&gt;ans(n,vector&lt;int&gt;(n,0));
        int r1=0,r2=n-1,c1=0,c2=n-1;
        int val=1;
        while(r1&lt;=r2 &amp;&amp; c1&lt;=c2) {
            for(int i=c1; i&lt;=c2;i++){
                ans[r1][i]=val++;
            }

            for(int i=r1+1; i&lt;=r2;i++){
                ans[i][c2]=val++;
            }

            if(r1&lt;r2 &amp;&amp; c1&lt;c2) {
                for(int i=c2-1;i&gt;c1;i--){
                    ans[r2][i]=val++;
                }

                for(int i=r2;i&gt;r1;i--){
                    ans[i][c1]=val++;
                }
            }
            r2--;
            c2--;
            r1++;
            c1++;
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 60. Permutation Sequence
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   The set
   <code>
    [1, 2, 3, ..., n]
   </code>
   contains a total of
   <code>
    n!
   </code>
   unique permutations.
  </p>
  <p>
   By listing and labeling all of the permutations in order, we get the following sequence for
   <code>
    n = 3
   </code>
   :
  </p>
  <ol>
   <li>
    <code>
     "123"
    </code>
   </li>
   <li>
    <code>
     "132"
    </code>
   </li>
   <li>
    <code>
     "213"
    </code>
   </li>
   <li>
    <code>
     "231"
    </code>
   </li>
   <li>
    <code>
     "312"
    </code>
   </li>
   <li>
    <code>
     "321"
    </code>
   </li>
  </ol>
  <p>
   Given
   <code>
    n
   </code>
   and
   <code>
    k
   </code>
   , return the
   <code>
    k
    <sup>
     th
    </sup>
   </code>
   permutation sequence.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 3, k = 3
<strong>Output:</strong> "213"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 4, k = 9
<strong>Output:</strong> "2314"
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 3, k = 1
<strong>Output:</strong> "123"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 9
    </code>
   </li>
   <li>
    <code>
     1 &lt;= k &lt;= n!
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 60 -->
<pre>/*
 * @lc app=leetcode id=60 lang=cpp
 *
 * [60] Permutation Sequence
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt;a;
    void permutation(string s,int index){
        if(index==s.length()){
            a.push_back(stoi(s));
            return;
        }
        for(int i=index;i&lt;s.length();i++){
            swap(s[i],s[index]);
            permutation(s,index+1);
            swap(s[i],s[index]);
        }
    }
    string getPermutation(int n, int k) {

        //method 1

        string s=&quot;&quot;;
        for(int i=0; i&lt;n; i++) {
            s=s+to_string(i+1);
        }
        permutation(s,0);
        sort(a.begin(), a.end());
        return to_string(a[k-1]);

        //method 2

        // vector&lt;int&gt;dict{1,1,2,6,24,120,720,5040,40320,362880};
        // vector&lt;int&gt;a;
        // string s=&quot;&quot;;
        // for(int i=0; i&lt;n;i++) a.push_back(i+1);
        // while(k&gt;0 &amp;&amp; n){
        //     int count=dict[n-1];
        //     int value=1;
        //     while(count*value&lt;k){
        //         value=value+1;
        //     }
        //     k=k-count*(value-1);
        //     n--;
        //     s=s+to_string(a[value-1]);
        //     remove(a.begin(), a.end(),a[value-1]);
        // }
        // return s;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 61. Rotate List
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    head
   </code>
   of a linked list, rotate the list to the right by
   <code>
    k
   </code>
   places.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/rotate1.jpg" style="width: 450px; height: 191px;"/>
  <pre><strong>Input:</strong> head = [1,2,3,4,5], k = 2
<strong>Output:</strong> [4,5,1,2,3]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/roate2.jpg" style="width: 305px; height: 350px;"/>
  <pre><strong>Input:</strong> head = [0,1,2], k = 4
<strong>Output:</strong> [2,0,1]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the list is in the range
    <code>
     [0, 500]
    </code>
    .
   </li>
   <li>
    <code>
     -100 &lt;= Node.val &lt;= 100
    </code>
   </li>
   <li>
    <code>
     0 &lt;= k &lt;= 2 * 10
     <sup>
      9
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 61 -->
<pre>/*
 * @lc app=leetcode id=61 lang=cpp
 *
 * [61] Rotate List
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(head==NULL)
        {
            return NULL;
        }
        if(head-&gt;next==NULL)
        {
            return head;
        }
        ListNode* temp = new ListNode(head-&gt;val);
        ListNode *traversenode = head-&gt;next;
        int count =1;
        while(traversenode!=NULL )
        {
            ListNode* newnode = new ListNode(traversenode-&gt;val);
            newnode-&gt;next=temp;
            temp=newnode;
            count++;
            traversenode = traversenode-&gt;next;
        }
        cout&lt;&lt;count;
        int main_count = k % count;
        while(main_count)
        {
            ListNode *newnode = new ListNode(temp-&gt;val);
            newnode-&gt;next=head;
            head=newnode;
            temp=temp-&gt;next;
            main_count--;
        }
        temp=head;
        main_count=count;
        while(main_count!=1)
        {
            temp=temp-&gt;next;
            main_count--;
        }
        temp-&gt;next=NULL;
        return head;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 62. Unique Paths
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   A robot is located at the top-left corner of a
   <code>
    m x n
   </code>
   grid (marked 'Start' in the diagram below).
  </p>
  <p>
   The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).
  </p>
  <p>
   How many possible unique paths are there?
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img src="./output_files/robot_maze.png" style="width: 400px; height: 183px;"/>
  <pre><strong>Input:</strong> m = 3, n = 7
<strong>Output:</strong> 28
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> m = 3, n = 2
<strong>Output:</strong> 3
<strong>Explanation:</strong>
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -&gt; Down -&gt; Down
2. Down -&gt; Down -&gt; Right
3. Down -&gt; Right -&gt; Down
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> m = 7, n = 3
<strong>Output:</strong> 28
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> m = 3, n = 3
<strong>Output:</strong> 6
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= m, n &lt;= 100
    </code>
   </li>
   <li>
    It's guaranteed that the answer will be less than or equal to
    <code>
     2 * 10
     <sup>
      9
     </sup>
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 62 -->
<pre>/*
 * @lc app=leetcode id=62 lang=cpp
 *
 * [62] Unique Paths
 */

// @lc code=start
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector&lt;vector&lt;int&gt;&gt;dp(m+1,vector&lt;int&gt;(n+1,0));
        dp[0][0]=0;
        for(int i=1;i&lt;=m;i++){
            for(int j=1;j&lt;=n;j++){
                if(i==1 &amp;&amp; j==1){
                    dp[i][j]=1;
                    continue;
                }
                dp[i][j]=dp[i][j-1]+dp[i-1][j];
            }
        }
        return dp[m][n];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 63. Unique Paths II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   A robot is located at the top-left corner of a
   <code>
    m x n
   </code>
   grid (marked 'Start' in the diagram below).
  </p>
  <p>
   The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).
  </p>
  <p>
   Now consider if some obstacles are added to the grids. How many unique paths would there be?
  </p>
  <p>
   An obstacle and space is marked as
   <code>
    1
   </code>
   and
   <code>
    0
   </code>
   respectively in the grid.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/robot1.jpg" style="width: 242px; height: 242px;"/>
  <pre><strong>Input:</strong> obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -&gt; Right -&gt; Down -&gt; Down
2. Down -&gt; Down -&gt; Right -&gt; Right
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/robot2.jpg" style="width: 162px; height: 162px;"/>
  <pre><strong>Input:</strong> obstacleGrid = [[0,1],[0,0]]
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == obstacleGrid.length
    </code>
   </li>
   <li>
    <code>
     n == obstacleGrid[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m, n &lt;= 100
    </code>
   </li>
   <li>
    <code>
     obstacleGrid[i][j]
    </code>
    is
    <code>
     0
    </code>
    or
    <code>
     1
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 63 -->
<pre>/*
 * @lc app=leetcode id=63 lang=cpp
 *
 * [63] Unique Paths II
 */

// @lc code=start
class Solution {
public:
    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {
        int m = obstacleGrid.size(), n = obstacleGrid[0].size();
        vector&lt;vector&lt;int&gt;&gt;dp(m+1,vector&lt;int&gt;(n+1,0));
        dp[0][1]=1;
        for(int i=1;i&lt;=m;i++) {
            for(int j=1;j&lt;=n;j++) {
                if(!obstacleGrid[i-1][j-1]){
                    dp[i][j]=dp[i][j-1]+dp[i-1][j];
                }
            }
        }
        return dp[m][n];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 64. Minimum Path Sum
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a
   <code>
    m x n
   </code>
   <code>
    grid
   </code>
   filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.
  </p>
  <p>
   <strong>
    Note:
   </strong>
   You can only move either down or right at any point in time.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/minpath.jpg" style="width: 242px; height: 242px;"/>
  <pre><strong>Input:</strong> grid = [[1,3,1],[1,5,1],[4,2,1]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> grid = [[1,2,3],[4,5,6]]
<strong>Output:</strong> 12
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == grid.length
    </code>
   </li>
   <li>
    <code>
     n == grid[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m, n &lt;= 200
    </code>
   </li>
   <li>
    <code>
     0 &lt;= grid[i][j] &lt;= 100
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 64 -->
<pre>/*
 * @lc app=leetcode id=64 lang=cpp
 *
 * [64] Minimum Path Sum
 */

// @lc code=start
class Solution {
public:
    int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int m=grid.size();
        int n=grid[0].size();
        vector&lt;vector&lt;int&gt;&gt;dp(m,vector&lt;int&gt;(n,0));
        dp[0][0]=grid[0][0];
        for(int i=1;i&lt;m;i++) dp[i][0]=dp[i-1][0]+grid[i][0];
        for(int i=1;i&lt;n;i++) dp[0][i]=dp[0][i-1]+grid[0][i];
        for(int i=1;i&lt;m;i++)
        {
            for(int j=1;j&lt;n;j++)
            {
                dp[i][j]=grid[i][j]+min(dp[i-1][j],dp[i][j-1]);
            }
        }
        for(auto y:dp){
            for(int x:y){
                cout&lt;&lt;x&lt;&lt;&#x27; &#x27;;
            }
            cout&lt;&lt;&#x27;\n&#x27;;
        }
        return dp[m-1][n-1];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 65. Valid Number
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   A
   <strong>
    valid number
   </strong>
   can be split up into these components (in order):
  </p>
  <ol>
   <li>
    A
    <strong>
     decimal number
    </strong>
    or an
    <strong>
     integer
    </strong>
    .
   </li>
   <li>
    (Optional) An
    <code>
     'e'
    </code>
    or
    <code>
     'E'
    </code>
    , followed by an
    <strong>
     integer
    </strong>
    .
   </li>
  </ol>
  <p>
   A
   <strong>
    decimal number
   </strong>
   can be split up into these components (in order):
  </p>
  <ol>
   <li>
    (Optional) A sign character (either
    <code>
     '+'
    </code>
    or
    <code>
     '-'
    </code>
    ).
   </li>
   <li>
    One of the following formats:
    <ol>
     <li>
      One or more digits, followed by a dot
      <code>
       '.'
      </code>
      .
     </li>
     <li>
      One or more digits, followed by a dot
      <code>
       '.'
      </code>
      , followed by one or more digits.
     </li>
     <li>
      A dot
      <code>
       '.'
      </code>
      , followed by one or more digits.
     </li>
    </ol>
   </li>
  </ol>
  <p>
   An
   <strong>
    integer
   </strong>
   can be split up into these components (in order):
  </p>
  <ol>
   <li>
    (Optional) A sign character (either
    <code>
     '+'
    </code>
    or
    <code>
     '-'
    </code>
    ).
   </li>
   <li>
    One or more digits.
   </li>
  </ol>
  <p>
   For example, all the following are valid numbers:
   <code>
    ["2", "0089", "-0.1", "+3.14", "4.", "-.9", "2e10", "-90E3", "3e+7", "+6e-1", "53.5e93", "-123.456e789"]
   </code>
   , while the following are not valid numbers:
   <code>
    ["abc", "1a", "1e", "e3", "99e2.5", "--6", "-+3", "95a54e53"]
   </code>
   .
  </p>
  <p>
   Given a string
   <code>
    s
   </code>
   , return
   <code>
    true
   </code>
   <em>
    if
   </em>
   <code>
    s
   </code>
   <em>
    is a
    <strong>
     valid number
    </strong>
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "0"
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "e"
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "."
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = ".1"
<strong>Output:</strong> true
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 20
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consists of only English letters (both uppercase and lowercase), digits (
    <code>
     0-9
    </code>
    ), plus
    <code>
     '+'
    </code>
    , minus
    <code>
     '-'
    </code>
    , or dot
    <code>
     '.'
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 65 -->
<pre>/*
 * @lc app=leetcode id=65 lang=cpp
 *
 * [65] Valid Number
 */

// @lc code=start
class Solution {
public:
    bool isNumber(string s) {
        int dot=0;
        int ecount=0;
        int sign=0;
        int dotstart=0;
        int signstart=0;
        int estart=0;
        int digitcount=0;
        for(int i = 0; i &lt;s.length(); i++) {
            if(s[i]==&#x27;+&#x27; || s[i]==&#x27;-&#x27;){
                if(sign&gt;0) return false;
                if(dot&gt;0 &amp;&amp; ecount==0) return false;
                if(estart!=i-1 &amp;&amp; ecount==1) return false;
                if(digitcount&gt;0 &amp;&amp; ecount==0) return false;
                if(s.length()==1 ||i==s.length()-1  ) return false;
                signstart=i;
                sign++;
            }
            else if(s[i]==&#x27;.&#x27;){
                if(dot&gt;0) return false;
                if(ecount&gt;0) return false;
                if(signstart&gt;i) return false;
                if(s.length()==1) return false;
                dotstart=i;
                dot++;
            }
            else if(s[i]==&#x27;e&#x27;||s[i]==&#x27;E&#x27;){
                if(sign&gt;0) sign--;
                if(i==s.length()-1 || i==0) return false;
                if(ecount&gt;0) return false;
                if(dotstart==i-1 &amp;&amp; dot&gt;0 &amp;&amp; digitcount==0) return false;
                if(digitcount==0) return false;
                estart=i;
                ecount++;
            }
            else if(isdigit(s[i])){
                digitcount++;
                continue;
            }

            else return false;
        }
        return digitcount!=0?true:false;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 66. Plus One
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given a
   <strong>
    large integer
   </strong>
   represented as an integer array
   <code>
    digits
   </code>
   , where each
   <code>
    digits[i]
   </code>
   is the
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading
   <code>
    0
   </code>
   's.
  </p>
  <p>
   Increment the large integer by one and return
   <em>
    the resulting array of digits
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> digits = [1,2,3]
<strong>Output:</strong> [1,2,4]
<strong>Explanation:</strong> The array represents the integer 123.
Incrementing by one gives 123 + 1 = 124.
Thus, the result should be [1,2,4].
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> digits = [4,3,2,1]
<strong>Output:</strong> [4,3,2,2]
<strong>Explanation:</strong> The array represents the integer 4321.
Incrementing by one gives 4321 + 1 = 4322.
Thus, the result should be [4,3,2,2].
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> digits = [0]
<strong>Output:</strong> [1]
<strong>Explanation:</strong> The array represents the integer 0.
Incrementing by one gives 0 + 1 = 1.
Thus, the result should be [1].
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> digits = [9]
<strong>Output:</strong> [1,0]
<strong>Explanation:</strong> The array represents the integer 9.
Incrementing by one gives 9 + 1 = 10.
Thus, the result should be [1,0].
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= digits.length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     0 &lt;= digits[i] &lt;= 9
    </code>
   </li>
   <li>
    <code>
     digits
    </code>
    does not contain any leading
    <code>
     0
    </code>
    's.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 66 -->
<pre>/*
 * @lc app=leetcode id=66 lang=cpp
 *
 * [66] Plus One
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) {
        int i=digits.size()-1;
        int carry=1;
        digits[i]+=carry;
        while(digits[i]==10 &amp;&amp; i&gt;=1){
            digits[i-1]=digits[i-1] + digits[i]/10;
            digits[i]%=10;
            i--;
        }
        if(digits[i]==10){
            digits.insert(digits.begin(),1);
            digits[i+1]=0;
        }
        return digits;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 67. Add Binary
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two binary strings
   <code>
    a
   </code>
   and
   <code>
    b
   </code>
   , return
   <em>
    their sum as a binary string
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> a = "11", b = "1"
<strong>Output:</strong> "100"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> a = "1010", b = "1011"
<strong>Output:</strong> "10101"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= a.length, b.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     a
    </code>
    and
    <code>
     b
    </code>
    consist only of
    <code>
     '0'
    </code>
    or
    <code>
     '1'
    </code>
    characters.
   </li>
   <li>
    Each string does not contain leading zeros except for the zero itself.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 67 -->
<pre>/*
 * @lc app=leetcode id=67 lang=cpp
 *
 * [67] Add Binary
 */

// @lc code=start
class Solution {
public:
    string addBinary(string a, string b) {
        int carry=0;
        string s=&quot;&quot;;
        if(a.length()&gt;b.length()){
            string str(a.length()-b.length(), &#x27;0&#x27;);
            b=str+b;
        }
        else if(a.length()&lt;b.length()){
            string str(-a.length()+b.length(), &#x27;0&#x27;);
            a=str+a;
        }
        cout&lt;&lt;a&lt;&lt;b;
        for(int i=a.length()-1; i&gt;=0; i--){
                int x=(int)a[i]-48;
                int y=(int)b[i]-48;
                if(x+y+carry==2)
                {
                    s=&#x27;0&#x27;+s;
                    carry=1;
                }
                else if(x+y+carry==3)
                {
                    s=&#x27;1&#x27;+s;
                    carry=1;
                }
                else{
                    s=to_string(x+y+carry)+s;
                    carry=0;
                }
            }
        if(carry==1){
            return &#x27;1&#x27;+s;
        }
        return s;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 68. Text Justification
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of strings
   <code>
    words
   </code>
   and a width
   <code>
    maxWidth
   </code>
   , format the text such that each line has exactly
   <code>
    maxWidth
   </code>
   characters and is fully (left and right) justified.
  </p>
  <p>
   You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces
   <code>
    ' '
   </code>
   when necessary so that each line has exactly
   <code>
    maxWidth
   </code>
   characters.
  </p>
  <p>
   Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.
  </p>
  <p>
   For the last line of text, it should be left-justified and no extra space is inserted between words.
  </p>
  <p>
   <strong>
    Note:
   </strong>
  </p>
  <ul>
   <li>
    A word is defined as a character sequence consisting of non-space characters only.
   </li>
   <li>
    Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.
   </li>
   <li>
    The input array
    <code>
     words
    </code>
    contains at least one word.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> words = ["This", "is", "an", "example", "of", "text", "justification."], maxWidth = 16
<strong>Output:</strong>
[
   "This    is    an",
   "example  of text",
   "justification.  "
]</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> words = ["What","must","be","acknowledgment","shall","be"], maxWidth = 16
<strong>Output:</strong>
[
  "What   must   be",
  "acknowledgment  ",
  "shall be        "
]
<strong>Explanation:</strong> Note that the last line is "shall be    " instead of "shall     be", because the last line must be left-justified instead of fully-justified.
Note that the second line is also left-justified becase it contains only one word.</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> words = ["Science","is","what","we","understand","well","enough","to","explain","to","a","computer.","Art","is","everything","else","we","do"], maxWidth = 20
<strong>Output:</strong>
[
  "Science  is  what we",
  "understand      well",
  "enough to explain to",
  "a  computer.  Art is",
  "everything  else  we",
  "do                  "
]</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= words.length &lt;= 300
    </code>
   </li>
   <li>
    <code>
     1 &lt;= words[i].length &lt;= 20
    </code>
   </li>
   <li>
    <code>
     words[i]
    </code>
    consists of only English letters and symbols.
   </li>
   <li>
    <code>
     1 &lt;= maxWidth &lt;= 100
    </code>
   </li>
   <li>
    <code>
     words[i].length &lt;= maxWidth
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 68 -->
<pre>/*
 * @lc app=leetcode id=68 lang=cpp
 *
 * [68] Text Justification
 */

// @lc code=start
class Solution {
public:
    string justify(vector&lt;int&gt;space,string s,int maxwidth) {
        while(s.length()&gt;= maxwidth) {
            for(int x:space){
                s[x]=s[x]+&#x27; &#x27;;
                if(s.length()&gt;=maxwidth){
                    cout&lt;&lt;s&lt;&lt;endl;
                    return s;
                }
            }
        }
        cout&lt;&lt;s&lt;&lt;endl;
        return s;
    }
    vector&lt;string&gt; fullJustify(vector&lt;string&gt;&amp; words, int maxWidth) {
        string s=&quot;&quot;;
        int spacing=0;
        vector&lt;string&gt;ans;
        int len=0;
        vector&lt;string&gt;temp;
        for(int i = 0; i &lt;words.size();i++){
            temp.push_back(words[i]);
            len+=words[i].length();
            spacing++;
            if(len+spacing-1&gt;maxWidth){
                temp.pop_back();
                len=len-words[i].length();
                cout&lt;&lt;len;
                spacing=0;
                while(len+spacing!=maxWidth){
                    for(int j = 0; j &lt;temp.size()-1; j++){
                        temp[j]=temp[j]+&#x27; &#x27;;
                        spacing++;
                        if(spacing+len==maxWidth){
                            cout&lt;&lt;spacing;
                            break;
                        }
                    }
                    if(temp.size()==1){
                        temp[0]=temp[0]+&#x27; &#x27;;
                        spacing++;
                        if(spacing+len==maxWidth){
                            cout&lt;&lt;spacing;
                            break;
                        }
                    }
                }
                string up=&quot;&quot;;
                for(auto x:temp){
                    up=up+x;
                }
                ans.push_back(up);
                len=words[i].length();
                spacing=1;
                temp.clear();
                temp.push_back(words[i]);
            }
        }
        spacing=0;
        for(int j = 0; j &lt;temp.size()-1; j++){
                        temp[j]=temp[j]+&#x27; &#x27;;
                        spacing++;
                        if(spacing+len==maxWidth){
                            cout&lt;&lt;spacing;
                            break;
                        }
                    }
        while(len+spacing!=maxWidth){
                        temp[temp.size()-1]=temp[temp.size()-1]+&#x27; &#x27;;
                        spacing++;
                        if(spacing+len==maxWidth){
                            cout&lt;&lt;spacing;
                            break;
                        }
                    }
                string up=&quot;&quot;;
                for(auto x:temp){
                    up=up+x;
                }
                ans.push_back(up);

        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 69. Sqrt(x)
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a non-negative integer
   <code>
    x
   </code>
   , compute and return
   <em>
    the square root of
   </em>
   <code>
    x
   </code>
   .
  </p>
  <p>
   Since the return type is an integer, the decimal digits are
   <strong>
    truncated
   </strong>
   , and only
   <strong>
    the integer part
   </strong>
   of the result is returned.
  </p>
  <p>
   <strong>
    Note:
   </strong>
   You are not allowed to use any built-in exponent function or operator, such as
   <code>
    pow(x, 0.5)
   </code>
   or
   <code>
    x ** 0.5
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> x = 4
<strong>Output:</strong> 2
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> x = 8
<strong>Output:</strong> 2
<strong>Explanation:</strong> The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= x &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 69 -->
<pre>/*
 * @lc app=leetcode id=69 lang=cpp
 *
 * [69] Sqrt(x)
 */

// @lc code=start
class Solution {
public:
    int mySqrt(int x) {
        long long result = x;
        while(result * result &gt; x) {
            result = (result + x/result)/2;
        }
        return result;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 70. Climbing Stairs
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are climbing a staircase. It takes
   <code>
    n
   </code>
   steps to reach the top.
  </p>
  <p>
   Each time you can either climb
   <code>
    1
   </code>
   or
   <code>
    2
   </code>
   steps. In how many distinct ways can you climb to the top?
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 2
<strong>Output:</strong> 2
<strong>Explanation:</strong> There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 45
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 70 -->
<pre>/*
 * @lc app=leetcode id=70 lang=cpp
 *
 * [70] Climbing Stairs
 */

// @lc code=start
class Solution {
public:
    int climbStairs(int n) {
        if(n&lt;=2){
            return n;
        }
        int a=1,b=2,c=0;
        for(int i=2;i&lt;n;i++){
            c=a+b;
            a=b;
            b=c;
        }
        return c;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 71. Simplify Path
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    path
   </code>
   , which is an
   <strong>
    absolute path
   </strong>
   (starting with a slash
   <code>
    '/'
   </code>
   ) to a file or directory in a Unix-style file system, convert it to the simplified
   <strong>
    canonical path
   </strong>
   .
  </p>
  <p>
   In a Unix-style file system, a period
   <code>
    '.'
   </code>
   refers to the current directory, a double period
   <code>
    '..'
   </code>
   refers to the directory up a level, and any multiple consecutive slashes (i.e.
   <code>
    '//'
   </code>
   ) are treated as a single slash
   <code>
    '/'
   </code>
   . For this problem, any other format of periods such as
   <code>
    '...'
   </code>
   are treated as file/directory names.
  </p>
  <p>
   The
   <strong>
    canonical path
   </strong>
   should have the following format:
  </p>
  <ul>
   <li>
    The path starts with a single slash
    <code>
     '/'
    </code>
    .
   </li>
   <li>
    Any two directories are separated by a single slash
    <code>
     '/'
    </code>
    .
   </li>
   <li>
    The path does not end with a trailing
    <code>
     '/'
    </code>
    .
   </li>
   <li>
    The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period
    <code>
     '.'
    </code>
    or double period
    <code>
     '..'
    </code>
    )
   </li>
  </ul>
  <p>
   Return
   <em>
    the simplified
    <strong>
     canonical path
    </strong>
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> path = "/home/"
<strong>Output:</strong> "/home"
<strong>Explanation:</strong> Note that there is no trailing slash after the last directory name.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> path = "/../"
<strong>Output:</strong> "/"
<strong>Explanation:</strong> Going one level up from the root directory is a no-op, as the root level is the highest level you can go.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> path = "/home//foo/"
<strong>Output:</strong> "/home/foo"
<strong>Explanation: </strong>In the canonical path, multiple consecutive slashes are replaced by a single one.
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> path = "/a/./b/../../c/"
<strong>Output:</strong> "/c"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= path.length &lt;= 3000
    </code>
   </li>
   <li>
    <code>
     path
    </code>
    consists of English letters, digits, period
    <code>
     '.'
    </code>
    , slash
    <code>
     '/'
    </code>
    or
    <code>
     '_'
    </code>
    .
   </li>
   <li>
    <code>
     path
    </code>
    is a valid absolute Unix path.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 71 -->
<pre>/*
 * @lc app=leetcode id=71 lang=cpp
 *
 * [71] Simplify Path
 */

// @lc code=start
class Solution {
public:
    string simplifyPath(string path) {
        stack&lt;string&gt;s;
        int i=0;
        string temp=&quot;&quot;;\
        for(int i=0; i&lt;path.length(); i++) {

            if(path[i] == &#x27;/&#x27;) continue;

            string temp=&quot;&quot;;
            while(path[i]!=&#x27;/&#x27; &amp;&amp; i&lt;path.length()) {
                temp=temp+path[i];
                i++;
            }
            if(temp==&quot;.&quot;){
                continue;
            }
            else if(temp==&quot;..&quot;){
                if(!s.empty())s.pop();
            }
            else{
                s.push(temp);
            }
        }
        string ans=&quot;&quot;;
        while(!s.empty()){
            ans=s.top()+&#x27;/&#x27;+ans;
            s.pop();
        }
        return &#x27;/&#x27;+ans.substr(0,ans.length()-1);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 72. Edit Distance
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two strings
   <code>
    word1
   </code>
   and
   <code>
    word2
   </code>
   , return
   <em>
    the minimum number of operations required to convert
    <code>
     word1
    </code>
    to
    <code>
     word2
    </code>
   </em>
   .
  </p>
  <p>
   You have the following three operations permitted on a word:
  </p>
  <ul>
   <li>
    Insert a character
   </li>
   <li>
    Delete a character
   </li>
   <li>
    Replace a character
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> word1 = "horse", word2 = "ros"
<strong>Output:</strong> 3
<strong>Explanation:</strong> 
horse -&gt; rorse (replace 'h' with 'r')
rorse -&gt; rose (remove 'r')
rose -&gt; ros (remove 'e')
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> word1 = "intention", word2 = "execution"
<strong>Output:</strong> 5
<strong>Explanation:</strong> 
intention -&gt; inention (remove 't')
inention -&gt; enention (replace 'i' with 'e')
enention -&gt; exention (replace 'n' with 'x')
exention -&gt; exection (replace 'n' with 'c')
exection -&gt; execution (insert 'u')
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= word1.length, word2.length &lt;= 500
    </code>
   </li>
   <li>
    <code>
     word1
    </code>
    and
    <code>
     word2
    </code>
    consist of lowercase English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 72 -->
<pre>/*
 * @lc app=leetcode id=72 lang=cpp
 *
 * [72] Edit Distance
 */

// @lc code=start
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m=word1.length(),n=word2.length();
        vector&lt;vector&lt;int&gt;&gt;dp(m+1,vector&lt;int&gt;(n+1,0));
        for(int i=1;i&lt;=m;i++){
            dp[i][0]=i;
        }
        for(int j=1;j&lt;=n;j++){
            dp[0][j]=j;
        }
        for(int i=1;i&lt;=m;i++){
            for(int j=1;j&lt;=n;j++){
                if(word1[i-1]==word2[j-1]){
                    dp[i][j]=dp[i-1][j-1];
                }
                else{
                    dp[i][j]=min({dp[i-1][j-1],dp[i][j-1],dp[i-1][j]}) +1;
                }
            }
        }
        for(auto y:dp){
            for(int x:y){
                cout&lt;&lt;x&lt;&lt;&#x27; &#x27;;
            }
            cout&lt;&lt;&#x27;\n&#x27;;
        }
        return dp[m][n];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 73. Set Matrix Zeroes
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an
   <code>
    m x n
   </code>
   integer matrix
   <code>
    matrix
   </code>
   , if an element is
   <code>
    0
   </code>
   , set its entire row and column to
   <code>
    0
   </code>
   's, and return
   <em>
    the matrix
   </em>
   .
  </p>
  <p>
   You must do it
   <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">
    in place
   </a>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/mat1(1).jpg" style="width: 450px; height: 169px;"/>
  <pre><strong>Input:</strong> matrix = [[1,1,1],[1,0,1],[1,1,1]]
<strong>Output:</strong> [[1,0,1],[0,0,0],[1,0,1]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/mat2(1).jpg" style="width: 450px; height: 137px;"/>
  <pre><strong>Input:</strong> matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
<strong>Output:</strong> [[0,0,0,0],[0,4,5,0],[0,3,1,0]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == matrix.length
    </code>
   </li>
   <li>
    <code>
     n == matrix[0].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m, n &lt;= 200
    </code>
   </li>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= matrix[i][j] &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
  </p>
  <ul>
   <li>
    A straightforward solution using
    <code>
     O(mn)
    </code>
    space is probably a bad idea.
   </li>
   <li>
    A simple improvement uses
    <code>
     O(m + n)
    </code>
    space, but still not the best solution.
   </li>
   <li>
    Could you devise a constant space solution?
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 73 -->
<pre>/*
 * @lc app=leetcode id=73 lang=cpp
 *
 * [73] Set Matrix Zeroes
 */

// @lc code=start
class Solution {
public:
    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        vector&lt;pair&lt;int,int&gt;&gt;a;
        for(int i=0;i&lt;matrix.size();i++){
            for(int j=0;j&lt;matrix[0].size();j++){
                if(matrix[i][j]==0){
                    a.push_back({i,j});
                }
            }
        }
        for(auto x:a){
            //cout&lt;&lt;x.first&lt;&lt;x.second&lt;&lt;&#x27;\n&#x27;;
            int m=x.first,n=x.second;
            while(m!=-1){
                matrix[m][n]=0;
                m--;
            }
            m++;
            while(m!=matrix.size()){
                matrix[m][n]=0;
                m++;
            }
            m=x.first;
            while(n!=-1){
                matrix[m][n]=0;
                n--;
            }
            n++;
            while(n!=matrix[0].size()){
                matrix[m][n]=0;
                n++;
            }
        }
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 74. Search a 2D Matrix
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Write an efficient algorithm that searches for a value in an
   <code>
    m x n
   </code>
   matrix. This matrix has the following properties:
  </p>
  <ul>
   <li>
    Integers in each row are sorted from left to right.
   </li>
   <li>
    The first integer of each row is greater than the last integer of the previous row.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/mat.jpg" style="width: 322px; height: 242px;"/>
  <pre><strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/mat2(2).jpg" style="width: 322px; height: 242px;"/>
  <pre><strong>Input:</strong> matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == matrix.length
    </code>
   </li>
   <li>
    <code>
     n == matrix[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m, n &lt;= 100
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= matrix[i][j], target &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 74 -->
<pre>/*
 * @lc app=leetcode id=74 lang=cpp
 *
 * [74] Search a 2D Matrix
 */

// @lc code=start
class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {
        if(matrix.empty() || matrix[0].empty()) return false;
        int m=matrix.size(),n=matrix[0].size();
        int start=0,end=m*n-1;
        while(start&lt;=end) {
            int mid=(start+end)/2;
            int element=matrix[mid/n][mid%n];
            if(target==element)
            {
                return true;
            }
            else if(target&gt;element)
            {
                start=mid+1;
            }
            else if(target&lt;element)
            {
                end=mid-1;
            }
        }
        return false;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 75. Sort Colors
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array
   <code>
    nums
   </code>
   with
   <code>
    n
   </code>
   objects colored red, white, or blue, sort them
   <strong>
    <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">
     in-place
    </a>
   </strong>
   so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
  </p>
  <p>
   We will use the integers
   <code>
    0
   </code>
   ,
   <code>
    1
   </code>
   , and
   <code>
    2
   </code>
   to represent the color red, white, and blue, respectively.
  </p>
  <p>
   You must solve this problem without using the library's sort function.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,0,2,1,1,0]
<strong>Output:</strong> [0,0,1,1,2,2]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,0,1]
<strong>Output:</strong> [0,1,2]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [0]
<strong>Output:</strong> [0]
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1]
<strong>Output:</strong> [1]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == nums.length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 300
    </code>
   </li>
   <li>
    <code>
     nums[i]
    </code>
    is
    <code>
     0
    </code>
    ,
    <code>
     1
    </code>
    , or
    <code>
     2
    </code>
    .
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   Could you come up with a one-pass algorithm using only constant extra space?
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 75 -->
<pre>/*
 * @lc app=leetcode id=75 lang=cpp
 *
 * [75] Sort Colors
 */

// @lc code=start
class Solution {
public:
    void sortColors(vector&lt;int&gt;&amp; a) {
        int count0=0;
        int count1=0;
        int count2=0;
        for(int i=0;i&lt;a.size();i++){
            if(a[i]==0){
                count0++;
            }
            else if(a[i]==1){
                count1++;
            }
            else{
                count2++;
            }
        }
        int i=0,j,k;
        for(i=0;i&lt;count0;i++){
            a[i]=0;
        }
        for(j=0;j&lt;count1;j++){
            a[i+j]=1;
        }
        for(k=0;k&lt;count2;k++){
            a[i+j+k]=2;
        }
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 76. Minimum Window Substring
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two strings
   <code>
    s
   </code>
   and
   <code>
    t
   </code>
   of lengths
   <code>
    m
   </code>
   and
   <code>
    n
   </code>
   respectively, return
   <em>
    the
    <strong>
     minimum window substring
    </strong>
    of
   </em>
   <code>
    s
   </code>
   <em>
    such that every character in
   </em>
   <code>
    t
   </code>
   <em>
    (
    <strong>
     including duplicates
    </strong>
    ) is included in the window. If there is no such substring
   </em>
   <em>
    , return the empty string
   </em>
   <code>
    ""
   </code>
   <em>
    .
   </em>
  </p>
  <p>
   The testcases will be generated such that the answer is
   <strong>
    unique
   </strong>
   .
  </p>
  <p>
   A
   <strong>
    substring
   </strong>
   is a contiguous sequence of characters within the string.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "ADOBECODEBANC", t = "ABC"
<strong>Output:</strong> "BANC"
<strong>Explanation:</strong> The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "a", t = "a"
<strong>Output:</strong> "a"
<strong>Explanation:</strong> The entire string s is the minimum window.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "a", t = "aa"
<strong>Output:</strong> ""
<strong>Explanation:</strong> Both 'a's from t must be included in the window.
Since the largest window of s only has one 'a', return empty string.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == s.length
    </code>
   </li>
   <li>
    <code>
     n == t.length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m, n &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    and
    <code>
     t
    </code>
    consist of uppercase and lowercase English letters.
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow up:
  </strong>
  Could you find an algorithm that runs in
  <code>
   O(m + n)
  </code>
  time?
 </div>
</div>
</body></html>
<!-- Solution for Question 76 -->
<pre>/*
 * @lc app=leetcode id=76 lang=cpp
 *
 * [76] Minimum Window Substring
 */

// @lc code=start
class Solution {
public:

string minWindow(string s, string t) {
    vector&lt;int&gt;m(128,0);
    for(auto x:t) m[x]++;
    int count=t.size(),start=0,end=0,d=INT_MAX,head=0;
    while(end&lt;s.size()){
        if(m[s[end++]]-- &gt;0) count--;
        while(count==0){
            if(d&gt;end-start){
                head=start;
                d=end-start;
            }
            if(m[s[start++]]++==0) count++;
        }

    }
    return d==INT_MAX?&quot;&quot;:s.substr(head,d);

    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 77. Combinations
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two integers
   <code>
    n
   </code>
   and
   <code>
    k
   </code>
   , return
   <em>
    all possible combinations of
   </em>
   <code>
    k
   </code>
   <em>
    numbers out of the range
   </em>
   <code>
    [1, n]
   </code>
   .
  </p>
  <p>
   You may return the answer in
   <strong>
    any order
   </strong>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 4, k = 2
<strong>Output:</strong>
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1, k = 1
<strong>Output:</strong> [[1]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 20
    </code>
   </li>
   <li>
    <code>
     1 &lt;= k &lt;= n
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 77 -->
<pre>/*
 * @lc app=leetcode id=77 lang=cpp
 *
 * [77] Combinations
 */

// @lc code=start
class Solution {
public:
void ans(int i,int n,int k,vector&lt;vector&lt;int&gt;&gt;&amp;a,vector&lt;int&gt;&amp;b){
    if(i&lt;=n+1){
    if(k==0){
        a.push_back(b);
        return;
    }
    b.push_back(i);
    ans(i+1,n,k-1,a,b);
    b.pop_back();
    ans(i+1,n,k,a,b);
    }
}
    vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) {
        int i=1;
        vector&lt;vector&lt;int&gt;&gt;a;
        vector&lt;int&gt;b;
        ans(i,n,k,a,b);
        return a;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 78. Subsets
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   of
   <strong>
    unique
   </strong>
   elements, return
   <em>
    all possible subsets (the power set)
   </em>
   .
  </p>
  <p>
   The solution set
   <strong>
    must not
   </strong>
   contain duplicate subsets. Return the solution in
   <strong>
    any order
   </strong>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [0]
<strong>Output:</strong> [[],[0]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 10
    </code>
   </li>
   <li>
    <code>
     -10 &lt;= nums[i] &lt;= 10
    </code>
   </li>
   <li>
    All the numbers of
    <code>
     nums
    </code>
    are
    <strong>
     unique
    </strong>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 78 -->
<pre>/*
 * @lc app=leetcode id=78 lang=cpp
 *
 * [78] Subsets
 */

// @lc code=start
class Solution {
public:
vector&lt;vector&lt;int&gt;&gt;ans;
    void generate(vector&lt;int&gt;b,vector&lt;int&gt;a,int i){
        ans.push_back(b);
        for(int j=i;j&lt;a.size();j++){
            b.push_back(a[j]);
            generate(b,a,j+1);
            b.pop_back();
        }
    }
    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; a) {
        sort(a.begin(), a.end());
        vector&lt;int&gt;b;
        generate(b,a,0);
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 79. Word Search
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an
   <code>
    m x n
   </code>
   grid of characters
   <code>
    board
   </code>
   and a string
   <code>
    word
   </code>
   , return
   <code>
    true
   </code>
   <em>
    if
   </em>
   <code>
    word
   </code>
   <em>
    exists in the grid
   </em>
   .
  </p>
  <p>
   The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/word2.jpg" style="width: 322px; height: 242px;"/>
  <pre><strong>Input:</strong> board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/word-1.jpg" style="width: 322px; height: 242px;"/>
  <pre><strong>Input:</strong> board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <img alt="" src="./output_files/word3.jpg" style="width: 322px; height: 242px;"/>
  <pre><strong>Input:</strong> board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == board.length
    </code>
   </li>
   <li>
    <code>
     n = board[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m, n &lt;= 6
    </code>
   </li>
   <li>
    <code>
     1 &lt;= word.length &lt;= 15
    </code>
   </li>
   <li>
    <code>
     board
    </code>
    and
    <code>
     word
    </code>
    consists of only lowercase and uppercase English letters.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   Could you use search pruning to make your solution faster with a larger
   <code>
    board
   </code>
   ?
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 79 -->
<pre>/*
 * @lc app=leetcode id=79 lang=cpp
 *
 * [79] Word Search
 */

// @lc code=start
class Solution {
public:
    bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {
        for(int i=0;i&lt;board.size();i++){
            for(int j=0;j&lt;board[0].size();j++){
                if(dfs(board,i,j,word)){
                    return true;
                }

            }
        }
        return false;
    }

    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board,int i,int j,string word)
    {
        if(!word.size()) return true;
        if(i&lt;0 || i&gt;=board.size()||j&lt;0 || j&gt;=board[0].size()||board[i][j]!=word[0]) return false;
        char c = board[i][j];
        board[i][j]=&#x27;*&#x27;;
        string s=word.substr(1);
        bool ret = dfs(board,i-1,j,s) || dfs(board,i+1,j,s) ||dfs(board,i,j-1,s) ||dfs(board,i,j+1,s);
        board[i][j]=c;
        return ret;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 80. Remove Duplicates from Sorted Array II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   sorted in
   <strong>
    non-decreasing order
   </strong>
   , remove some duplicates
   <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">
    <strong>
     in-place
    </strong>
   </a>
   such that each unique element appears
   <strong>
    at most twice
   </strong>
   . The
   <strong>
    relative order
   </strong>
   of the elements should be kept the
   <strong>
    same
   </strong>
   .
  </p>
  <p>
   Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the
   <strong>
    first part
   </strong>
   of the array
   <code>
    nums
   </code>
   . More formally, if there are
   <code>
    k
   </code>
   elements after removing the duplicates, then the first
   <code>
    k
   </code>
   elements of
   <code>
    nums
   </code>
   should hold the final result. It does not matter what you leave beyond the first
   <code>
    k
   </code>
   elements.
  </p>
  <p>
   Return
   <code>
    k
   </code>
   <em>
    after placing the final result in the first
   </em>
   <code>
    k
   </code>
   <em>
    slots of
   </em>
   <code>
    nums
   </code>
   .
  </p>
  <p>
   Do
   <strong>
    not
   </strong>
   allocate extra space for another array. You must do this by
   <strong>
    modifying the input array
    <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">
     in-place
    </a>
   </strong>
   with O(1) extra memory.
  </p>
  <p>
   <strong>
    Custom Judge:
   </strong>
  </p>
  <p>
   The judge will test your solution with the following code:
  </p>
  <pre>int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i &lt; k; i++) {
    assert nums[i] == expectedNums[i];
}
</pre>
  <p>
   If all assertions pass, then your solution will be
   <strong>
    accepted
   </strong>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,1,1,2,2,3]
<strong>Output:</strong> 5, nums = [1,1,2,2,3,_]
<strong>Explanation:</strong> Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [0,0,1,1,1,1,2,3,3]
<strong>Output:</strong> 7, nums = [0,0,1,1,2,3,3,_,_]
<strong>Explanation:</strong> Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 3 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= nums[i] &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     nums
    </code>
    is sorted in
    <strong>
     non-decreasing
    </strong>
    order.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 80 -->
<pre>/*
 * @lc app=leetcode id=80 lang=cpp
 *
 * [80] Remove Duplicates from Sorted Array II
 */

// @lc code=start
class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; a) {
        int n=a.size();
        if(n&lt;3) return n;
        int index=2;
        for(int i=2; i&lt;n; i++){
            if(a[i]!=a[index-2]){
                a[index]=a[i];
                index++;
            }
        }
        return index;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 81. Search in Rotated Sorted Array II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   There is an integer array
   <code>
    nums
   </code>
   sorted in non-decreasing order (not necessarily with
   <strong>
    distinct
   </strong>
   values).
  </p>
  <p>
   Before being passed to your function,
   <code>
    nums
   </code>
   is
   <strong>
    rotated
   </strong>
   at an unknown pivot index
   <code>
    k
   </code>
   (
   <code>
    0 &lt;= k &lt; nums.length
   </code>
   ) such that the resulting array is
   <code>
    [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]
   </code>
   (
   <strong>
    0-indexed
   </strong>
   ). For example,
   <code>
    [0,1,2,4,4,4,5,6,6,7]
   </code>
   might be rotated at pivot index
   <code>
    5
   </code>
   and become
   <code>
    [4,5,6,6,7,0,1,2,4,4]
   </code>
   .
  </p>
  <p>
   Given the array
   <code>
    nums
   </code>
   <strong>
    after
   </strong>
   the rotation and an integer
   <code>
    target
   </code>
   , return
   <code>
    true
   </code>
   <em>
    if
   </em>
   <code>
    target
   </code>
   <em>
    is in
   </em>
   <code>
    nums
   </code>
   <em>
    , or
   </em>
   <code>
    false
   </code>
   <em>
    if it is not in
   </em>
   <code>
    nums
   </code>
   <em>
    .
   </em>
  </p>
  <p>
   You must decrease the overall operation steps as much as possible.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,5,6,0,0,1,2], target = 0
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,5,6,0,0,1,2], target = 3
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 5000
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= nums[i] &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     nums
    </code>
    is guaranteed to be rotated at some pivot.
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= target &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   This problem is similar to
   <a href="https://bishalsarang.github.io/problems/search-in-rotated-sorted-array/description/" target="_blank">
    Search in Rotated Sorted Array
   </a>
   , but
   <code>
    nums
   </code>
   may contain
   <strong>
    duplicates
   </strong>
   . Would this affect the runtime complexity? How and why?
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 81 -->
<pre>/*
 * @lc app=leetcode id=81 lang=cpp
 *
 * [81] Search in Rotated Sorted Array II
 */

// @lc code=start
class Solution {
public:
    bool search(vector&lt;int&gt;&amp; a, int target) {
        int start=0,end=a.size()-1;
        while(start&lt;=end){
            int mid=(start+end)/2;
            cout&lt;&lt;mid;
            if(a[mid]==target) return true;
            else if(a[mid]==a[start] &amp;&amp; a[mid]==a[end]){
                start++;
                end--;
            }
            else if(a[mid]&gt;=a[start])
            {
                if( target &gt;= a[start] &amp;&amp; a[mid]&gt;target)
                {
                    end=mid-1;
                }
                else start=mid+1;
            }
            else
            {
                if(target&gt;a[mid] &amp;&amp; a[end] &gt;= target) start = mid +1;
                else end=mid-1;
            }
        }
        return false;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 82. Remove Duplicates from Sorted List II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    head
   </code>
   of a sorted linked list,
   <em>
    delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list
   </em>
   . Return
   <em>
    the linked list
    <strong>
     sorted
    </strong>
    as well
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/linkedlist1.jpg" style="width: 500px; height: 142px;"/>
  <pre><strong>Input:</strong> head = [1,2,3,3,4,4,5]
<strong>Output:</strong> [1,2,5]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/linkedlist2.jpg" style="width: 500px; height: 205px;"/>
  <pre><strong>Input:</strong> head = [1,1,1,2,3]
<strong>Output:</strong> [2,3]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the list is in the range
    <code>
     [0, 300]
    </code>
    .
   </li>
   <li>
    <code>
     -100 &lt;= Node.val &lt;= 100
    </code>
   </li>
   <li>
    The list is guaranteed to be
    <strong>
     sorted
    </strong>
    in ascending order.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 82 -->
<pre>/*
 * @lc app=leetcode id=82 lang=cpp
 *
 * [82] Remove Duplicates from Sorted List II
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* temp,*ptr;
        map&lt;int,int&gt;m;
        temp=new ListNode(INT_MAX-1);
        temp-&gt;next=head;
        head=temp;
        while(temp!=NULL){
            m[temp-&gt;val]++;
            temp=temp-&gt;next;
        }
        temp=head;
        while(temp!=NULL){
            if(m[temp-&gt;val]==1){
                ptr=temp;
                temp=temp-&gt;next;
            }
            else{
                ptr-&gt;next=temp-&gt;next;
                temp=temp-&gt;next;
            }
        }
        return head-&gt;next;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 83. Remove Duplicates from Sorted List
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    head
   </code>
   of a sorted linked list,
   <em>
    delete all duplicates such that each element appears only once
   </em>
   . Return
   <em>
    the linked list
    <strong>
     sorted
    </strong>
    as well
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/list1.jpg" style="width: 302px; height: 242px;"/>
  <pre><strong>Input:</strong> head = [1,1,2]
<strong>Output:</strong> [1,2]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/list2.jpg" style="width: 542px; height: 222px;"/>
  <pre><strong>Input:</strong> head = [1,1,2,3,3]
<strong>Output:</strong> [1,2,3]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the list is in the range
    <code>
     [0, 300]
    </code>
    .
   </li>
   <li>
    <code>
     -100 &lt;= Node.val &lt;= 100
    </code>
   </li>
   <li>
    The list is guaranteed to be
    <strong>
     sorted
    </strong>
    in ascending order.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 83 -->
<pre>/*
 * @lc app=leetcode id=83 lang=cpp
 *
 * [83] Remove Duplicates from Sorted List
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(head==NULL) return NULL;
        while(head-&gt;next!=NULL &amp;&amp; head-&gt;val==head-&gt;next-&gt;val){
            head=head-&gt;next;
        }
        ListNode *temp=head,*ptr=head;
        while(temp!=NULL){
            if(temp-&gt;next!=NULL &amp;&amp; temp-&gt;val==temp-&gt;next-&gt;val ){
                ptr-&gt;next=temp-&gt;next;
            }
            else{
                ptr=temp;
            }
            temp=temp-&gt;next;
        }
        return head;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 84. Largest Rectangle in Histogram
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of integers
   <code>
    heights
   </code>
   representing the histogram's bar height where the width of each bar is
   <code>
    1
   </code>
   , return
   <em>
    the area of the largest rectangle in the histogram
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/histogram.jpg" style="width: 522px; height: 242px;"/>
  <pre><strong>Input:</strong> heights = [2,1,5,6,2,3]
<strong>Output:</strong> 10
<strong>Explanation:</strong> The above is a histogram where width of each bar is 1.
The largest rectangle is shown in the red area, which has an area = 10 units.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/histogram-1.jpg" style="width: 202px; height: 362px;"/>
  <pre><strong>Input:</strong> heights = [2,4]
<strong>Output:</strong> 4
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= heights.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= heights[i] &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 84 -->
<pre>/*
 * @lc app=leetcode id=84 lang=cpp
 *
 * [84] Largest Rectangle in Histogram
 */

// @lc code=start
class Solution {
public:
    int largestRectangleArea(vector&lt;int&gt;&amp; a) {
        stack&lt;int&gt;s;
        a.push_back(0);
        int maxx=0;
        for(int i = 0; i &lt; a.size();i++){
            if(s.empty() || a[i] &gt;= a[s.top()]){
                s.push(i);
            }
            else{
                int temp=a[s.top()];
                s.pop();
                if(s.empty()){
                    maxx = max(maxx, temp*i);
                }
                else{
                    maxx = max(maxx, temp*(i-1-s.top()));
                }
                i--;
            }
        }
        return maxx;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 85. Maximal Rectangle
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a
   <code>
    rows x cols
   </code>
   binary
   <code>
    matrix
   </code>
   filled with
   <code>
    0
   </code>
   's and
   <code>
    1
   </code>
   's, find the largest rectangle containing only
   <code>
    1
   </code>
   's and return
   <em>
    its area
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/maximal.jpg" style="width: 402px; height: 322px;"/>
  <pre><strong>Input:</strong> matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The maximal rectangle is shown in the above picture.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> matrix = []
<strong>Output:</strong> 0
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> matrix = [["0"]]
<strong>Output:</strong> 0
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> matrix = [["1"]]
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> matrix = [["0","0"]]
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     rows == matrix.length
    </code>
   </li>
   <li>
    <code>
     cols == matrix[i].length
    </code>
   </li>
   <li>
    <code>
     0 &lt;= row, cols &lt;= 200
    </code>
   </li>
   <li>
    <code>
     matrix[i][j]
    </code>
    is
    <code>
     '0'
    </code>
    or
    <code>
     '1'
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 85 -->
<pre>/*
 * @lc app=leetcode id=85 lang=cpp
 *
 * [85] Maximal Rectangle
 */

// @lc code=start
class Solution {
public:
    int largestRectangleArea(vector&lt;int&gt;&amp; a) {
        stack&lt;int&gt;s;
        a.push_back(0);
        int maxx=0;
        for(int i = 0; i &lt; a.size();i++){
            if(s.empty() || a[i] &gt;= a[s.top()]){
                s.push(i);
            }
            else{
                int temp=a[s.top()];
                s.pop();
                if(s.empty()){
                    maxx = max(maxx, temp*i);
                }
                else{
                    maxx = max(maxx, temp*(i-1-s.top()));
                }
                i--;
            }
        }
        return maxx;
    }

    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; a) {
        vector&lt;int&gt;b(a[0].size(),0);
        int area=0;
        for(int i = 0; i &lt; a.size();i++){
            for(int j = 0; j &lt; a[i].size();j++){
                if(a[i][j]==&#x27;0&#x27;){
                    b[j]=0;
                }
                else{
                    b[j]++;
                }
            }
            area=max(area,largestRectangleArea(b));
        }
        return area;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 86. Partition List
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    head
   </code>
   of a linked list and a value
   <code>
    x
   </code>
   , partition it such that all nodes
   <strong>
    less than
   </strong>
   <code>
    x
   </code>
   come before nodes
   <strong>
    greater than or equal
   </strong>
   to
   <code>
    x
   </code>
   .
  </p>
  <p>
   You should
   <strong>
    preserve
   </strong>
   the original relative order of the nodes in each of the two partitions.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/partition.jpg" style="width: 662px; height: 222px;"/>
  <pre><strong>Input:</strong> head = [1,4,3,2,5,2], x = 3
<strong>Output:</strong> [1,2,2,4,3,5]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> head = [2,1], x = 2
<strong>Output:</strong> [1,2]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the list is in the range
    <code>
     [0, 200]
    </code>
    .
   </li>
   <li>
    <code>
     -100 &lt;= Node.val &lt;= 100
    </code>
   </li>
   <li>
    <code>
     -200 &lt;= x &lt;= 200
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 86 -->
<pre>/*
 * @lc app=leetcode id=86 lang=cpp
 *
 * [86] Partition List
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode *fast=head;
        ListNode *temp=new ListNode(0);
        ListNode *t=temp;
        ListNode *temp1=new ListNode(0);
        ListNode *t1=temp1;
        while(fast!=NULL){
            if(fast-&gt;val&lt;x){
                t-&gt;next=new ListNode(fast-&gt;val);
                t=t-&gt;next;
            }
            else{
                t1-&gt;next=new ListNode(fast-&gt;val);
                t1=t1-&gt;next;
            }
            fast=fast-&gt;next;
        }
        t-&gt;next=temp1-&gt;next;
        return temp-&gt;next;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 87. Scramble String
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   We can scramble a string s to get a string t using the following algorithm:
  </p>
  <ol>
   <li>
    If the length of the string is 1, stop.
   </li>
   <li>
    If the length of the string is &gt; 1, do the following:
    <ul>
     <li>
      Split the string into two non-empty substrings at a random index, i.e., if the string is
      <code>
       s
      </code>
      , divide it to
      <code>
       x
      </code>
      and
      <code>
       y
      </code>
      where
      <code>
       s = x + y
      </code>
      .
     </li>
     <li>
      <strong>
       Randomly
      </strong>
      decide to swap the two substrings or to keep them in the same order. i.e., after this step,
      <code>
       s
      </code>
      may become
      <code>
       s = x + y
      </code>
      or
      <code>
       s = y + x
      </code>
      .
     </li>
     <li>
      Apply step 1 recursively on each of the two substrings
      <code>
       x
      </code>
      and
      <code>
       y
      </code>
      .
     </li>
    </ul>
   </li>
  </ol>
  <p>
   Given two strings
   <code>
    s1
   </code>
   and
   <code>
    s2
   </code>
   of
   <strong>
    the same length
   </strong>
   , return
   <code>
    true
   </code>
   if
   <code>
    s2
   </code>
   is a scrambled string of
   <code>
    s1
   </code>
   , otherwise, return
   <code>
    false
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s1 = "great", s2 = "rgeat"
<strong>Output:</strong> true
<strong>Explanation:</strong> One possible scenario applied on s1 is:
"great" --&gt; "gr/eat" // divide at random index.
"gr/eat" --&gt; "gr/eat" // random decision is not to swap the two substrings and keep them in order.
"gr/eat" --&gt; "g/r / e/at" // apply the same algorithm recursively on both substrings. divide at ranom index each of them.
"g/r / e/at" --&gt; "r/g / e/at" // random decision was to swap the first substring and to keep the second substring in the same order.
"r/g / e/at" --&gt; "r/g / e/ a/t" // again apply the algorithm recursively, divide "at" to "a/t".
"r/g / e/ a/t" --&gt; "r/g / e/ a/t" // random decision is to keep both substrings in the same order.
The algorithm stops now and the result string is "rgeat" which is s2.
As there is one possible scenario that led s1 to be scrambled to s2, we return true.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s1 = "abcde", s2 = "caebd"
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s1 = "a", s2 = "a"
<strong>Output:</strong> true
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     s1.length == s2.length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= s1.length &lt;= 30
    </code>
   </li>
   <li>
    <code>
     s1
    </code>
    and
    <code>
     s2
    </code>
    consist of lower-case English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 87 -->
<pre>/*
 * @lc app=leetcode id=87 lang=cpp
 *
 * [87] Scramble String
 */

// @lc code=start
class Solution {
public:
    bool isScramble(string s1, string s2) {

    }
};
// @lc code=end 

</pre><html><head></head><body>
<div id="title">
 88. Merge Sorted Array
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given two integer arrays
   <code>
    nums1
   </code>
   and
   <code>
    nums2
   </code>
   , sorted in
   <strong>
    non-decreasing order
   </strong>
   , and two integers
   <code>
    m
   </code>
   and
   <code>
    n
   </code>
   , representing the number of elements in
   <code>
    nums1
   </code>
   and
   <code>
    nums2
   </code>
   respectively.
  </p>
  <p>
   <strong>
    Merge
   </strong>
   <code>
    nums1
   </code>
   and
   <code>
    nums2
   </code>
   into a single array sorted in
   <strong>
    non-decreasing order
   </strong>
   .
  </p>
  <p>
   The final sorted array should not be returned by the function, but instead be
   <em>
    stored inside the array
   </em>
   <code>
    nums1
   </code>
   . To accommodate this,
   <code>
    nums1
   </code>
   has a length of
   <code>
    m + n
   </code>
   , where the first
   <code>
    m
   </code>
   elements denote the elements that should be merged, and the last
   <code>
    n
   </code>
   elements are set to
   <code>
    0
   </code>
   and should be ignored.
   <code>
    nums2
   </code>
   has a length of
   <code>
    n
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
<strong>Output:</strong> [1,2,2,3,5,6]
<strong>Explanation:</strong> The arrays we are merging are [1,2,3] and [2,5,6].
The result of the merge is [<u>1</u>,<u>2</u>,2,<u>3</u>,5,6] with the underlined elements coming from nums1.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums1 = [1], m = 1, nums2 = [], n = 0
<strong>Output:</strong> [1]
<strong>Explanation:</strong> The arrays we are merging are [1] and [].
The result of the merge is [1].
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums1 = [0], m = 0, nums2 = [1], n = 1
<strong>Output:</strong> [1]
<strong>Explanation:</strong> The arrays we are merging are [] and [1].
The result of the merge is [1].
Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     nums1.length == m + n
    </code>
   </li>
   <li>
    <code>
     nums2.length == n
    </code>
   </li>
   <li>
    <code>
     0 &lt;= m, n &lt;= 200
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m + n &lt;= 200
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      9
     </sup>
     &lt;= nums1[i], nums2[j] &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   Can you come up with an algorithm that runs in
   <code>
    O(m + n)
   </code>
   time?
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 88 -->
<pre>/*
 * @lc app=leetcode id=88 lang=cpp
 *
 * [88] Merge Sorted Array
 */

// @lc code=start
class Solution {
public:
    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
        for(int i=0; i&lt;m; i++)
        {
            int ins=lower_bound(nums2.begin(), nums2.end(),nums1[i])-nums2.begin();
            nums2.insert(nums2.begin()+ins,nums1[i]);
        }
        nums1=nums2;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 89. Gray Code
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   An
   <strong>
    n-bit gray code sequence
   </strong>
   is a sequence of
   <code>
    2
    <sup>
     n
    </sup>
   </code>
   integers where:
  </p>
  <ul>
   <li>
    Every integer is in the
    <strong>
     inclusive
    </strong>
    range
    <code>
     [0, 2
     <sup>
      n
     </sup>
     - 1]
    </code>
    ,
   </li>
   <li>
    The first integer is
    <code>
     0
    </code>
    ,
   </li>
   <li>
    An integer appears
    <strong>
     no more than once
    </strong>
    in the sequence,
   </li>
   <li>
    The binary representation of every pair of
    <strong>
     adjacent
    </strong>
    integers differs by
    <strong>
     exactly one bit
    </strong>
    , and
   </li>
   <li>
    The binary representation of the
    <strong>
     first
    </strong>
    and
    <strong>
     last
    </strong>
    integers differs by
    <strong>
     exactly one bit
    </strong>
    .
   </li>
  </ul>
  <p>
   Given an integer
   <code>
    n
   </code>
   , return
   <em>
    any valid
    <strong>
     n-bit gray code sequence
    </strong>
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 2
<strong>Output:</strong> [0,1,3,2]
<strong>Explanation:</strong>
The binary representation of [0,1,3,2] is [00,01,11,10].
- 0<u>0</u> and 0<u>1</u> differ by one bit
- <u>0</u>1 and <u>1</u>1 differ by one bit
- 1<u>1</u> and 1<u>0</u> differ by one bit
- <u>1</u>0 and <u>0</u>0 differ by one bit
[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].
- <u>0</u>0 and <u>1</u>0 differ by one bit
- 1<u>0</u> and 1<u>1</u> differ by one bit
- <u>1</u>1 and <u>0</u>1 differ by one bit
- 0<u>1</u> and 0<u>0</u> differ by one bit
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1
<strong>Output:</strong> [0,1]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 16
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 89 -->
<pre>/*
 * @lc app=leetcode id=89 lang=cpp
 *
 * [89] Gray Code
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt;ans;
    vector&lt;int&gt; grayCode(int n) {
        for(int i=0; i&lt;(1&lt;&lt;n); i++){
            ans.push_back(i^(i&gt;&gt;1));
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 90. Subsets II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   that may contain duplicates, return
   <em>
    all possible subsets (the power set)
   </em>
   .
  </p>
  <p>
   The solution set
   <strong>
    must not
   </strong>
   contain duplicate subsets. Return the solution in
   <strong>
    any order
   </strong>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,2]
<strong>Output:</strong> [[],[1],[1,2],[1,2,2],[2],[2,2]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [0]
<strong>Output:</strong> [[],[0]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 10
    </code>
   </li>
   <li>
    <code>
     -10 &lt;= nums[i] &lt;= 10
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 90 -->
<pre>/*
 * @lc app=leetcode id=90 lang=cpp
 *
 * [90] Subsets II
 */

// @lc code=start
class Solution {
public:
vector&lt;vector&lt;int&gt;&gt;ans;
    void generate(vector&lt;int&gt;b,vector&lt;int&gt;a,int i){
        ans.push_back(b);
        for(int j=i;j&lt;a.size();j++){
            if(j&gt;i &amp;&amp; a[j]==a[j-1]) continue;
            b.push_back(a[j]);
            generate(b,a,j+1);
            b.pop_back();
        }
    }
    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; a) {
        sort(a.begin(), a.end());
        vector&lt;int&gt;b;
        generate(b,a,0);
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 91. Decode Ways
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   A message containing letters from
   <code>
    A-Z
   </code>
   can be
   <strong>
    encoded
   </strong>
   into numbers using the following mapping:
  </p>
  <pre>'A' -&gt; "1"
'B' -&gt; "2"
...
'Z' -&gt; "26"
</pre>
  <p>
   To
   <strong>
    decode
   </strong>
   an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example,
   <code>
    "11106"
   </code>
   can be mapped into:
  </p>
  <ul>
   <li>
    <code>
     "AAJF"
    </code>
    with the grouping
    <code>
     (1 1 10 6)
    </code>
   </li>
   <li>
    <code>
     "KJF"
    </code>
    with the grouping
    <code>
     (11 10 6)
    </code>
   </li>
  </ul>
  <p>
   Note that the grouping
   <code>
    (1 11 06)
   </code>
   is invalid because
   <code>
    "06"
   </code>
   cannot be mapped into
   <code>
    'F'
   </code>
   since
   <code>
    "6"
   </code>
   is different from
   <code>
    "06"
   </code>
   .
  </p>
  <p>
   Given a string
   <code>
    s
   </code>
   containing only digits, return
   <em>
    the
    <strong>
     number
    </strong>
    of ways to
    <strong>
     decode
    </strong>
    it
   </em>
   .
  </p>
  <p>
   The answer is guaranteed to fit in a
   <strong>
    32-bit
   </strong>
   integer.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "12"
<strong>Output:</strong> 2
<strong>Explanation:</strong> "12" could be decoded as "AB" (1 2) or "L" (12).
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "226"
<strong>Output:</strong> 3
<strong>Explanation:</strong> "226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "0"
<strong>Output:</strong> 0
<strong>Explanation:</strong> There is no character that is mapped to a number starting with 0.
The only valid mappings with 0 are 'J' -&gt; "10" and 'T' -&gt; "20", neither of which start with 0.
Hence, there are no valid ways to decode this since all digits need to be mapped.
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "06"
<strong>Output:</strong> 0
<strong>Explanation:</strong> "06" cannot be mapped to "F" because of the leading zero ("6" is different from "06").
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    contains only digits and may contain leading zero(s).
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 91 -->
<pre>/*
 * @lc app=leetcode id=91 lang=cpp
 *
 * [91] Decode Ways
 */

// @lc code=start
class Solution {
public:
    int generate(string s,int i,vector&lt;int&gt;&amp; dp){
        if(s.size()==i) return 1;
        if(s[i]==&#x27;0&#x27;) return 0;
        if(s.size()-1==i) return 1;
        if(dp[i]!=0) return dp[i];
        string t=s.substr(i,2);
        int way1=generate(s,i+1,dp);
        int way2=0;
        if(stoi(t)&lt;=26 &amp;&amp; stoi(t)&gt;0) way2=generate(s,i+2,dp);
        return dp[i]=way1+way2;
    }
    int numDecodings(string s) {
         vector&lt;int&gt; dp(s.size()+1,0);
         int ans=0;
         ans=generate(s,0,dp);
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 92. Reverse Linked List II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    head
   </code>
   of a singly linked list and two integers
   <code>
    left
   </code>
   and
   <code>
    right
   </code>
   where
   <code>
    left &lt;= right
   </code>
   , reverse the nodes of the list from position
   <code>
    left
   </code>
   to position
   <code>
    right
   </code>
   , and return
   <em>
    the reversed list
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/rev2ex2.jpg" style="width: 542px; height: 222px;"/>
  <pre><strong>Input:</strong> head = [1,2,3,4,5], left = 2, right = 4
<strong>Output:</strong> [1,4,3,2,5]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> head = [5], left = 1, right = 1
<strong>Output:</strong> [5]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the list is
    <code>
     n
    </code>
    .
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 500
    </code>
   </li>
   <li>
    <code>
     -500 &lt;= Node.val &lt;= 500
    </code>
   </li>
   <li>
    <code>
     1 &lt;= left &lt;= right &lt;= n
    </code>
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow up:
  </strong>
  Could you do it in one pass?
 </div>
</div>
</body></html>
<!-- Solution for Question 92 -->
<pre>/*
 * @lc app=leetcode id=92 lang=cpp
 *
 * [92] Reverse Linked List II
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int left, int right) {
     if(head==NULL) return NULL;
     if(left&gt;=right) return head;
      ListNode *temp=head,*ptr,*ptr2;
      for(int i=0; i&lt;left; i++){
        ptr2=temp;
        temp=temp-&gt;next;
      }
      for(int i=0; i&lt;right-left; i++){
        ptr=temp;
        temp=temp-&gt;next;
      }
      swap(ptr-&gt;val,ptr2-&gt;val);
      return reverseBetween(head,left+1,right-1);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 93. Restore IP Addresses
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    s
   </code>
   containing only digits, return all possible valid IP addresses that can be obtained from
   <code>
    s
   </code>
   . You can return them in
   <strong>
    any
   </strong>
   order.
  </p>
  <p>
   A
   <strong>
    valid IP address
   </strong>
   consists of exactly four integers, each integer is between
   <code>
    0
   </code>
   and
   <code>
    255
   </code>
   , separated by single dots and cannot have leading zeros. For example, "0.1.2.201" and "192.168.1.1" are
   <strong>
    valid
   </strong>
   IP addresses and "0.011.255.245", "192.168.1.312" and "192.168@1.1" are
   <strong>
    invalid
   </strong>
   IP addresses.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "25525511135"
<strong>Output:</strong> ["255.255.11.135","255.255.111.35"]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "0000"
<strong>Output:</strong> ["0.0.0.0"]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "1111"
<strong>Output:</strong> ["1.1.1.1"]
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "010010"
<strong>Output:</strong> ["0.10.0.10","0.100.1.0"]
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "101023"
<strong>Output:</strong> ["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= s.length &lt;= 3000
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consists of digits only.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 93 -->
<pre>/*
 * @lc app=leetcode id=93 lang=cpp
 *
 * [93] Restore IP Addresses
 */

// @lc code=start
class Solution {
public:
    vector&lt;string&gt;ans;
    bool check(string s){
        if(s.length()&gt;1 &amp;&amp; s[0]==&#x27;0&#x27;) return false;
        return true;
    }
    void backtrack(string s,int i,string temp,string mini,int dot){
        if(i==s.length() &amp;&amp; dot==4){
            ans.push_back(temp.substr(0,temp.length()-1));
            return;
        }
        if(dot==4 || i==s.length()){
            return;
        }
        cout&lt;&lt;mini&lt;&lt;&#x27;\n&#x27;;
        if(mini.length()&lt;3 &amp;&amp; stoi(mini+s[i])&lt;=255 &amp;&amp; i&lt;s.length() &amp;&amp; check(mini+s[i])){
        backtrack(s,i+1,temp+s[i],mini+s[i],dot);
        backtrack(s,i+1,temp+s[i]+&#x27;.&#x27;,&quot;&quot;,dot+1);
        }

    }
    vector&lt;string&gt; restoreIpAddresses(string s) {
        backtrack(s,0,&quot;&quot;,&quot;&quot;,0);
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 94. Binary Tree Inorder Traversal
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree, return
   <em>
    the inorder traversal of its nodes' values
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/inorder_1.jpg" style="width: 202px; height: 324px;"/>
  <pre><strong>Input:</strong> root = [1,null,2,3]
<strong>Output:</strong> [1,3,2]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1]
<strong>Output:</strong> [1]
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <img alt="" src="./output_files/inorder_5.jpg" style="width: 202px; height: 202px;"/>
  <pre><strong>Input:</strong> root = [1,2]
<strong>Output:</strong> [2,1]
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <img alt="" src="./output_files/inorder_4.jpg" style="width: 202px; height: 202px;"/>
  <pre><strong>Input:</strong> root = [1,null,2]
<strong>Output:</strong> [1,2]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [0, 100]
    </code>
    .
   </li>
   <li>
    <code>
     -100 &lt;= Node.val &lt;= 100
    </code>
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow up:
  </strong>
  Recursive solution is trivial, could you do it iteratively?
 </div>
</div>
</body></html>
<!-- Solution for Question 94 -->
<pre>/*
 * @lc app=leetcode id=94 lang=cpp
 *
 * [94] Binary Tree Inorder Traversal
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
 void inorder(TreeNode *root,vector&lt;int&gt;&amp;a)
 {
        if(root!=NULL)
        {
            inorder(root-&gt;left,a);
            a.push_back(root-&gt;val);
            inorder(root-&gt;right,a);
        }
 }
    vector&lt;int&gt; inorderTraversal(TreeNode* root) {
        vector&lt;int&gt;a;
        inorder(root,a);
        return a;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 95. Unique Binary Search Trees II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer
   <code>
    n
   </code>
   , return
   <em>
    all the structurally unique
    <strong>
     BST'
    </strong>
    s (binary search trees), which has exactly
   </em>
   <code>
    n
   </code>
   <em>
    nodes of unique values from
   </em>
   <code>
    1
   </code>
   <em>
    to
   </em>
   <code>
    n
   </code>
   . Return the answer in
   <strong>
    any order
   </strong>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/uniquebstn3.jpg" style="width: 600px; height: 148px;"/>
  <pre><strong>Input:</strong> n = 3
<strong>Output:</strong> [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1
<strong>Output:</strong> [[1]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 8
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 95 -->
<pre>/*
 * @lc app=leetcode id=95 lang=cpp
 *
 * [95] Unique Binary Search Trees II
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;TreeNode *&gt; generate(int start,int end){
        vector&lt;TreeNode *&gt;ans;
        if(start&gt;end){
            ans.push_back(NULL);
            return ans;
        }
        for(int i=start;i&lt;=end;i++){
            vector&lt;TreeNode *&gt;lefts=generate(start,i-1);
            vector&lt;TreeNode *&gt;rights=generate(i+1,end);
            for(int j=0;j&lt;lefts.size();j++){
                for(int k=0;k&lt;rights.size();k++){
                    TreeNode* root = new TreeNode(i);
                    root-&gt;left = lefts[j];
                    root-&gt;right = rights[k];
                    ans.push_back(root);
                }
            }
        }
        return ans;
    }
    vector&lt;TreeNode*&gt; generateTrees(int n) {
        return generate(1,n);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 96. Unique Binary Search Trees
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer
   <code>
    n
   </code>
   , return
   <em>
    the number of structurally unique
    <strong>
     BST'
    </strong>
    s (binary search trees) which has exactly
   </em>
   <code>
    n
   </code>
   <em>
    nodes of unique values from
   </em>
   <code>
    1
   </code>
   <em>
    to
   </em>
   <code>
    n
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/uniquebstn3.jpg" style="width: 600px; height: 148px;"/>
  <pre><strong>Input:</strong> n = 3
<strong>Output:</strong> 5
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 19
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 96 -->
<pre>/*
 * @lc app=leetcode id=96 lang=cpp
 *
 * [96] Unique Binary Search Trees
 */

// @lc code=start
class Solution {
public:
    int numTrees(int n) {
        vector&lt;int&gt;dp(n+1,0);
        dp[0]=1;
        dp[1]=1;
        for(int i=2; i&lt;=n; i++){
            for(int j=1; j&lt;=i; j++){
                dp[i]+=dp[i-j]*dp[j-1];
            }
        }
        for(auto y:dp){
                cout&lt;&lt;y&lt;&lt;&#x27; &#x27;;
        }
        return dp[n];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 97. Interleaving String
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given strings
   <code>
    s1
   </code>
   ,
   <code>
    s2
   </code>
   , and
   <code>
    s3
   </code>
   , find whether
   <code>
    s3
   </code>
   is formed by an
   <strong>
    interleaving
   </strong>
   of
   <code>
    s1
   </code>
   and
   <code>
    s2
   </code>
   .
  </p>
  <p>
   An
   <strong>
    interleaving
   </strong>
   of two strings
   <code>
    s
   </code>
   and
   <code>
    t
   </code>
   is a configuration where they are divided into
   <strong>
    non-empty
   </strong>
   substrings such that:
  </p>
  <ul>
   <li>
    <code>
     s = s
     <sub>
      1
     </sub>
     + s
     <sub>
      2
     </sub>
     + ... + s
     <sub>
      n
     </sub>
    </code>
   </li>
   <li>
    <code>
     t = t
     <sub>
      1
     </sub>
     + t
     <sub>
      2
     </sub>
     + ... + t
     <sub>
      m
     </sub>
    </code>
   </li>
   <li>
    <code>
     |n - m| &lt;= 1
    </code>
   </li>
   <li>
    The
    <strong>
     interleaving
    </strong>
    is
    <code>
     s
     <sub>
      1
     </sub>
     + t
     <sub>
      1
     </sub>
     + s
     <sub>
      2
     </sub>
     + t
     <sub>
      2
     </sub>
     + s
     <sub>
      3
     </sub>
     + t
     <sub>
      3
     </sub>
     + ...
    </code>
    or
    <code>
     t
     <sub>
      1
     </sub>
     + s
     <sub>
      1
     </sub>
     + t
     <sub>
      2
     </sub>
     + s
     <sub>
      2
     </sub>
     + t
     <sub>
      3
     </sub>
     + s
     <sub>
      3
     </sub>
     + ...
    </code>
   </li>
  </ul>
  <p>
   <strong>
    Note:
   </strong>
   <code>
    a + b
   </code>
   is the concatenation of strings
   <code>
    a
   </code>
   and
   <code>
    b
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/interleave.jpg" style="width: 561px; height: 203px;"/>
  <pre><strong>Input:</strong> s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s1 = "", s2 = "", s3 = ""
<strong>Output:</strong> true
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= s1.length, s2.length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     0 &lt;= s3.length &lt;= 200
    </code>
   </li>
   <li>
    <code>
     s1
    </code>
    ,
    <code>
     s2
    </code>
    , and
    <code>
     s3
    </code>
    consist of lowercase English letters.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   Could you solve it using only
   <code>
    O(s2.length)
   </code>
   additional memory space?
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 97 -->
<pre>/*
 * @lc app=leetcode id=97 lang=cpp
 *
 * [97] Interleaving String
 */

// @lc code=start
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        int n1,n2,n3;
        n1 = s1.size();
        n2 = s2.size();
        n3 = s3.size();
        if(n1 + n2 != n3) return false;
        vector&lt;vector&lt;bool&gt;&gt;dp(n1+1,vector&lt;bool&gt;(n2+1,false));
        dp[0][0]= true;
        for(int i=1; i&lt;=n1;i++) dp[i][0] = dp[i-1][0] &amp;&amp; s1[i-1]==s3[i-1];
        for(int i=1; i&lt;=n2;i++) dp[0][i] = dp[0][i-1] &amp;&amp; s2[i-1]==s3[i-1];

        for(int i=1;i&lt;=n1;i++){
            for(int j=1;j&lt;=n2;j++){
                dp[i][j]=(dp[i-1][j] &amp;&amp; s1[i-1]==s3[i+j-1])||(dp[i][j-1] &amp;&amp; s2[j-1]==s3[i+j-1]);
            } 
        }

        for(auto y:dp){
            for(int x:y){
                cout&lt;&lt;x&lt;&lt;&#x27; &#x27;;
            }
            cout&lt;&lt;&#x27;\n&#x27;;
        }

        return dp[n1][n2];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 98. Validate Binary Search Tree
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree,
   <em>
    determine if it is a valid binary search tree (BST)
   </em>
   .
  </p>
  <p>
   A
   <strong>
    valid BST
   </strong>
   is defined as follows:
  </p>
  <ul>
   <li>
    The left subtree of a node contains only nodes with keys
    <strong>
     less than
    </strong>
    the node's key.
   </li>
   <li>
    The right subtree of a node contains only nodes with keys
    <strong>
     greater than
    </strong>
    the node's key.
   </li>
   <li>
    Both the left and right subtrees must also be binary search trees.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/tree1(1).jpg" style="width: 302px; height: 182px;"/>
  <pre><strong>Input:</strong> root = [2,1,3]
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/tree2(1).jpg" style="width: 422px; height: 292px;"/>
  <pre><strong>Input:</strong> root = [5,1,4,null,null,3,6]
<strong>Output:</strong> false
<strong>Explanation:</strong> The root node's value is 5 but its right child's value is 4.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [1, 10
     <sup>
      4
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= Node.val &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 98 -->
<pre>/*
 * @lc app=leetcode id=98 lang=cpp
 *
 * [98] Validate Binary Search Tree
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
vector&lt;int&gt;a;
    void inorder(TreeNode* root){
        if(root!=NULL){
            inorder(root-&gt;left);
            a.push_back(root-&gt;val);
            inorder(root-&gt;right);
        }
    }
    bool isValidBST(TreeNode* root) {
        inorder(root);
        for(int i=0;i&lt;a.size()-1;i++)
        {
            if(a[i]&gt;=a[i+1]) return false;
        }
        return true;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 99. Recover Binary Search Tree
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given the
   <code>
    root
   </code>
   of a binary search tree (BST), where the values of
   <strong>
    exactly
   </strong>
   two nodes of the tree were swapped by mistake.
   <em>
    Recover the tree without changing its structure
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/recover1.jpg" style="width: 422px; height: 302px;"/>
  <pre><strong>Input:</strong> root = [1,3,null,null,2]
<strong>Output:</strong> [3,1,null,null,2]
<strong>Explanation:</strong> 3 cannot be a left child of 1 because 3 &gt; 1. Swapping 1 and 3 makes the BST valid.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/recover2.jpg" style="width: 581px; height: 302px;"/>
  <pre><strong>Input:</strong> root = [3,1,4,null,null,2]
<strong>Output:</strong> [2,1,4,null,null,3]
<strong>Explanation:</strong> 2 cannot be in the right subtree of 3 because 2 &lt; 3. Swapping 2 and 3 makes the BST valid.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [2, 1000]
    </code>
    .
   </li>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= Node.val &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow up:
  </strong>
  A solution using
  <code>
   O(n)
  </code>
  space is pretty straight-forward. Could you devise a constant
  <code>
   O(1)
  </code>
  space solution?
 </div>
</div>
</body></html>
<!-- Solution for Question 99 -->
<pre>/*
 * @lc app=leetcode id=99 lang=cpp
 *
 * [99] Recover Binary Search Tree
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    void inorder(TreeNode *root,TreeNode*&amp; prev,TreeNode*&amp; start,TreeNode*&amp; end){
        if(root){
            inorder(root-&gt;left,prev,start,end);
            if(prev){
                if(prev-&gt;val&gt;root-&gt;val){
                    if(start==NULL){
                        start=prev;
                    }
                    end=root;
                }
            }
            prev=root;
            inorder(root-&gt;right,prev,start,end);
        }
    }
    void recoverTree(TreeNode* root) {
        TreeNode *prev=NULL;
        TreeNode *start=NULL;
        TreeNode *end=NULL;
        inorder(root,prev,start,end);
        swap(start-&gt;val,end-&gt;val);
        return;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 101. Symmetric Tree
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree,
   <em>
    check whether it is a mirror of itself
   </em>
   (i.e., symmetric around its center).
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/symtree1.jpg" style="width: 354px; height: 291px;"/>
  <pre><strong>Input:</strong> root = [1,2,2,3,4,4,3]
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/symtree2.jpg" style="width: 308px; height: 258px;"/>
  <pre><strong>Input:</strong> root = [1,2,2,null,3,null,3]
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [1, 1000]
    </code>
    .
   </li>
   <li>
    <code>
     -100 &lt;= Node.val &lt;= 100
    </code>
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow up:
  </strong>
  Could you solve it both recursively and iteratively?
 </div>
</div>
</body></html>
<!-- Solution for Question 101 -->
<pre>/*
 * @lc app=leetcode id=101 lang=cpp
 *
 * [101] Symmetric Tree
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool check(TreeNode *t1, TreeNode *t2)
    {
        if(t1==NULL &amp;&amp; t2==NULL)
        {
            return true;
        }
        if(t1==NULL || t2==NULL)
        {
            return false;
        }
        if(t1-&gt;val != t2-&gt;val)
        {
            return false;
        }
        return check(t1-&gt;left,t2-&gt;right) &amp;&amp; check(t2-&gt;left,t1-&gt;right);
    }
    bool isSymmetric(TreeNode* root) {
        if(root==NULL) return false;

        return check(root-&gt;left,root-&gt;right);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 102. Binary Tree Level Order Traversal
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree, return
   <em>
    the level order traversal of its nodes' values
   </em>
   . (i.e., from left to right, level by level).
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/tree1(2).jpg" style="width: 277px; height: 302px;"/>
  <pre><strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> [[3],[9,20],[15,7]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1]
<strong>Output:</strong> [[1]]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [0, 2000]
    </code>
    .
   </li>
   <li>
    <code>
     -1000 &lt;= Node.val &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 102 -->
<pre>/*
 * @lc app=leetcode id=102 lang=cpp
 *
 * [102] Binary Tree Level Order Traversal
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        if(root == NULL)
        {
            return {};
        }
        vector&lt;vector&lt;int&gt;&gt;a;
        queue&lt;TreeNode *&gt; q;
        q.push(root);
        while(!q.empty()) {
            int count=q.size();
            vector&lt;int&gt;b;
            while(count)
            {
            TreeNode* node = q.front();
            b.push_back(node-&gt;val);
            q.pop();
            if(node-&gt;left)
            q.push(node-&gt;left);
            if(node-&gt;right)
            q.push(node-&gt;right);
            count--;
        }
        a.push_back(b);
        }
        return a;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 103. Binary Tree Zigzag Level Order Traversal
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree, return
   <em>
    the zigzag level order traversal of its nodes' values
   </em>
   . (i.e., from left to right, then right to left for the next level and alternate between).
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/tree1(2).jpg" style="width: 277px; height: 302px;"/>
  <pre><strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> [[3],[20,9],[15,7]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1]
<strong>Output:</strong> [[1]]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [0, 2000]
    </code>
    .
   </li>
   <li>
    <code>
     -100 &lt;= Node.val &lt;= 100
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 103 -->
<pre>/*
 * @lc app=leetcode id=103 lang=cpp
 *
 * [103] Binary Tree Zigzag Level Order Traversal
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; zigzagLevelOrder(TreeNode* root) {
        if(root == NULL)
        {
            return {};
        }
        vector&lt;vector&lt;int&gt;&gt;a;
        queue&lt;TreeNode *&gt; q;
        q.push(root);
        int c = 0;
        while(!q.empty()) {
            int count=q.size();
            vector&lt;int&gt;b;
            while(count)
            {
            TreeNode* node = q.front();
            b.push_back(node-&gt;val);
            q.pop();
            if(node-&gt;left)
            q.push(node-&gt;left);
            if(node-&gt;right)
            q.push(node-&gt;right);
            count--;
        }
        if(c==0) c=1;
        else
        {
            reverse(b.begin(),b.end());
            c=0;
        }
        a.push_back(b);
        }
        return a;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 104. Maximum Depth of Binary Tree
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree, return
   <em>
    its maximum depth
   </em>
   .
  </p>
  <p>
   A binary tree's
   <strong>
    maximum depth
   </strong>
   is the number of nodes along the longest path from the root node down to the farthest leaf node.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/tmp-tree.jpg" style="width: 400px; height: 277px;"/>
  <pre><strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> 3
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1,null,2]
<strong>Output:</strong> 2
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = []
<strong>Output:</strong> 0
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [0]
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [0, 10
     <sup>
      4
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     -100 &lt;= Node.val &lt;= 100
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 104 -->
<pre>/*
 * @lc app=leetcode id=104 lang=cpp
 *
 * [104] Maximum Depth of Binary Tree
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==NULL) return 0;
        return 1+max(maxDepth(root-&gt;left),maxDepth(root-&gt;right));
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 105. Construct Binary Tree from Preorder and Inorder Traversal
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two integer arrays
   <code>
    preorder
   </code>
   and
   <code>
    inorder
   </code>
   where
   <code>
    preorder
   </code>
   is the preorder traversal of a binary tree and
   <code>
    inorder
   </code>
   is the inorder traversal of the same tree, construct and return
   <em>
    the binary tree
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/tree.jpg" style="width: 277px; height: 302px;"/>
  <pre><strong>Input:</strong> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
<strong>Output:</strong> [3,9,20,null,null,15,7]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> preorder = [-1], inorder = [-1]
<strong>Output:</strong> [-1]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= preorder.length &lt;= 3000
    </code>
   </li>
   <li>
    <code>
     inorder.length == preorder.length
    </code>
   </li>
   <li>
    <code>
     -3000 &lt;= preorder[i], inorder[i] &lt;= 3000
    </code>
   </li>
   <li>
    <code>
     preorder
    </code>
    and
    <code>
     inorder
    </code>
    consist of
    <strong>
     unique
    </strong>
    values.
   </li>
   <li>
    Each value of
    <code>
     inorder
    </code>
    also appears in
    <code>
     preorder
    </code>
    .
   </li>
   <li>
    <code>
     preorder
    </code>
    is
    <strong>
     guaranteed
    </strong>
    to be the preorder traversal of the tree.
   </li>
   <li>
    <code>
     inorder
    </code>
    is
    <strong>
     guaranteed
    </strong>
    to be the inorder traversal of the tree.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 105 -->
<pre>/*
 * @lc app=leetcode id=105 lang=cpp
 *
 * [105] Construct Binary Tree from Preorder and Inorder Traversal
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int pre=0;
    map&lt;int,int&gt;m;
    TreeNode* create(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder,int start,int end){
        if(start&gt;end) return NULL;
        TreeNode *node = new TreeNode(preorder[pre++]);
        if(start==end) return node;
        int pos=m[node-&gt;val];
        node-&gt;left = create(preorder,inorder,start,pos-1);
        node-&gt;right = create(preorder,inorder,pos+1,end);
        return node;
    }
    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) {
        for(int i=0;i&lt;inorder.size();i++){
            m[inorder[i]] = i;
        }
        return create(preorder, inorder,0,inorder.size()-1);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 106. Construct Binary Tree from Inorder and Postorder Traversal
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two integer arrays
   <code>
    inorder
   </code>
   and
   <code>
    postorder
   </code>
   where
   <code>
    inorder
   </code>
   is the inorder traversal of a binary tree and
   <code>
    postorder
   </code>
   is the postorder traversal of the same tree, construct and return
   <em>
    the binary tree
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/tree.jpg" style="width: 277px; height: 302px;"/>
  <pre><strong>Input:</strong> inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
<strong>Output:</strong> [3,9,20,null,null,15,7]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> inorder = [-1], postorder = [-1]
<strong>Output:</strong> [-1]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= inorder.length &lt;= 3000
    </code>
   </li>
   <li>
    <code>
     postorder.length == inorder.length
    </code>
   </li>
   <li>
    <code>
     -3000 &lt;= inorder[i], postorder[i] &lt;= 3000
    </code>
   </li>
   <li>
    <code>
     inorder
    </code>
    and
    <code>
     postorder
    </code>
    consist of
    <strong>
     unique
    </strong>
    values.
   </li>
   <li>
    Each value of
    <code>
     postorder
    </code>
    also appears in
    <code>
     inorder
    </code>
    .
   </li>
   <li>
    <code>
     inorder
    </code>
    is
    <strong>
     guaranteed
    </strong>
    to be the inorder traversal of the tree.
   </li>
   <li>
    <code>
     postorder
    </code>
    is
    <strong>
     guaranteed
    </strong>
    to be the postorder traversal of the tree.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 106 -->
<pre>/*
 * @lc app=leetcode id=106 lang=cpp
 *
 * [106] Construct Binary Tree from Inorder and Postorder Traversal
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    map&lt;int,int&gt;m;
    int post;
    TreeNode * build(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder,int start,int end){
        if(post&lt;0 || start &gt; end) return NULL;
        int element = postorder[post--];
        TreeNode *root = new TreeNode(element);
        int index=m[element];
        root-&gt;right=build(inorder,postorder,index+1,end);
        root-&gt;left=build(inorder,postorder,start,index-1);
        return root;
    }
    TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) {
        for(int i=0; i&lt;inorder.size();i++){
            m[inorder[i]]=i;
        }
        post=postorder.size()-1;
        return build(inorder,postorder,0,inorder.size()-1);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 107. Binary Tree Level Order Traversal II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree, return
   <em>
    the bottom-up level order traversal of its nodes' values
   </em>
   . (i.e., from left to right, level by level from leaf to root).
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/tree1(2).jpg" style="width: 277px; height: 302px;"/>
  <pre><strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> [[15,7],[9,20],[3]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1]
<strong>Output:</strong> [[1]]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [0, 2000]
    </code>
    .
   </li>
   <li>
    <code>
     -1000 &lt;= Node.val &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 107 -->
<pre>/*
 * @lc app=leetcode id=107 lang=cpp
 *
 * [107] Binary Tree Level Order Traversal II
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) {
          if(root == NULL)
        {
            return {};
        }
        vector&lt;vector&lt;int&gt;&gt;a;
        queue&lt;TreeNode *&gt; q;
        q.push(root);
        while(!q.empty()) {
            int count=q.size();
            vector&lt;int&gt;b;
            while(count)
            {
            TreeNode* node = q.front();
            b.push_back(node-&gt;val);
            q.pop();
            if(node-&gt;left)
            q.push(node-&gt;left);
            if(node-&gt;right)
            q.push(node-&gt;right);
            count--;
        }
        a.insert(a.begin(),b);
        }
        return a;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 108. Convert Sorted Array to Binary Search Tree
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   where the elements are sorted in
   <strong>
    ascending order
   </strong>
   , convert
   <em>
    it to a
    <strong>
     height-balanced
    </strong>
    binary search tree
   </em>
   .
  </p>
  <p>
   A
   <strong>
    height-balanced
   </strong>
   binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/btree1.jpg" style="width: 302px; height: 222px;"/>
  <pre><strong>Input:</strong> nums = [-10,-3,0,5,9]
<strong>Output:</strong> [0,-3,9,-10,null,5]
<strong>Explanation:</strong> [0,-10,5,null,-3,null,9] is also accepted:
<img alt="" src="./output_files/btree2.jpg" style="width: 302px; height: 222px;"/>
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/btree.jpg" style="width: 342px; height: 142px;"/>
  <pre><strong>Input:</strong> nums = [1,3]
<strong>Output:</strong> [3,1]
<strong>Explanation:</strong> [1,3] and [3,1] are both a height-balanced BSTs.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= nums[i] &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     nums
    </code>
    is sorted in a
    <strong>
     strictly increasing
    </strong>
    order.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 108 -->
<pre>/*
 * @lc app=leetcode id=108 lang=cpp
 *
 * [108] Convert Sorted Array to Binary Search Tree
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* create(vector&lt;int&gt;nums,int start,int end){
        if(start&gt;end) return NULL;
        int mid=(start+end)/2;
        TreeNode *node = new TreeNode(nums[mid]);
        node-&gt;left = create(nums,start,mid-1);
        node-&gt;right = create(nums,mid+1,end);
        return node;
    }
    TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {
        return create(nums,0,nums.size()-1);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 109. Convert Sorted List to Binary Search Tree
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    head
   </code>
   of a singly linked list where elements are
   <strong>
    sorted in ascending order
   </strong>
   , convert it to a height balanced BST.
  </p>
  <p>
   For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of
   <em>
    every
   </em>
   node never differ by more than 1.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/linked.jpg" style="width: 600px; height: 466px;"/>
  <pre><strong>Input:</strong> head = [-10,-3,0,5,9]
<strong>Output:</strong> [0,-3,9,-10,null,5]
<strong>Explanation:</strong> One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> head = []
<strong>Output:</strong> []
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> head = [0]
<strong>Output:</strong> [0]
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> head = [1,3]
<strong>Output:</strong> [3,1]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in
    <code>
     head
    </code>
    is in the range
    <code>
     [0, 2 * 10
     <sup>
      4
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     -10
     <sup>
      5
     </sup>
     &lt;= Node.val &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 109 -->
<pre>/*
 * @lc app=leetcode id=109 lang=cpp
 *
 * [109] Convert Sorted List to Binary Search Tree
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* create(vector&lt;int&gt;nums,int start,int end){
        if(start&gt;end) return NULL;
        int mid=(start+end)/2;
        TreeNode *node = new TreeNode(nums[mid]);
        node-&gt;left = create(nums,mid+1,end);
        node-&gt;right = create(nums,start,mid-1);
        return node;
    }
    TreeNode* sortedListToBST(ListNode* head) {
        vector&lt;int&gt;nums;
        ListNode *temp=head;
        while(temp!=NULL){
            nums.insert(nums.begin(),temp-&gt;val);
            temp=temp-&gt;next;
        }
        return create(nums,0,nums.size()-1);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 110. Balanced Binary Tree
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a binary tree, determine if it is height-balanced.
  </p>
  <p>
   For this problem, a height-balanced binary tree is defined as:
  </p>
  <blockquote>
   <p>
    a binary tree in which the left and right subtrees of
    <em>
     every
    </em>
    node differ in height by no more than 1.
   </p>
  </blockquote>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/balance_1.jpg" style="width: 342px; height: 221px;"/>
  <pre><strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/balance_2.jpg" style="width: 452px; height: 301px;"/>
  <pre><strong>Input:</strong> root = [1,2,2,3,3,null,null,4,4]
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = []
<strong>Output:</strong> true
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [0, 5000]
    </code>
    .
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= Node.val &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 110 -->
<pre>/*
 * @lc app=leetcode id=110 lang=cpp
 *
 * [110] Balanced Binary Tree
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int height(TreeNode *root){
        if(root==NULL) return 0;
        return 1 + max(height(root-&gt;right), height(root-&gt;left));
    }
    bool isBalanced(TreeNode* root) {
        if(root==NULL) return true;
        cout&lt;&lt;height(root-&gt;right)&lt;&lt;&quot; &quot;&lt;&lt;height(root-&gt;left);
        if(abs(height(root-&gt;right)-height(root-&gt;left))&lt;=1) return true &amp;&amp; isBalanced(root-&gt;right) &amp;&amp; isBalanced(root-&gt;left);
        return false;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 111. Minimum Depth of Binary Tree
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a binary tree, find its minimum depth.
  </p>
  <p>
   The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.
  </p>
  <p>
   <strong>
    Note:
   </strong>
   A leaf is a node with no children.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/ex_depth.jpg" style="width: 432px; height: 302px;"/>
  <pre><strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> 2
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [2,null,3,null,4,null,5,null,6]
<strong>Output:</strong> 5
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [0, 10
     <sup>
      5
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     -1000 &lt;= Node.val &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 111 -->
<pre>/*
 * @lc app=leetcode id=111 lang=cpp
 *
 * [111] Minimum Depth of Binary Tree
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root==NULL) return 0;
        if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL) return 1;
        if(root-&gt;left ==NULL &amp;&amp; root-&gt;right!=NULL){
            return 1+minDepth(root-&gt;right);
        }
        if(root-&gt;left !=NULL &amp;&amp; root-&gt;right==NULL){
            return 1+minDepth(root-&gt;left);
        }
        else{
        return 1+min({minDepth(root-&gt;left),minDepth(root-&gt;right)});
        }
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 112. Path Sum
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree and an integer
   <code>
    targetSum
   </code>
   , return
   <code>
    true
   </code>
   if the tree has a
   <strong>
    root-to-leaf
   </strong>
   path such that adding up all the values along the path equals
   <code>
    targetSum
   </code>
   .
  </p>
  <p>
   A
   <strong>
    leaf
   </strong>
   is a node with no children.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/pathsum1.jpg" style="width: 500px; height: 356px;"/>
  <pre><strong>Input:</strong> root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/pathsum2.jpg"/>
  <pre><strong>Input:</strong> root = [1,2,3], targetSum = 5
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1,2], targetSum = 0
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [0, 5000]
    </code>
    .
   </li>
   <li>
    <code>
     -1000 &lt;= Node.val &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     -1000 &lt;= targetSum &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 112 -->
<pre>/*
 * @lc app=leetcode id=112 lang=cpp
 *
 * [112] Path Sum
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root==NULL) return 0;
        bool ans=0;
        if(targetSum- root-&gt;val==0 &amp;&amp; root-&gt;left ==NULL &amp;&amp; root-&gt;right==NULL){
            return 1;
        }
        if(root-&gt;left){
            ans=ans||hasPathSum(root-&gt;left,targetSum- root-&gt;val);
        }
        if(root-&gt;right){
            ans=ans||hasPathSum(root-&gt;right,targetSum- root-&gt;val);
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 113. Path Sum II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree and an integer
   <code>
    targetSum
   </code>
   , return
   <em>
    all
    <strong>
     root-to-leaf
    </strong>
    paths where the sum of the node values in the path equals
   </em>
   <code>
    targetSum
   </code>
   <em>
    . Each path should be returned as a list of the node
    <strong>
     values
    </strong>
    , not node references
   </em>
   .
  </p>
  <p>
   A
   <strong>
    root-to-leaf
   </strong>
   path is a path starting from the root and ending at any leaf node. A
   <strong>
    leaf
   </strong>
   is a node with no children.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/pathsumii1.jpg" style="width: 500px; height: 356px;"/>
  <pre><strong>Input:</strong> root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
<strong>Output:</strong> [[5,4,11,2],[5,8,4,5]]
<strong>Explanation:</strong> There are two paths whose sum equals targetSum:
5 + 4 + 11 + 2 = 22
5 + 8 + 4 + 5 = 22
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/pathsum2.jpg" style="width: 212px; height: 181px;"/>
  <pre><strong>Input:</strong> root = [1,2,3], targetSum = 5
<strong>Output:</strong> []
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1,2], targetSum = 0
<strong>Output:</strong> []
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [0, 5000]
    </code>
    .
   </li>
   <li>
    <code>
     -1000 &lt;= Node.val &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     -1000 &lt;= targetSum &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 113 -->
<pre>/*
 * @lc app=leetcode id=113 lang=cpp
 *
 * [113] Path Sum II
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void inorder(TreeNode* root,int targetSum,vector&lt;int&gt;b,vector&lt;vector&lt;int&gt;&gt;&amp;a){
        if(root==NULL){
            return;
        }
        b.push_back(root-&gt;val);
        if(targetSum==root-&gt;val &amp;&amp;  root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL){
            a.push_back(b);
            return;
        }
        inorder(root-&gt;left,targetSum-root-&gt;val,b,a);
        inorder(root-&gt;right,targetSum-root-&gt;val,b,a);
    }
    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int targetSum) {
        vector&lt;vector&lt;int&gt;&gt;a;
        vector&lt;int&gt;b;
        string s=&quot;&quot;;
        inorder(root,targetSum,b,a);
        return a;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 114. Flatten Binary Tree to Linked List
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree, flatten the tree into a "linked list":
  </p>
  <ul>
   <li>
    The "linked list" should use the same
    <code>
     TreeNode
    </code>
    class where the
    <code>
     right
    </code>
    child pointer points to the next node in the list and the
    <code>
     left
    </code>
    child pointer is always
    <code>
     null
    </code>
    .
   </li>
   <li>
    The "linked list" should be in the same order as a
    <a href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR" target="_blank">
     <strong>
      pre-order
     </strong>
     <strong>
      traversal
     </strong>
    </a>
    of the binary tree.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/flaten.jpg" style="width: 500px; height: 226px;"/>
  <pre><strong>Input:</strong> root = [1,2,5,3,4,null,6]
<strong>Output:</strong> [1,null,2,null,3,null,4,null,5,null,6]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [0]
<strong>Output:</strong> [0]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [0, 2000]
    </code>
    .
   </li>
   <li>
    <code>
     -100 &lt;= Node.val &lt;= 100
    </code>
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow up:
  </strong>
  Can you flatten the tree in-place (with
  <code>
   O(1)
  </code>
  extra space)?
 </div>
</div>
</body></html>
<!-- Solution for Question 114 -->
<pre>/*
 * @lc app=leetcode id=114 lang=cpp
 *
 * [114] Flatten Binary Tree to Linked List
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void flatten(TreeNode* root) {
        if(root){
            if(root-&gt;left){
                flatten(root-&gt;left);
                TreeNode *node = root-&gt;right;
                root-&gt;right=root-&gt;left;
                root-&gt;left=NULL;
                TreeNode * temp=root-&gt;right;
                while(temp-&gt;right!=NULL){
                    temp=temp-&gt;right;
                }
                temp-&gt;right=node;
            }
            flatten(root-&gt;right);
        }
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 115. Distinct Subsequences
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two strings
   <code>
    s
   </code>
   and
   <code>
    t
   </code>
   , return
   <em>
    the number of distinct subsequences of
    <code>
     s
    </code>
    which equals
    <code>
     t
    </code>
   </em>
   .
  </p>
  <p>
   A string's
   <strong>
    subsequence
   </strong>
   is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the remaining characters' relative positions. (i.e.,
   <code>
    "ACE"
   </code>
   is a subsequence of
   <code>
    "ABCDE"
   </code>
   while
   <code>
    "AEC"
   </code>
   is not).
  </p>
  <p>
   It is guaranteed the answer fits on a 32-bit signed integer.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "rabbbit", t = "rabbit"
<strong>Output:</strong> 3
<strong>Explanation:</strong>
As shown below, there are 3 ways you can generate "rabbit" from S.
<code><strong><u>rabb</u></strong>b<strong><u>it</u></strong></code>
<code><strong><u>ra</u></strong>b<strong><u>bbit</u></strong></code>
<code><strong><u>rab</u></strong>b<strong><u>bit</u></strong></code>
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "babgbag", t = "bag"
<strong>Output:</strong> 5
<strong>Explanation:</strong>
As shown below, there are 5 ways you can generate "bag" from S.
<code><strong><u>ba</u></strong>b<u><strong>g</strong></u>bag</code>
<code><strong><u>ba</u></strong>bgba<strong><u>g</u></strong></code>
<code><u><strong>b</strong></u>abgb<strong><u>ag</u></strong></code>
<code>ba<u><strong>b</strong></u>gb<u><strong>ag</strong></u></code>
<code>babg<strong><u>bag</u></strong></code></pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length, t.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    and
    <code>
     t
    </code>
    consist of English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 115 -->
<pre>/*
 * @lc app=leetcode id=115 lang=cpp
 *
 * [115] Distinct Subsequences
 */

// @lc code=start
class Solution {
public:
    int numDistinct(string s, string t) {
        int m=s.length();
        int n=t.length();
        int mod = 1e9+7;
        if(m&lt;n) return 0;
        vector&lt;vector&lt;long long&gt;&gt;dp(m,vector&lt;long long&gt;(n,0));
        dp[0][0] = s[0]==t[0];
        for(int i=1;i&lt;m;i++){
            if(s[i]==t[0]){
                dp[i][0] = dp[i-1][0] + 1;
            }
            else{
                dp[i][0] = dp[i-1][0];
            }
        }
        for(int i=1;i&lt;m;i++){
            for(int j=1;j&lt;n;j++){
                if(s[i]==t[j]){
                    dp[i][j] = (dp[i-1][j]%mod + dp[i-1][j-1]%mod)%mod;
                }
                else{
                    dp[i][j] = dp[i-1][j]%mod;
                }
            }
        }

        return dp[m-1][n-1]%mod;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 116. Populating Next Right Pointers in Each Node
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given a
   <strong>
    perfect binary tree
   </strong>
   where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:
  </p>
  <pre>struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
</pre>
  <p>
   Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to
   <code>
    NULL
   </code>
   .
  </p>
  <p>
   Initially, all next pointers are set to
   <code>
    NULL
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/116_sample.png" style="width: 500px; height: 171px;"/>
  <pre><strong>Input:</strong> root = [1,2,3,4,5,6,7]
<strong>Output:</strong> [1,#,2,3,#,4,5,6,7,#]
<strong>Explanation: </strong>Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [0, 2
     <sup>
      12
     </sup>
     - 1]
    </code>
    .
   </li>
   <li>
    <code>
     -1000 &lt;= Node.val &lt;= 1000
    </code>
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow-up:
   </strong>
  </p>
  <ul>
   <li>
    You may only use constant extra space.
   </li>
   <li>
    The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 116 -->
<pre>/*
 * @lc app=leetcode id=116 lang=cpp
 *
 * [116] Populating Next Right Pointers in Each Node
 */

// @lc code=start
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        if(root==NULL) return NULL;
        queue&lt;Node *&gt; q;
        q.push(root);
        while(!q.empty()) {
            int count=q.size();
            vector&lt;Node* &gt;b;
            while(count)
            {
            Node* node = q.front();
            b.push_back(node);
            q.pop();
            if(node-&gt;left)
            q.push(node-&gt;left);
            if(node-&gt;right)
            q.push(node-&gt;right);
            count--;
        }
        for(int i=0;i&lt;b.size()-1;i++){
            b[i]-&gt;next=b[i+1];
        }
        }
        return root;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 117. Populating Next Right Pointers in Each Node II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a binary tree
  </p>
  <pre>struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
</pre>
  <p>
   Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to
   <code>
    NULL
   </code>
   .
  </p>
  <p>
   Initially, all next pointers are set to
   <code>
    NULL
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/117_sample.png" style="width: 500px; height: 171px;"/>
  <pre><strong>Input:</strong> root = [1,2,3,4,5,null,7]
<strong>Output:</strong> [1,#,2,3,#,4,5,7,#]
<strong>Explanation: </strong>Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [0, 6000]
    </code>
    .
   </li>
   <li>
    <code>
     -100 &lt;= Node.val &lt;= 100
    </code>
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow-up:
   </strong>
  </p>
  <ul>
   <li>
    You may only use constant extra space.
   </li>
   <li>
    The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 117 -->
<pre>/*
 * @lc app=leetcode id=117 lang=cpp
 *
 * [117] Populating Next Right Pointers in Each Node II
 */

// @lc code=start
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        if(root==NULL) return NULL;
        queue&lt;Node *&gt; q;
        q.push(root);
        while(!q.empty()) {
            int count=q.size();
            vector&lt;Node* &gt;b;
            while(count)
            {
            Node* node = q.front();
            b.push_back(node);
            q.pop();
            if(node-&gt;left)
            q.push(node-&gt;left);
            if(node-&gt;right)
            q.push(node-&gt;right);
            count--;
        }
        for(int i=0;i&lt;b.size()-1;i++){
            b[i]-&gt;next=b[i+1];
        }
        }
        return root;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 118. Pascal's Triangle
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer
   <code>
    numRows
   </code>
   , return the first numRows of
   <strong>
    Pascal's triangle
   </strong>
   .
  </p>
  <p>
   In
   <strong>
    Pascal's triangle
   </strong>
   , each number is the sum of the two numbers directly above it as shown:
  </p>
  <img alt="" src="./output_files/PascalTriangleAnimated2.gif" style="height:240px; width:260px"/>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> numRows = 5
<strong>Output:</strong> [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> numRows = 1
<strong>Output:</strong> [[1]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= numRows &lt;= 30
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 118 -->
<pre>/*
 * @lc app=leetcode id=118 lang=cpp
 *
 * [118] Pascal&#x27;s Triangle
 */

// @lc code=start
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {
         vector&lt;vector&lt;int&gt;&gt;dp;
        for(int i = 0; i &lt; numRows; i++)
        {
            vector&lt;int&gt;ans(i+1,1);
            for(int j = 1; j &lt; i; j++)
            {
                ans[j]=dp[i-1][j-1]+dp[i-1][j];
            }
            dp.push_back(ans);
        }
        return dp;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 119. Pascal's Triangle II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer
   <code>
    rowIndex
   </code>
   , return the
   <code>
    rowIndex
    <sup>
     th
    </sup>
   </code>
   (
   <strong>
    0-indexed
   </strong>
   ) row of the
   <strong>
    Pascal's triangle
   </strong>
   .
  </p>
  <p>
   In
   <strong>
    Pascal's triangle
   </strong>
   , each number is the sum of the two numbers directly above it as shown:
  </p>
  <img alt="" src="./output_files/PascalTriangleAnimated2.gif" style="height:240px; width:260px"/>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> rowIndex = 3
<strong>Output:</strong> [1,3,3,1]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> rowIndex = 0
<strong>Output:</strong> [1]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> rowIndex = 1
<strong>Output:</strong> [1,1]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= rowIndex &lt;= 33
    </code>
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   Could you optimize your algorithm to use only
   <code>
    O(rowIndex)
   </code>
   extra space?
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 119 -->
<pre>/*
 * @lc app=leetcode id=119 lang=cpp
 *
 * [119] Pascal&#x27;s Triangle II
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; getRow(int rowIndex) {
        vector&lt;vector&lt;int&gt;&gt;a;
        for(int i = 0; i &lt; rowIndex+1; i++)
        {
            vector&lt;int&gt;ans(i+1,1);
            for(int j = 1; j &lt; i; j++)
            {
                ans[j]=a[i-1][j-1]+a[i-1][j];
            }
            a.push_back(ans);
            if(rowIndex==i){
                return ans;
            }
        }
        return {};
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 120. Triangle
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a
   <code>
    triangle
   </code>
   array, return
   <em>
    the minimum path sum from top to bottom
   </em>
   .
  </p>
  <p>
   For each step, you may move to an adjacent number of the row below. More formally, if you are on index
   <code>
    i
   </code>
   on the current row, you may move to either index
   <code>
    i
   </code>
   or index
   <code>
    i + 1
   </code>
   on the next row.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
<strong>Output:</strong> 11
<strong>Explanation:</strong> The triangle looks like:
   <u>2</u>
  <u>3</u> 4
 6 <u>5</u> 7
4 <u>1</u> 8 3
The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> triangle = [[-10]]
<strong>Output:</strong> -10
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= triangle.length &lt;= 200
    </code>
   </li>
   <li>
    <code>
     triangle[0].length == 1
    </code>
   </li>
   <li>
    <code>
     triangle[i].length == triangle[i - 1].length + 1
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= triangle[i][j] &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow up:
  </strong>
  Could you do this using only
  <code>
   O(n)
  </code>
  extra space, where
  <code>
   n
  </code>
  is the total number of rows in the triangle?
 </div>
</div>
</body></html>
<!-- Solution for Question 120 -->
<pre>/*
 * @lc app=leetcode id=120 lang=cpp
 *
 * [120] Triangle
 */

// @lc code=start
class Solution {
public:
    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp;a) {
        vector&lt;int&gt;ans=a[a.size()-1];
        for(int i=a.size()-2;i&gt;=0;i--)
        {
            for(int j=0;j&lt;a[i].size();j++)
            {
            ans[j]=a[i][j]+min(ans[j],ans[j+1]);
            }
        }
        return ans[0];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 121. Best Time to Buy and Sell Stock
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an array
   <code>
    prices
   </code>
   where
   <code>
    prices[i]
   </code>
   is the price of a given stock on the
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   day.
  </p>
  <p>
   You want to maximize your profit by choosing a
   <strong>
    single day
   </strong>
   to buy one stock and choosing a
   <strong>
    different day in the future
   </strong>
   to sell that stock.
  </p>
  <p>
   Return
   <em>
    the maximum profit you can achieve from this transaction
   </em>
   . If you cannot achieve any profit, return
   <code>
    0
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> prices = [7,1,5,3,6,4]
<strong>Output:</strong> 5
<strong>Explanation:</strong> Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> prices = [7,6,4,3,1]
<strong>Output:</strong> 0
<strong>Explanation:</strong> In this case, no transactions are done and the max profit = 0.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= prices.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= prices[i] &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 121 -->
<pre>/*
 * @lc app=leetcode id=121 lang=cpp
 *
 * [121] Best Time to Buy and Sell Stock
 */

// @lc code=start
class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int maxprof=0;
        int minprof=INT_MAX;
        for(int i=0; i&lt;prices.size(); i++)
        {
            minprof=min(minprof, prices[i]);
            maxprof=max(maxprof, prices[i]-minprof);
        }
        return maxprof;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 122. Best Time to Buy and Sell Stock II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an integer array
   <code>
    prices
   </code>
   where
   <code>
    prices[i]
   </code>
   is the price of a given stock on the
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   day.
  </p>
  <p>
   On each day, you may decide to buy and/or sell the stock. You can only hold
   <strong>
    at most one
   </strong>
   share of the stock at any time. However, you can buy it then immediately sell it on the
   <strong>
    same day
   </strong>
   .
  </p>
  <p>
   Find and return
   <em>
    the
    <strong>
     maximum
    </strong>
    profit you can achieve
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> prices = [7,1,5,3,6,4]
<strong>Output:</strong> 7
<strong>Explanation:</strong> Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Total profit is 4 + 3 = 7.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> prices = [1,2,3,4,5]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
Total profit is 4.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> prices = [7,6,4,3,1]
<strong>Output:</strong> 0
<strong>Explanation:</strong> There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= prices.length &lt;= 3 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= prices[i] &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 122 -->
<pre>/*
 * @lc app=leetcode id=122 lang=cpp
 *
 * [122] Best Time to Buy and Sell Stock II
 */

// @lc code=start
class Solution {
public:
    int find(int i,int state,vector&lt;int&gt;&amp;prices,vector&lt;vector&lt;int&gt;&gt;&amp;dp)
    {
        if(i&gt;=prices.size()) return 0;
        if(dp[i][state]!=-1) return dp[i][state];
        if(state) return dp[i][state]=max(-prices[i]+find(i+1,0,prices,dp),find(i+1,1,prices,dp));
        else return dp[i][state]=max(prices[i]+find(i+1,1,prices,dp),find(i+1,0,prices,dp));
    }
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        vector&lt;vector&lt;int&gt;&gt;dp(prices.size(),vector&lt;int&gt;(2,-1));
        return find(0,1,prices,dp);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 123. Best Time to Buy and Sell Stock III
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an array
   <code>
    prices
   </code>
   where
   <code>
    prices[i]
   </code>
   is the price of a given stock on the
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   day.
  </p>
  <p>
   Find the maximum profit you can achieve. You may complete
   <strong>
    at most two transactions
   </strong>
   .
  </p>
  <p>
   <strong>
    Note:
   </strong>
   You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> prices = [3,3,5,0,0,3,1,4]
<strong>Output:</strong> 6
<strong>Explanation:</strong> Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> prices = [1,2,3,4,5]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> prices = [7,6,4,3,1]
<strong>Output:</strong> 0
<strong>Explanation:</strong> In this case, no transaction is done, i.e. max profit = 0.
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> prices = [1]
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= prices.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= prices[i] &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 123 -->
<pre>/*
 * @lc app=leetcode id=123 lang=cpp
 *
 * [123] Best Time to Buy and Sell Stock III
 */

// @lc code=start
class Solution {
public:
    int find(vector&lt;int&gt;&amp;prices,int i,int state,vector&lt;vector&lt;int&gt;&gt;&amp;dp)
    {
        if(i&gt;=prices.size() || state&gt;=4) return 0;
        if(dp[i][state]!=-1) return dp[i][state];
        if(state%2==0)
        {
            return dp[i][state] = max(-prices[i]+find(prices,i+1,state+1,dp),find(prices,i+1,state,dp));
        }
        else
        {
            return dp[i][state] = max(prices[i]+find(prices,i+1,state+1,dp),find(prices,i+1,state,dp));
        }
    }
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int n=prices.size();
        vector&lt;vector&lt;int&gt;&gt;dp(n,vector&lt;int&gt;(4,-1));
        return find(prices,0,0,dp);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 124. Binary Tree Maximum Path Sum
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   A
   <strong>
    path
   </strong>
   in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence
   <strong>
    at most once
   </strong>
   . Note that the path does not need to pass through the root.
  </p>
  <p>
   The
   <strong>
    path sum
   </strong>
   of a path is the sum of the node's values in the path.
  </p>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree, return
   <em>
    the maximum
    <strong>
     path sum
    </strong>
    of any path
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/exx1.jpg" style="width: 322px; height: 182px;"/>
  <pre><strong>Input:</strong> root = [1,2,3]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The optimal path is 2 -&gt; 1 -&gt; 3 with a path sum of 2 + 1 + 3 = 6.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/exx2.jpg"/>
  <pre><strong>Input:</strong> root = [-10,9,20,null,null,15,7]
<strong>Output:</strong> 42
<strong>Explanation:</strong> The optimal path is 15 -&gt; 20 -&gt; 7 with a path sum of 15 + 20 + 7 = 42.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [1, 3 * 10
     <sup>
      4
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     -1000 &lt;= Node.val &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 124 -->
<pre>/*
 * @lc app=leetcode id=124 lang=cpp
 *
 * [124] Binary Tree Maximum Path Sum
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
int maxSum(TreeNode* root, int&amp; ans){
        if(root==NULL)return 0;
       int x=root-&gt;val+maxSum(root-&gt;right,ans);
        int y=root-&gt;val+maxSum(root-&gt;left,ans);
        ans=max({ans,x,y,x+y-root-&gt;val,root-&gt;val});
        return max({x,y,root-&gt;val});
}
    int maxPathSum(TreeNode* root) {
        int ans = INT_MIN;
        maxSum(root, ans);
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 125. Valid Palindrome
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    s
   </code>
   , determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "A man, a plan, a canal: Panama"
<strong>Output:</strong> true
<strong>Explanation:</strong> "amanaplanacanalpanama" is a palindrome.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "race a car"
<strong>Output:</strong> false
<strong>Explanation:</strong> "raceacar" is not a palindrome.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 2 * 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consists only of printable ASCII characters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 125 -->
<pre>/*
 * @lc app=leetcode id=125 lang=cpp
 *
 * [125] Valid Palindrome
 */

// @lc code=start
class Solution {
public:
    bool isPalindrome(string s) {
        int start=0,end=s.length()-1;
        if(s==&quot; &quot;) return true;
        while(start&lt;=end){
            while(!isalnum(s[start]) &amp;&amp; start&lt;=end){
                start++;
            }
            while(!isalnum(s[end])  &amp;&amp; start&lt;=end ){
                end--;
            }
            cout&lt;&lt;start&lt;&lt;end;
            if((char)(tolower(s[start]))!=(char)(tolower(s[end])) &amp;&amp; start&lt;=end) return false;
            else {
                start++;
                end--;
            }
        }
        return true;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 126. Word Ladder II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   A
   <strong>
    transformation sequence
   </strong>
   from word
   <code>
    beginWord
   </code>
   to word
   <code>
    endWord
   </code>
   using a dictionary
   <code>
    wordList
   </code>
   is a sequence of words
   <code>
    beginWord -&gt; s
    <sub>
     1
    </sub>
    -&gt; s
    <sub>
     2
    </sub>
    -&gt; ... -&gt; s
    <sub>
     k
    </sub>
   </code>
   such that:
  </p>
  <ul>
   <li>
    Every adjacent pair of words differs by a single letter.
   </li>
   <li>
    Every
    <code>
     s
     <sub>
      i
     </sub>
    </code>
    for
    <code>
     1 &lt;= i &lt;= k
    </code>
    is in
    <code>
     wordList
    </code>
    . Note that
    <code>
     beginWord
    </code>
    does not need to be in
    <code>
     wordList
    </code>
    .
   </li>
   <li>
    <code>
     s
     <sub>
      k
     </sub>
     == endWord
    </code>
   </li>
  </ul>
  <p>
   Given two words,
   <code>
    beginWord
   </code>
   and
   <code>
    endWord
   </code>
   , and a dictionary
   <code>
    wordList
   </code>
   , return
   <em>
    all the
    <strong>
     shortest transformation sequences
    </strong>
    from
   </em>
   <code>
    beginWord
   </code>
   <em>
    to
   </em>
   <code>
    endWord
   </code>
   <em>
    , or an empty list if no such sequence exists. Each sequence should be returned as a list of the words
   </em>
   <code>
    [beginWord, s
    <sub>
     1
    </sub>
    , s
    <sub>
     2
    </sub>
    , ..., s
    <sub>
     k
    </sub>
    ]
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
<strong>Output:</strong> [["hit","hot","dot","dog","cog"],["hit","hot","lot","log","cog"]]
<strong>Explanation:</strong> There are 2 shortest transformation sequences:
"hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog"
"hit" -&gt; "hot" -&gt; "lot" -&gt; "log" -&gt; "cog"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
<strong>Output:</strong> []
<strong>Explanation:</strong> The endWord "cog" is not in wordList, therefore there is no valid transformation sequence.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= beginWord.length &lt;= 5
    </code>
   </li>
   <li>
    <code>
     endWord.length == beginWord.length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= wordList.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     wordList[i].length == beginWord.length
    </code>
   </li>
   <li>
    <code>
     beginWord
    </code>
    ,
    <code>
     endWord
    </code>
    , and
    <code>
     wordList[i]
    </code>
    consist of lowercase English letters.
   </li>
   <li>
    <code>
     beginWord != endWord
    </code>
   </li>
   <li>
    All the words in
    <code>
     wordList
    </code>
    are
    <strong>
     unique
    </strong>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 126 -->
<pre>/*
 * @lc app=leetcode id=126 lang=cpp
 *
 * [126] Word Ladder II
 */

// @lc code=start
class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 127. Word Ladder
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   A
   <strong>
    transformation sequence
   </strong>
   from word
   <code>
    beginWord
   </code>
   to word
   <code>
    endWord
   </code>
   using a dictionary
   <code>
    wordList
   </code>
   is a sequence of words
   <code>
    beginWord -&gt; s
    <sub>
     1
    </sub>
    -&gt; s
    <sub>
     2
    </sub>
    -&gt; ... -&gt; s
    <sub>
     k
    </sub>
   </code>
   such that:
  </p>
  <ul>
   <li>
    Every adjacent pair of words differs by a single letter.
   </li>
   <li>
    Every
    <code>
     s
     <sub>
      i
     </sub>
    </code>
    for
    <code>
     1 &lt;= i &lt;= k
    </code>
    is in
    <code>
     wordList
    </code>
    . Note that
    <code>
     beginWord
    </code>
    does not need to be in
    <code>
     wordList
    </code>
    .
   </li>
   <li>
    <code>
     s
     <sub>
      k
     </sub>
     == endWord
    </code>
   </li>
  </ul>
  <p>
   Given two words,
   <code>
    beginWord
   </code>
   and
   <code>
    endWord
   </code>
   , and a dictionary
   <code>
    wordList
   </code>
   , return
   <em>
    the
    <strong>
     number of words
    </strong>
    in the
    <strong>
     shortest transformation sequence
    </strong>
    from
   </em>
   <code>
    beginWord
   </code>
   <em>
    to
   </em>
   <code>
    endWord
   </code>
   <em>
    , or
   </em>
   <code>
    0
   </code>
   <em>
    if no such sequence exists.
   </em>
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
<strong>Output:</strong> 5
<strong>Explanation:</strong> One shortest transformation sequence is "hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; cog", which is 5 words long.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The endWord "cog" is not in wordList, therefore there is no valid transformation sequence.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= beginWord.length &lt;= 10
    </code>
   </li>
   <li>
    <code>
     endWord.length == beginWord.length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= wordList.length &lt;= 5000
    </code>
   </li>
   <li>
    <code>
     wordList[i].length == beginWord.length
    </code>
   </li>
   <li>
    <code>
     beginWord
    </code>
    ,
    <code>
     endWord
    </code>
    , and
    <code>
     wordList[i]
    </code>
    consist of lowercase English letters.
   </li>
   <li>
    <code>
     beginWord != endWord
    </code>
   </li>
   <li>
    All the words in
    <code>
     wordList
    </code>
    are
    <strong>
     unique
    </strong>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 127 -->
<pre>/*
 * @lc app=leetcode id=127 lang=cpp
 *
 * [127] Word Ladder
 */

// @lc code=start
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) {
        if(beginWord == endWord) return 0;
        if(find(wordList.begin(),wordList.end(),endWord) == wordList.end()) return 0;
        set&lt;string&gt;dict;
        for(int i = 0; i &lt; wordList.size();i++){
            dict.insert(wordList[i]);
        }
        int n=endWord.length(),level=0;
        queue&lt;string&gt; q;
        q.push(beginWord);
        while(!q.empty()) {
            level++;
            int m=q.size();
            for(int i=0;i&lt;m;i++){
                string word=q.front();
                q.pop();
                for(int i=0; i&lt;n; i++){
                    char org=word[i];
                    for(char j=&#x27;a&#x27;; j&lt;=&#x27;z&#x27;; j++){
                        word[i]=j;
                        if(word==endWord) return level+1;
                        if(dict.find(word) == dict.end()) continue;
                        q.push(word);
                        dict.erase(word);
                    }
                    word[i]=org;
                }
            }
        }
        return 0;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 128. Longest Consecutive Sequence
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an unsorted array of integers
   <code>
    nums
   </code>
   , return
   <em>
    the length of the longest consecutive elements sequence.
   </em>
  </p>
  <p>
   You must write an algorithm that runs in
   <code>
    O(n)
   </code>
   time.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [100,4,200,1,3,2]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The longest consecutive elements sequence is <code>[1, 2, 3, 4]</code>. Therefore its length is 4.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [0,3,7,2,5,8,4,6,0,1]
<strong>Output:</strong> 9
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= nums.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      9
     </sup>
     &lt;= nums[i] &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 128 -->
<pre>/*
 * @lc app=leetcode id=128 lang=cpp
 *
 * [128] Longest Consecutive Sequence
 */

// @lc code=start
class Solution {
public:
    int longestConsecutive(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(),nums.end());
        int count=1,max_ele=1;
        int n=nums.size();
        if(n&lt;=1){
            return n;
        }
        for(int i=0;i&lt;n-1;i++){
            if(nums[i+1]!=nums[i]){
                if(nums[i+1]==nums[i]+1){
                    count++;
                }
                else{
                    max_ele=max(count,max_ele);
                    count=1;
                }
            }
        }
        return max(count,max_ele);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 129. Sum Root to Leaf Numbers
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given the
   <code>
    root
   </code>
   of a binary tree containing digits from
   <code>
    0
   </code>
   to
   <code>
    9
   </code>
   only.
  </p>
  <p>
   Each root-to-leaf path in the tree represents a number.
  </p>
  <ul>
   <li>
    For example, the root-to-leaf path
    <code>
     1 -&gt; 2 -&gt; 3
    </code>
    represents the number
    <code>
     123
    </code>
    .
   </li>
  </ul>
  <p>
   Return
   <em>
    the total sum of all root-to-leaf numbers
   </em>
   . Test cases are generated so that the answer will fit in a
   <strong>
    32-bit
   </strong>
   integer.
  </p>
  <p>
   A
   <strong>
    leaf
   </strong>
   node is a node with no children.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/num1tree.jpg" style="width: 212px; height: 182px;"/>
  <pre><strong>Input:</strong> root = [1,2,3]
<strong>Output:</strong> 25
<strong>Explanation:</strong>
The root-to-leaf path <code>1-&gt;2</code> represents the number <code>12</code>.
The root-to-leaf path <code>1-&gt;3</code> represents the number <code>13</code>.
Therefore, sum = 12 + 13 = <code>25</code>.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/num2tree.jpg" style="width: 292px; height: 302px;"/>
  <pre><strong>Input:</strong> root = [4,9,0,5,1]
<strong>Output:</strong> 1026
<strong>Explanation:</strong>
The root-to-leaf path <code>4-&gt;9-&gt;5</code> represents the number 495.
The root-to-leaf path <code>4-&gt;9-&gt;1</code> represents the number 491.
The root-to-leaf path <code>4-&gt;0</code> represents the number 40.
Therefore, sum = 495 + 491 + 40 = <code>1026</code>.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [1, 1000]
    </code>
    .
   </li>
   <li>
    <code>
     0 &lt;= Node.val &lt;= 9
    </code>
   </li>
   <li>
    The depth of the tree will not exceed
    <code>
     10
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 129 -->
<pre>/*
 * @lc app=leetcode id=129 lang=cpp
 *
 * [129] Sum Root to Leaf Numbers
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
int ans=0;
    void create(TreeNode *root,string s){
        if(root==NULL) return;
        if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL){
            ans=ans+stoi(s+to_string(root-&gt;val));
            return;
        }
        create(root-&gt;left,s+to_string(root-&gt;val));
        create(root-&gt;right,s+to_string(root-&gt;val));
    }
    int sumNumbers(TreeNode* root) {
        create(root,&quot;&quot;);
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 130. Surrounded Regions
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an
   <code>
    m x n
   </code>
   matrix
   <code>
    board
   </code>
   containing
   <code>
    'X'
   </code>
   and
   <code>
    'O'
   </code>
   ,
   <em>
    capture all regions that are 4-directionally surrounded by
   </em>
   <code>
    'X'
   </code>
   .
  </p>
  <p>
   A region is
   <strong>
    captured
   </strong>
   by flipping all
   <code>
    'O'
   </code>
   s into
   <code>
    'X'
   </code>
   s in that surrounded region.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/xogrid.jpg" style="width: 550px; height: 237px;"/>
  <pre><strong>Input:</strong> board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
<strong>Output:</strong> [["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
<strong>Explanation:</strong> Surrounded regions should not be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> board = [["X"]]
<strong>Output:</strong> [["X"]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == board.length
    </code>
   </li>
   <li>
    <code>
     n == board[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m, n &lt;= 200
    </code>
   </li>
   <li>
    <code>
     board[i][j]
    </code>
    is
    <code>
     'X'
    </code>
    or
    <code>
     'O'
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 130 -->
<pre>wwww/*
 * @lc app=leetcode id=130 lang=cpp
 *
 * [130] Surrounded Regions
 */

// @lc code=start
class Solution {
public:
    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board,int x,int y,char value){
        if(x&lt;0 || y&lt;0 || x&gt;=board.size()|| y&gt;=board[x].size()){
            return;
        }
        if(board[x][y]!=&#x27;O&#x27;){
            return;
        }
        board[x][y] = value;
        dfs(board,x-1,y,value);
        dfs(board,x+1,y,value);
        dfs(board,x,y-1,value);
        dfs(board,x,y+1,value);
    }
    void solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        for(int i = 0; i &lt; board.size();i++){
            for(int j = 0; j &lt; board[i].size();j++){
                if((i==0 || j==0|| i==board.size()-1 || j==board[i].size()-1) &amp;&amp; board[i][j]==&#x27;O&#x27;){
                    dfs(board,i,j,&#x27;1&#x27;);
                }
            }
        }

        for(int i = 1; i &lt; board.size()-1;i++){
            for(int j = 1; j &lt; board[i].size()-1;j++){
                    dfs(board,i,j,&#x27;X&#x27;);
            }
        }

        for(int i = 0; i &lt; board.size();i++){
            for(int j = 0; j &lt; board[i].size();j++){
                if(board[i][j]==&#x27;1&#x27;) board[i][j]=&#x27;O&#x27;;
            }
        }
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 131. Palindrome Partitioning
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    s
   </code>
   , partition
   <code>
    s
   </code>
   such that every substring of the partition is a
   <strong>
    palindrome
   </strong>
   . Return all possible palindrome partitioning of
   <code>
    s
   </code>
   .
  </p>
  <p>
   A
   <strong>
    palindrome
   </strong>
   string is a string that reads the same backward as forward.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "aab"
<strong>Output:</strong> [["a","a","b"],["aa","b"]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "a"
<strong>Output:</strong> [["a"]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 16
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    contains only lowercase English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 131 -->
<pre>/*
 * @lc app=leetcode id=131 lang=cpp
 *
 * [131] Palindrome Partitioning
 */

// @lc code=start
class Solution {
public:
    int res=0;
    vector&lt;vector&lt;string&gt;&gt;a;
    int check(string s1,string s2){
        reverse(s2.begin(),s2.end());
        if(s1.compare(s2)==0){
            return 1;
        }
        return 0;
    }
    void ans(vector&lt;string&gt;b,string s){
        if(s.size()==0){
            res=min(res,b.size()-1);
            a.push_back(b);
            return;
        }
        for(int i=0;i&lt;s.size();i++){
            if(check(s.substr(0,i+1),s.substr(0,i+1))){
                b.push_back(s.substr(0,i+1));
                ans(b,s.substr(i+1,s.size()-i-1));
                b.pop_back();
            }
        }
    }
    vector&lt;vector&lt;string&gt;&gt; partition(string s) {
            int i=0,n=s.length();
            vector&lt;string&gt;b;
            ans(b,s);
            return res;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 132. Palindrome Partitioning II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    s
   </code>
   , partition
   <code>
    s
   </code>
   such that every substring of the partition is a palindrome.
  </p>
  <p>
   Return
   <em>
    the minimum cuts needed
   </em>
   for a palindrome partitioning of
   <code>
    s
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "aab"
<strong>Output:</strong> 1
<strong>Explanation:</strong> The palindrome partitioning ["aa","b"] could be produced using 1 cut.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "a"
<strong>Output:</strong> 0
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "ab"
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 2000
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consists of lower-case English letters only.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 132 -->
<pre>/*
 * @lc app=leetcode id=132 lang=cpp
 *
 * [132] Palindrome Partitioning II
 */

// @lc code=start
class Solution {
public:
vector&lt;vector&lt;string&gt;&gt;a;
int check(string s1,string s2){
    reverse(s2.begin(),s2.end());
    if(s1.compare(s2)==0)
    {
        return 1;
    }
    return 0;
}

void ans(vector&lt;string&gt;b,string s,int&amp; cut){
    if(s.size()==0){
        a.push_back(b);
        if(cut&gt;b.size()-1)cut=b.size()-1;
        return;
    }
    cout&lt;&lt;s&lt;&lt;&#x27;\n&#x27;;
    for(int i=0;i&lt;s.size();i++){
        if(check(s.substr(0,i+1),s.substr(0,i+1))){
        b.push_back(s.substr(0,i+1));
        ans(b,s.substr(i+1,s.size()-i-1),cut);
        b.pop_back();
        }
    }
}

int minCut(string s) {
    int i=0,n=s.length();
    vector&lt;string&gt;b;
    int cut=s.length()-1;
    ans(b,s,cut);
    return cut;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 136. Single Number
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a
   <strong>
    non-empty
   </strong>
   array of integers
   <code>
    nums
   </code>
   , every element appears
   <em>
    twice
   </em>
   except for one. Find that single one.
  </p>
  <p>
   You must implement a solution with a linear runtime complexity and use only constant extra space.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,2,1]
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [4,1,2,1,2]
<strong>Output:</strong> 4
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1]
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 3 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -3 * 10
     <sup>
      4
     </sup>
     &lt;= nums[i] &lt;= 3 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    Each element in the array appears twice except for one element which appears only once.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 136 -->
<pre>/*
 * @lc app=leetcode id=136 lang=cpp
 *
 * [136] Single Number
 */

// @lc code=start
class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {
        int ans=nums[0];
        for(int i=1; i&lt;nums.size(); i++){
            ans=ans^nums[i];
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 137. Single Number II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   where every element appears
   <strong>
    three times
   </strong>
   except for one, which appears
   <strong>
    exactly once
   </strong>
   .
   <em>
    Find the single element and return it
   </em>
   .
  </p>
  <p>
   You must implement a solution with a linear runtime complexity and use only constant extra space.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,2,3,2]
<strong>Output:</strong> 3
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [0,1,0,1,0,1,99]
<strong>Output:</strong> 99
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 3 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= nums[i] &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
   <li>
    Each element in
    <code>
     nums
    </code>
    appears exactly
    <strong>
     three times
    </strong>
    except for one element which appears
    <strong>
     once
    </strong>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 137 -->
<pre>/*
 * @lc app=leetcode id=137 lang=cpp
 *
 * [137] Single Number II
 */

// @lc code=start
class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {
        unordered_map&lt;int,int&gt; m;

        for(auto v:nums){
            m[v]++;
        }

        for(auto val:m){
            if(val.second == 1){
                return val.first;
            }
        }

        return -1;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 138. Copy List with Random Pointer
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   A linked list of length
   <code>
    n
   </code>
   is given such that each node contains an additional random pointer, which could point to any node in the list, or
   <code>
    null
   </code>
   .
  </p>
  <p>
   Construct a
   <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy" target="_blank">
    <strong>
     deep copy
    </strong>
   </a>
   of the list. The deep copy should consist of exactly
   <code>
    n
   </code>
   <strong>
    brand new
   </strong>
   nodes, where each new node has its value set to the value of its corresponding original node. Both the
   <code>
    next
   </code>
   and
   <code>
    random
   </code>
   pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state.
   <strong>
    None of the pointers in the new list should point to nodes in the original list
   </strong>
   .
  </p>
  <p>
   For example, if there are two nodes
   <code>
    X
   </code>
   and
   <code>
    Y
   </code>
   in the original list, where
   <code>
    X.random --&gt; Y
   </code>
   , then for the corresponding two nodes
   <code>
    x
   </code>
   and
   <code>
    y
   </code>
   in the copied list,
   <code>
    x.random --&gt; y
   </code>
   .
  </p>
  <p>
   Return
   <em>
    the head of the copied linked list
   </em>
   .
  </p>
  <p>
   The linked list is represented in the input/output as a list of
   <code>
    n
   </code>
   nodes. Each node is represented as a pair of
   <code>
    [val, random_index]
   </code>
   where:
  </p>
  <ul>
   <li>
    <code>
     val
    </code>
    : an integer representing
    <code>
     Node.val
    </code>
   </li>
   <li>
    <code>
     random_index
    </code>
    : the index of the node (range from
    <code>
     0
    </code>
    to
    <code>
     n-1
    </code>
    ) that the
    <code>
     random
    </code>
    pointer points to, or
    <code>
     null
    </code>
    if it does not point to any node.
   </li>
  </ul>
  <p>
   Your code will
   <strong>
    only
   </strong>
   be given the
   <code>
    head
   </code>
   of the original linked list.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/e1(2).png" style="width: 700px; height: 142px;"/>
  <pre><strong>Input:</strong> head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
<strong>Output:</strong> [[7,null],[13,0],[11,4],[10,2],[1,0]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/e2(2).png" style="width: 700px; height: 114px;"/>
  <pre><strong>Input:</strong> head = [[1,1],[2,1]]
<strong>Output:</strong> [[1,1],[2,1]]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <p>
   <strong>
    <img alt="" src="./output_files/e3.png" style="width: 700px; height: 122px;"/>
   </strong>
  </p>
  <pre><strong>Input:</strong> head = [[3,null],[3,0],[3,null]]
<strong>Output:</strong> [[3,null],[3,0],[3,null]]
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> head = []
<strong>Output:</strong> []
<strong>Explanation:</strong> The given linked list is empty (null pointer), so return null.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= n &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     -10000 &lt;= Node.val &lt;= 10000
    </code>
   </li>
   <li>
    <code>
     Node.random
    </code>
    is
    <code>
     null
    </code>
    or is pointing to some node in the linked list.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 138 -->
<pre>/*
 * @lc app=leetcode id=138 lang=cpp
 *
 * [138] Copy List with Random Pointer
 */

// @lc code=start
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/

class Solution {
public:
    Node* copyRandomList(Node* head) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 139. Word Break
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    s
   </code>
   and a dictionary of strings
   <code>
    wordDict
   </code>
   , return
   <code>
    true
   </code>
   if
   <code>
    s
   </code>
   can be segmented into a space-separated sequence of one or more dictionary words.
  </p>
  <p>
   <strong>
    Note
   </strong>
   that the same word in the dictionary may be reused multiple times in the segmentation.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "leetcode", wordDict = ["leet","code"]
<strong>Output:</strong> true
<strong>Explanation:</strong> Return true because "leetcode" can be segmented as "leet code".
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "applepenapple", wordDict = ["apple","pen"]
<strong>Output:</strong> true
<strong>Explanation:</strong> Return true because "applepenapple" can be segmented as "apple pen apple".
Note that you are allowed to reuse a dictionary word.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 300
    </code>
   </li>
   <li>
    <code>
     1 &lt;= wordDict.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     1 &lt;= wordDict[i].length &lt;= 20
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    and
    <code>
     wordDict[i]
    </code>
    consist of only lowercase English letters.
   </li>
   <li>
    All the strings of
    <code>
     wordDict
    </code>
    are
    <strong>
     unique
    </strong>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 139 -->
<pre>x/*
 * @lc app=leetcode id=139 lang=cpp
 *
 * [139] Word Break
 */

// @lc code=start
class Solution {
public:
    bool f(int i,string s ,vector&lt;string&gt;&amp;a,vector&lt;int&gt;&amp;dp){
        if(i==s.size()){
            return 1;
        }
        if(dp[i]!=-1){
            return dp[i];
        }
        string temp;
        for(int j=i;j&lt;s.length();j++){
            temp=temp+s[j];
            if(find(a.begin(),a.end(),temp)!=a.end()){
                if(f(j+1,s,a,dp)){
                    return dp[i]=1;
                }
            }
        }
        return dp[i]=0;
    }
    bool wordBreak(string s, vector&lt;string&gt;&amp; a) {
        int i=0;
        vector&lt;int&gt;dp(s.length(),-1);
        return f(i,s,a,dp);
    }

};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 141. Linked List Cycle
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given
   <code>
    head
   </code>
   , the head of a linked list, determine if the linked list has a cycle in it.
  </p>
  <p>
   There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the
   <code>
    next
   </code>
   pointer. Internally,
   <code>
    pos
   </code>
   is used to denote the index of the node that tail's
   <code>
    next
   </code>
   pointer is connected to.
   <strong>
    Note that
    <code>
     pos
    </code>
    is not passed as a parameter
   </strong>
   .
  </p>
  <p>
   Return
   <code>
    true
   </code>
   <em>
    if there is a cycle in the linked list
   </em>
   . Otherwise, return
   <code>
    false
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/circularlinkedlist.png" style="width: 300px; height: 97px; margin-top: 8px; margin-bottom: 8px;"/>
  <pre><strong>Input:</strong> head = [3,2,0,-4], pos = 1
<strong>Output:</strong> true
<strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/circularlinkedlist_test2.png" style="width: 141px; height: 74px;"/>
  <pre><strong>Input:</strong> head = [1,2], pos = 0
<strong>Output:</strong> true
<strong>Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 0th node.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <img alt="" src="./output_files/circularlinkedlist_test3.png" style="width: 45px; height: 45px;"/>
  <pre><strong>Input:</strong> head = [1], pos = -1
<strong>Output:</strong> false
<strong>Explanation:</strong> There is no cycle in the linked list.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of the nodes in the list is in the range
    <code>
     [0, 10
     <sup>
      4
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     -10
     <sup>
      5
     </sup>
     &lt;= Node.val &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     pos
    </code>
    is
    <code>
     -1
    </code>
    or a
    <strong>
     valid index
    </strong>
    in the linked-list.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   Can you solve it using
   <code>
    O(1)
   </code>
   (i.e. constant) memory?
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 141 -->
<pre>/*
 * @lc app=leetcode id=141 lang=cpp
 *
 * [141] Linked List Cycle
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode *temp= head;
        map&lt;ListNode * , int&gt;m;
        while(temp!=NULL)
        {
            if(m[temp]==1){
                return 1;
            }
            m[temp]=1;
            temp=temp-&gt;next;
        }
        return 0;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 142. Linked List Cycle II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    head
   </code>
   of a linked list, return
   <em>
    the node where the cycle begins. If there is no cycle, return
   </em>
   <code>
    null
   </code>
   .
  </p>
  <p>
   There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the
   <code>
    next
   </code>
   pointer. Internally,
   <code>
    pos
   </code>
   is used to denote the index of the node that tail's
   <code>
    next
   </code>
   pointer is connected to (
   <strong>
    0-indexed
   </strong>
   ). It is
   <code>
    -1
   </code>
   if there is no cycle.
   <strong>
    Note that
   </strong>
   <code>
    pos
   </code>
   <strong>
    is not passed as a parameter
   </strong>
   .
  </p>
  <p>
   <strong>
    Do not modify
   </strong>
   the linked list.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/circularlinkedlist.png" style="height: 145px; width: 450px;"/>
  <pre><strong>Input:</strong> head = [3,2,0,-4], pos = 1
<strong>Output:</strong> tail connects to node index 1
<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the second node.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/circularlinkedlist_test2.png" style="height: 105px; width: 201px;"/>
  <pre><strong>Input:</strong> head = [1,2], pos = 0
<strong>Output:</strong> tail connects to node index 0
<strong>Explanation:</strong> There is a cycle in the linked list, where tail connects to the first node.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <img alt="" src="./output_files/circularlinkedlist_test3.png" style="height: 65px; width: 65px;"/>
  <pre><strong>Input:</strong> head = [1], pos = -1
<strong>Output:</strong> no cycle
<strong>Explanation:</strong> There is no cycle in the linked list.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of the nodes in the list is in the range
    <code>
     [0, 10
     <sup>
      4
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     -10
     <sup>
      5
     </sup>
     &lt;= Node.val &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     pos
    </code>
    is
    <code>
     -1
    </code>
    or a
    <strong>
     valid index
    </strong>
    in the linked-list.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   Can you solve it using
   <code>
    O(1)
   </code>
   (i.e. constant) memory?
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 142 -->
<pre>/*
 * @lc app=leetcode id=142 lang=cpp
 *
 * [142] Linked List Cycle II
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *temp= head;
        map&lt;ListNode * , pair&lt;ListNode *,int&gt;&gt;m;
        while(temp!=NULL)
        {
            if(m[temp].second==1){
                return m[temp].first;
            }
            m[temp]={temp,1};
            temp=temp-&gt;next;
        }
        return NULL;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 143. Reorder List
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given the head of a singly linked-list. The list can be represented as:
  </p>
  <pre>L<sub>0</sub> → L<sub>1</sub> → … → L<sub>n - 1</sub> → L<sub>n</sub>
</pre>
  <p>
   <em>
    Reorder the list to be on the following form:
   </em>
  </p>
  <pre>L<sub>0</sub> → L<sub>n</sub> → L<sub>1</sub> → L<sub>n - 1</sub> → L<sub>2</sub> → L<sub>n - 2</sub> → …
</pre>
  <p>
   You may not modify the values in the list's nodes. Only nodes themselves may be changed.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/reorder1linked-list.jpg" style="width: 422px; height: 222px;"/>
  <pre><strong>Input:</strong> head = [1,2,3,4]
<strong>Output:</strong> [1,4,2,3]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/reorder2-linked-list.jpg" style="width: 542px; height: 222px;"/>
  <pre><strong>Input:</strong> head = [1,2,3,4,5]
<strong>Output:</strong> [1,5,2,4,3]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the list is in the range
    <code>
     [1, 5 * 10
     <sup>
      4
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     1 &lt;= Node.val &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 143 -->
<pre>/*
 * @lc app=leetcode id=143 lang=cpp
 *
 * [143] Reorder List
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    void reorderList(ListNode* head) {
        vector&lt;int&gt;a;
        ListNode *temp=head;
        while(temp!=NULL){
            a.push_back(temp-&gt;val);
            temp=temp-&gt;next;
        }
        if(a.size()==1) return;
        temp=head;
        int start=0,end=a.size()-1;
        ListNode *prev=NULL;
        while(start&lt;=end &amp;&amp; temp-&gt;next!=NULL){
            temp-&gt;val=a[start++];
            temp-&gt;next-&gt;val=a[end--];
            prev=temp-&gt;next;
            temp=temp-&gt;next-&gt;next;
        }
        if(a.size()%2==1){
            prev-&gt;next-&gt;val=a[start];
        }
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 144. Binary Tree Preorder Traversal
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree, return
   <em>
    the preorder traversal of its nodes' values
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/inorder_1.jpg" style="width: 202px; height: 324px;"/>
  <pre><strong>Input:</strong> root = [1,null,2,3]
<strong>Output:</strong> [1,2,3]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1]
<strong>Output:</strong> [1]
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <img alt="" src="./output_files/inorder_5.jpg" style="width: 202px; height: 202px;"/>
  <pre><strong>Input:</strong> root = [1,2]
<strong>Output:</strong> [1,2]
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <img alt="" src="./output_files/inorder_4.jpg" style="width: 202px; height: 202px;"/>
  <pre><strong>Input:</strong> root = [1,null,2]
<strong>Output:</strong> [1,2]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [0, 100]
    </code>
    .
   </li>
   <li>
    <code>
     -100 &lt;= Node.val &lt;= 100
    </code>
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   Recursive solution is trivial, could you do it iteratively?
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 144 -->
<pre>/*
 * @lc app=leetcode id=144 lang=cpp
 *
 * [144] Binary Tree Preorder Traversal
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
void preorder(vector&lt;int&gt;&amp;ans,TreeNode* root){
    if(root!=NULL){
        ans.push_back(root-&gt;val);
        preorder(ans,root-&gt;left);
        preorder(ans,root-&gt;right);
    }
}
    vector&lt;int&gt; preorderTraversal(TreeNode* root) {
        if(root==NULL){return {};}
        vector&lt;int&gt;ans;
        preorder(ans,root);
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 145. Binary Tree Postorder Traversal
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree, return
   <em>
    the postorder traversal of its nodes' values
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/pre1.jpg" style="width: 202px; height: 317px;"/>
  <pre><strong>Input:</strong> root = [1,null,2,3]
<strong>Output:</strong> [3,2,1]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1]
<strong>Output:</strong> [1]
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <img alt="" src="./output_files/pre3.jpg" style="width: 202px; height: 197px;"/>
  <pre><strong>Input:</strong> root = [1,2]
<strong>Output:</strong> [2,1]
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <img alt="" src="./output_files/pre2.jpg" style="width: 202px; height: 197px;"/>
  <pre><strong>Input:</strong> root = [1,null,2]
<strong>Output:</strong> [2,1]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of the nodes in the tree is in the range
    <code>
     [0, 100]
    </code>
    .
   </li>
   <li>
    <code>
     -100 &lt;= Node.val &lt;= 100
    </code>
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow up:
  </strong>
  Recursive solution is trivial, could you do it iteratively?
 </div>
</div>
</body></html>
<!-- Solution for Question 145 -->
<pre>/*
 * @lc app=leetcode id=145 lang=cpp
 *
 * [145] Binary Tree Postorder Traversal
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

void postorder(vector&lt;int&gt;&amp;ans,TreeNode* root){
    if(root!=NULL){
        postorder(ans,root-&gt;left);
        postorder(ans,root-&gt;right);
        ans.push_back(root-&gt;val);
    }
}
    vector&lt;int&gt; postorderTraversal(TreeNode* root) {
        if(root==NULL){return {};}
        vector&lt;int&gt;ans;
        postorder(ans,root);
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 146. LRU Cache
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Design a data structure that follows the constraints of a
   <strong>
    <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU" target="_blank">
     Least Recently Used (LRU) cache
    </a>
   </strong>
   .
  </p>
  <p>
   Implement the
   <code>
    LRUCache
   </code>
   class:
  </p>
  <ul>
   <li>
    <code>
     LRUCache(int capacity)
    </code>
    Initialize the LRU cache with
    <strong>
     positive
    </strong>
    size
    <code>
     capacity
    </code>
    .
   </li>
   <li>
    <code>
     int get(int key)
    </code>
    Return the value of the
    <code>
     key
    </code>
    if the key exists, otherwise return
    <code>
     -1
    </code>
    .
   </li>
   <li>
    <code>
     void put(int key, int value)
    </code>
    Update the value of the
    <code>
     key
    </code>
    if the
    <code>
     key
    </code>
    exists. Otherwise, add the
    <code>
     key-value
    </code>
    pair to the cache. If the number of keys exceeds the
    <code>
     capacity
    </code>
    from this operation,
    <strong>
     evict
    </strong>
    the least recently used key.
   </li>
  </ul>
  <p>
   The functions
   <code data-stringify-type="code">
    get
   </code>
   and
   <code data-stringify-type="code">
    put
   </code>
   must each run in
   <code>
    O(1)
   </code>
   average time complexity.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input</strong>
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
<strong>Output</strong>
[null, null, null, 1, null, -1, null, -1, 3, 4]

<strong>Explanation</strong>
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // cache is {1=1}
lRUCache.put(2, 2); // cache is {1=1, 2=2}
lRUCache.get(1);    // return 1
lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
lRUCache.get(2);    // returns -1 (not found)
lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
lRUCache.get(1);    // return -1 (not found)
lRUCache.get(3);    // return 3
lRUCache.get(4);    // return 4
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= capacity &lt;= 3000
    </code>
   </li>
   <li>
    <code>
     0 &lt;= key &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= value &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    At most 2
    <code>
     * 10
     <sup>
      5
     </sup>
    </code>
    calls will be made to
    <code>
     get
    </code>
    and
    <code>
     put
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 146 -->
<pre>/*
 * @lc app=leetcode id=146 lang=cpp
 *
 * [146] LRU Cache
 */

// @lc code=start
class LRUCache {
public:
    queue&lt;int&gt;q;
    int val[10001];
    int count[10001];
    int total=0,frame;
    LRUCache(int capacity) {
        frame=capacity;
    }

    int get(int key) {
        if(count[key]==0) return -1;
        put(key,val[key]);
        return val[key];
    }

    void put(int key, int value) {
        if(count[key]==0){
            if(frame&gt;total) total++;
            else{
                while(true){
                    if(--count[q.front()]==0){
                        q.pop();
                        break;
                    }
                    q.pop();
                }
            }
        }
        count[key]++;
        val[key]=value;
        q.push(key);
    }
};
/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj-&gt;get(key);
 * obj-&gt;put(key,value);
 */
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 147. Insertion Sort List
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    head
   </code>
   of a singly linked list, sort the list using
   <strong>
    insertion sort
   </strong>
   , and return
   <em>
    the sorted list's head
   </em>
   .
  </p>
  <p>
   The steps of the
   <strong>
    insertion sort
   </strong>
   algorithm:
  </p>
  <ol>
   <li>
    Insertion sort iterates, consuming one input element each repetition and growing a sorted output list.
   </li>
   <li>
    At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.
   </li>
   <li>
    It repeats until no input elements remain.
   </li>
  </ol>
  <p>
   The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.
  </p>
  <img alt="" src="./output_files/Insertion-sort-example-300px.gif" style="height:180px; width:300px"/>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/sort1linked-list.jpg" style="width: 422px; height: 222px;"/>
  <pre><strong>Input:</strong> head = [4,2,1,3]
<strong>Output:</strong> [1,2,3,4]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/sort2linked-list.jpg" style="width: 542px; height: 222px;"/>
  <pre><strong>Input:</strong> head = [-1,5,3,4,0]
<strong>Output:</strong> [-1,0,3,4,5]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the list is in the range
    <code>
     [1, 5000]
    </code>
    .
   </li>
   <li>
    <code>
     -5000 &lt;= Node.val &lt;= 5000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 147 -->
<pre>/*
 * @lc app=leetcode id=147 lang=cpp
 *
 * [147] Insertion Sort List
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 148. Sort List
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    head
   </code>
   of a linked list, return
   <em>
    the list after sorting it in
    <strong>
     ascending order
    </strong>
   </em>
   .
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   Can you sort the linked list in
   <code>
    O(n logn)
   </code>
   time and
   <code>
    O(1)
   </code>
   memory (i.e. constant space)?
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/sort_list_1.jpg" style="width: 450px; height: 194px;"/>
  <pre><strong>Input:</strong> head = [4,2,1,3]
<strong>Output:</strong> [1,2,3,4]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/sort_list_2.jpg" style="width: 550px; height: 184px;"/>
  <pre><strong>Input:</strong> head = [-1,5,3,4,0]
<strong>Output:</strong> [-1,0,3,4,5]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> head = []
<strong>Output:</strong> []
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the list is in the range
    <code>
     [0, 5 * 10
     <sup>
      4
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     -10
     <sup>
      5
     </sup>
     &lt;= Node.val &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 148 -->
<pre>/*
 * @lc app=leetcode id=148 lang=cpp
 *
 * [148] Sort List
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        vector&lt;int&gt;ans;
        ListNode *temp=head;
        while(temp){
            ans.push_back(temp-&gt;val);
            temp=temp-&gt;next;
        }
        temp=head;
        int i=0;
        sort(ans.begin(), ans.end());
        while(temp){
            temp-&gt;val=ans[i];
            i++;
            temp=temp-&gt;next;
        }
        return head;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 149. Max Points on a Line
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of
   <code>
    points
   </code>
   where
   <code>
    points[i] = [x
    <sub>
     i
    </sub>
    , y
    <sub>
     i
    </sub>
    ]
   </code>
   represents a point on the
   <strong>
    X-Y
   </strong>
   plane, return
   <em>
    the maximum number of points that lie on the same straight line
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/plane1.jpg" style="width: 300px; height: 294px;"/>
  <pre><strong>Input:</strong> points = [[1,1],[2,2],[3,3]]
<strong>Output:</strong> 3
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/plane2.jpg" style="width: 300px; height: 294px;"/>
  <pre><strong>Input:</strong> points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
<strong>Output:</strong> 4
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= points.length &lt;= 300
    </code>
   </li>
   <li>
    <code>
     points[i].length == 2
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= x
     <sub>
      i
     </sub>
     , y
     <sub>
      i
     </sub>
     &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    All the
    <code>
     points
    </code>
    are
    <strong>
     unique
    </strong>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 149 -->
<pre>/*
 * @lc app=leetcode id=149 lang=cpp
 *
 * [149] Max Points on a Line
 */

// @lc code=start
class Solution {
public:
    int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 150. Evaluate Reverse Polish Notation
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Evaluate the value of an arithmetic expression in
   <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" target="_blank">
    Reverse Polish Notation
   </a>
   .
  </p>
  <p>
   Valid operators are
   <code>
    +
   </code>
   ,
   <code>
    -
   </code>
   ,
   <code>
    *
   </code>
   , and
   <code>
    /
   </code>
   . Each operand may be an integer or another expression.
  </p>
  <p>
   <strong>
    Note
   </strong>
   that division between two integers should truncate toward zero.
  </p>
  <p>
   It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> tokens = ["2","1","+","3","*"]
<strong>Output:</strong> 9
<strong>Explanation:</strong> ((2 + 1) * 3) = 9
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> tokens = ["4","13","5","/","+"]
<strong>Output:</strong> 6
<strong>Explanation:</strong> (4 + (13 / 5)) = 6
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
<strong>Output:</strong> 22
<strong>Explanation:</strong> ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= tokens.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     tokens[i]
    </code>
    is either an operator:
    <code>
     "+"
    </code>
    ,
    <code>
     "-"
    </code>
    ,
    <code>
     "*"
    </code>
    , or
    <code>
     "/"
    </code>
    , or an integer in the range
    <code>
     [-200, 200]
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 150 -->
<pre>/*
 * @lc app=leetcode id=150 lang=cpp
 *
 * [150] Evaluate Reverse Polish Notation
 */

// @lc code=start
class Solution {
public:
    int evalRPN(vector&lt;string&gt;&amp; tokens) {
        stack&lt;int&gt;s;
        for(int i = 0; i &lt; tokens.size();i++){
            if(tokens[i] == &quot;+&quot; || tokens[i] ==&quot;-&quot; || tokens[i] == &quot;*&quot; || tokens[i] == &quot;/&quot;){
                int x=s.top();
                s.pop();
                int y=s.top();
                s.pop();
                if(tokens[i] == &quot;-&quot;) s.push(y-x);
                else if(tokens[i] == &quot;+&quot;) s.push(x+y);
                else if(tokens[i]==&quot;*&quot;) s.push(x*y);
                else s.push(y/x);
            }
            else{
                s.push(stoi(tokens[i]));
            }
        }
        return s.top();
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 151. Reverse Words in a String
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an input string
   <code>
    s
   </code>
   , reverse the order of the
   <strong>
    words
   </strong>
   .
  </p>
  <p>
   A
   <strong>
    word
   </strong>
   is defined as a sequence of non-space characters. The
   <strong>
    words
   </strong>
   in
   <code>
    s
   </code>
   will be separated by at least one space.
  </p>
  <p>
   Return
   <em>
    a string of the words in reverse order concatenated by a single space.
   </em>
  </p>
  <p>
   <b>
    Note
   </b>
   that
   <code>
    s
   </code>
   may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "the sky is blue"
<strong>Output:</strong> "blue is sky the"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "  hello world  "
<strong>Output:</strong> "world hello"
<strong>Explanation:</strong> Your reversed string should not contain leading or trailing spaces.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "a good   example"
<strong>Output:</strong> "example good a"
<strong>Explanation:</strong> You need to reduce multiple spaces between two words to a single space in the reversed string.
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "  Bob    Loves  Alice   "
<strong>Output:</strong> "Alice Loves Bob"
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "Alice does not even like bob"
<strong>Output:</strong> "bob like even not does Alice"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    contains English letters (upper-case and lower-case), digits, and spaces
    <code>
     ' '
    </code>
    .
   </li>
   <li>
    There is
    <strong>
     at least one
    </strong>
    word in
    <code>
     s
    </code>
    .
   </li>
  </ul>
  <p>
  </p>
  <p>
   <b data-stringify-type="bold">
    Follow-up:
   </b>
   If the string data type is mutable in your language, can you solve it
   <b data-stringify-type="bold">
    in-place
   </b>
   with
   <code data-stringify-type="code">
    O(1)
   </code>
   extra space?
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 151 -->
<pre>/*
 * @lc app=leetcode id=151 lang=cpp
 *
 * [151] Reverse Words in a String
 */

// @lc code=start
class Solution {
public:
    string reverseWords(string s) {
        string ans=&quot;&quot;;
        int i=0;
        string temp=&quot;&quot;;
        int count=0;
        while(i&lt;s.length()) {
            if(s[i]!=&#x27; &#x27;){
                temp=temp+s[i];
                i++;
                count=0;
            }
            else if(count==0 &amp;&amp; s[i]==&#x27; &#x27;){
                if(ans==&quot;&quot;) ans=temp;
                else ans=temp+&#x27; &#x27;+ans;
                count++;
                temp=&quot;&quot;;
                i++;
            }
            else{
                i++;
            }
            cout&lt;&lt;temp&lt;&lt;&quot; &quot;&lt;&lt;count&lt;&lt;endl;
        }
        return count==1?ans:ans==&quot;&quot;?temp:temp+&#x27; &#x27;+ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 152. Maximum Product Subarray
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   , find a contiguous non-empty subarray within the array that has the largest product, and return
   <em>
    the product
   </em>
   .
  </p>
  <p>
   It is
   <strong>
    guaranteed
   </strong>
   that the answer will fit in a
   <strong>
    32-bit
   </strong>
   integer.
  </p>
  <p>
   A
   <strong>
    subarray
   </strong>
   is a contiguous subsequence of the array.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,3,-2,4]
<strong>Output:</strong> 6
<strong>Explanation:</strong> [2,3] has the largest product 6.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [-2,0,-1]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The result cannot be 2, because [-2,-1] is not a subarray.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 2 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -10 &lt;= nums[i] &lt;= 10
    </code>
   </li>
   <li>
    The product of any prefix or suffix of
    <code>
     nums
    </code>
    is
    <strong>
     guaranteed
    </strong>
    to fit in a
    <strong>
     32-bit
    </strong>
    integer.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 152 -->
<pre>/*
 * @lc app=leetcode id=152 lang=cpp
 *
 * [152] Maximum Product Subarray
 */

// @lc code=start
class Solution {
public:
    int maxProduct(vector&lt;int&gt;&amp; nums) {
        int max_1=nums[0];
        int max_till=nums[0];
        int min_till=nums[0];
        for(int i=1;i&lt;nums.size();i++)
        {
            int temp=max({nums[i],max_till*nums[i],min_till*nums[i]});
            min_till=min({nums[i],max_till*nums[i],min_till*nums[i]});
            max_till=temp;
            max_1=max(max_1,max_till);
        }
        return max_1;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 153. Find Minimum in Rotated Sorted Array
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Suppose an array of length
   <code>
    n
   </code>
   sorted in ascending order is
   <strong>
    rotated
   </strong>
   between
   <code>
    1
   </code>
   and
   <code>
    n
   </code>
   times. For example, the array
   <code>
    nums = [0,1,2,4,5,6,7]
   </code>
   might become:
  </p>
  <ul>
   <li>
    <code>
     [4,5,6,7,0,1,2]
    </code>
    if it was rotated
    <code>
     4
    </code>
    times.
   </li>
   <li>
    <code>
     [0,1,2,4,5,6,7]
    </code>
    if it was rotated
    <code>
     7
    </code>
    times.
   </li>
  </ul>
  <p>
   Notice that
   <strong>
    rotating
   </strong>
   an array
   <code>
    [a[0], a[1], a[2], ..., a[n-1]]
   </code>
   1 time results in the array
   <code>
    [a[n-1], a[0], a[1], a[2], ..., a[n-2]]
   </code>
   .
  </p>
  <p>
   Given the sorted rotated array
   <code>
    nums
   </code>
   of
   <strong>
    unique
   </strong>
   elements, return
   <em>
    the minimum element of this array
   </em>
   .
  </p>
  <p>
   You must write an algorithm that runs in
   <code>
    O(log n) time.
   </code>
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,4,5,1,2]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The original array was [1,2,3,4,5] rotated 3 times.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [4,5,6,7,0,1,2]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [11,13,15,17]
<strong>Output:</strong> 11
<strong>Explanation:</strong> The original array was [11,13,15,17] and it was rotated 4 times. 
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == nums.length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 5000
    </code>
   </li>
   <li>
    <code>
     -5000 &lt;= nums[i] &lt;= 5000
    </code>
   </li>
   <li>
    All the integers of
    <code>
     nums
    </code>
    are
    <strong>
     unique
    </strong>
    .
   </li>
   <li>
    <code>
     nums
    </code>
    is sorted and rotated between
    <code>
     1
    </code>
    and
    <code>
     n
    </code>
    times.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 153 -->
<pre>/*
 * @lc app=leetcode id=153 lang=cpp
 *
 * [153] Find Minimum in Rotated Sorted Array
 */

// @lc code=start
class Solution {
public:
    int findMin(vector&lt;int&gt;&amp; a) {
        int start = 0, end = a.size()-1;
        while(start &lt; end) {
            int mid=(start+end)/2;
            if(a[mid]&gt;a[end]) start=mid+1;
            else if(a[mid]&lt;a[end]) end=mid;
            else end--;
        }
        return a[start];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 154. Find Minimum in Rotated Sorted Array II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Suppose an array of length
   <code>
    n
   </code>
   sorted in ascending order is
   <strong>
    rotated
   </strong>
   between
   <code>
    1
   </code>
   and
   <code>
    n
   </code>
   times. For example, the array
   <code>
    nums = [0,1,4,4,5,6,7]
   </code>
   might become:
  </p>
  <ul>
   <li>
    <code>
     [4,5,6,7,0,1,4]
    </code>
    if it was rotated
    <code>
     4
    </code>
    times.
   </li>
   <li>
    <code>
     [0,1,4,4,5,6,7]
    </code>
    if it was rotated
    <code>
     7
    </code>
    times.
   </li>
  </ul>
  <p>
   Notice that
   <strong>
    rotating
   </strong>
   an array
   <code>
    [a[0], a[1], a[2], ..., a[n-1]]
   </code>
   1 time results in the array
   <code>
    [a[n-1], a[0], a[1], a[2], ..., a[n-2]]
   </code>
   .
  </p>
  <p>
   Given the sorted rotated array
   <code>
    nums
   </code>
   that may contain
   <strong>
    duplicates
   </strong>
   , return
   <em>
    the minimum element of this array
   </em>
   .
  </p>
  <p>
   You must decrease the overall operation steps as much as possible.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,3,5]
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,2,2,0,1]
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == nums.length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 5000
    </code>
   </li>
   <li>
    <code>
     -5000 &lt;= nums[i] &lt;= 5000
    </code>
   </li>
   <li>
    <code>
     nums
    </code>
    is sorted and rotated between
    <code>
     1
    </code>
    and
    <code>
     n
    </code>
    times.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   This problem is similar to
   <a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank">
    Find Minimum in Rotated Sorted Array
   </a>
   , but
   <code>
    nums
   </code>
   may contain
   <strong>
    duplicates
   </strong>
   . Would this affect the runtime complexity? How and why?
  </p>
  <p>
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 154 -->
<pre>/*
 * @lc app=leetcode id=154 lang=cpp
 *
 * [154] Find Minimum in Rotated Sorted Array II
 */

// @lc code=start
class Solution {
public:
    int findMin(vector&lt;int&gt;&amp; a) {
        int start = 0,end=a.size()-1;
        while (start &lt; end){
            int mid=(start+end)/2;
            if(a[mid]&gt;a[end]) start = mid+1;
            else if (a[mid]&lt;a[end]) end=mid;
            else end--;
        }
        return a[start];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 155. Min Stack
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
  </p>
  <p>
   Implement the
   <code>
    MinStack
   </code>
   class:
  </p>
  <ul>
   <li>
    <code>
     MinStack()
    </code>
    initializes the stack object.
   </li>
   <li>
    <code>
     void push(val)
    </code>
    pushes the element
    <code>
     val
    </code>
    onto the stack.
   </li>
   <li>
    <code>
     void pop()
    </code>
    removes the element on the top of the stack.
   </li>
   <li>
    <code>
     int top()
    </code>
    gets the top element of the stack.
   </li>
   <li>
    <code>
     int getMin()
    </code>
    retrieves the minimum element in the stack.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input</strong>
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

<strong>Output</strong>
[null,null,null,null,-3,null,0,-2]

<strong>Explanation</strong>
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); // return -3
minStack.pop();
minStack.top();    // return 0
minStack.getMin(); // return -2
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= val &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
   <li>
    Methods
    <code>
     pop
    </code>
    ,
    <code>
     top
    </code>
    and
    <code>
     getMin
    </code>
    operations will always be called on
    <strong>
     non-empty
    </strong>
    stacks.
   </li>
   <li>
    At most
    <code>
     3 * 10
     <sup>
      4
     </sup>
    </code>
    calls will be made to
    <code>
     push
    </code>
    ,
    <code>
     pop
    </code>
    ,
    <code>
     top
    </code>
    , and
    <code>
     getMin
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 155 -->
<pre>/*
 * @lc app=leetcode id=155 lang=cpp
 *
 * [155] Min Stack
 */

// @lc code=start
class MinStack {
public:
    stack&lt;int&gt;s1;
    stack&lt;int&gt;s2;
    MinStack() {

    }

    void push(int val) {
        s1.push(val);
        if(s2.empty() || val&lt;=getMin()) s2.push(val);
    }

    void pop() {
        if(s1.top()==getMin()) s2.pop();
        s1.pop();
    }

    int top() {
        return s1.top();
    }

    int getMin() {
        return s2.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj-&gt;push(val);
 * obj-&gt;pop();
 * int param_3 = obj-&gt;top();
 * int param_4 = obj-&gt;getMin();
 */
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 160. Intersection of Two Linked Lists
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the heads of two singly linked-lists
   <code>
    headA
   </code>
   and
   <code>
    headB
   </code>
   , return
   <em>
    the node at which the two lists intersect
   </em>
   . If the two linked lists have no intersection at all, return
   <code>
    null
   </code>
   .
  </p>
  <p>
   For example, the following two linked lists begin to intersect at node
   <code>
    c1
   </code>
   :
  </p>
  <img alt="" src="./output_files/160_statement.png" style="width: 500px; height: 162px;"/>
  <p>
   The test cases are generated such that there are no cycles anywhere in the entire linked structure.
  </p>
  <p>
   <strong>
    Note
   </strong>
   that the linked lists must
   <strong>
    retain their original structure
   </strong>
   after the function returns.
  </p>
  <p>
   <strong>
    Custom Judge:
   </strong>
  </p>
  <p>
   The inputs to the
   <strong>
    judge
   </strong>
   are given as follows (your program is
   <strong>
    not
   </strong>
   given these inputs):
  </p>
  <ul>
   <li>
    <code>
     intersectVal
    </code>
    - The value of the node where the intersection occurs. This is
    <code>
     0
    </code>
    if there is no intersected node.
   </li>
   <li>
    <code>
     listA
    </code>
    - The first linked list.
   </li>
   <li>
    <code>
     listB
    </code>
    - The second linked list.
   </li>
   <li>
    <code>
     skipA
    </code>
    - The number of nodes to skip ahead in
    <code>
     listA
    </code>
    (starting from the head) to get to the intersected node.
   </li>
   <li>
    <code>
     skipB
    </code>
    - The number of nodes to skip ahead in
    <code>
     listB
    </code>
    (starting from the head) to get to the intersected node.
   </li>
  </ul>
  <p>
   The judge will then create the linked structure based on these inputs and pass the two heads,
   <code>
    headA
   </code>
   and
   <code>
    headB
   </code>
   to your program. If you correctly return the intersected node, then your solution will be
   <strong>
    accepted
   </strong>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/160_example_1_1.png" style="width: 500px; height: 162px;"/>
  <pre><strong>Input:</strong> intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
<strong>Output:</strong> Intersected at '8'
<strong>Explanation:</strong> The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).
From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/160_example_2.png" style="width: 500px; height: 194px;"/>
  <pre><strong>Input:</strong> intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
<strong>Output:</strong> Intersected at '2'
<strong>Explanation:</strong> The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).
From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <img alt="" src="./output_files/160_example_3.png" style="width: 300px; height: 189px;"/>
  <pre><strong>Input:</strong> intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
<strong>Output:</strong> No intersection
<strong>Explanation:</strong> From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.
Explanation: The two lists do not intersect, so return null.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes of
    <code>
     listA
    </code>
    is in the
    <code>
     m
    </code>
    .
   </li>
   <li>
    The number of nodes of
    <code>
     listB
    </code>
    is in the
    <code>
     n
    </code>
    .
   </li>
   <li>
    <code>
     0 &lt;= m, n &lt;= 3 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     1 &lt;= Node.val &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= skipA &lt;= m
    </code>
   </li>
   <li>
    <code>
     0 &lt;= skipB &lt;= n
    </code>
   </li>
   <li>
    <code>
     intersectVal
    </code>
    is
    <code>
     0
    </code>
    if
    <code>
     listA
    </code>
    and
    <code>
     listB
    </code>
    do not intersect.
   </li>
   <li>
    <code>
     intersectVal == listA[skipA] == listB[skipB]
    </code>
    if
    <code>
     listA
    </code>
    and
    <code>
     listB
    </code>
    intersect.
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow up:
  </strong>
  Could you write a solution that runs in
  <code>
   O(n)
  </code>
  time and use only
  <code>
   O(1)
  </code>
  memory?
 </div>
</div>
</body></html>
<!-- Solution for Question 160 -->
<pre>/*
 * @lc app=leetcode id=160 lang=cpp
 *
 * [160] Intersection of Two Linked Lists
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(headA==NULL || headB==NULL) return NULL;
        if(headA==headB) return headA;
        ListNode * ans1=headA;
        while(ans1!=NULL){
        ListNode * ans2=headB;
            while(ans2!=NULL){
                if(ans1==ans2) return ans1;
                ans2=ans2-&gt;next;
            }
            ans1=ans1-&gt;next;
        }
        return NULL;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 162. Find Peak Element
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   A peak element is an element that is strictly greater than its neighbors.
  </p>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   , find a peak element, and return its index. If the array contains multiple peaks, return the index to
   <strong>
    any of the peaks
   </strong>
   .
  </p>
  <p>
   You may imagine that
   <code>
    nums[-1] = nums[n] = -∞
   </code>
   .
  </p>
  <p>
   You must write an algorithm that runs in
   <code>
    O(log n)
   </code>
   time.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3,1]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 3 is a peak element and your function should return the index number 2.</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,1,3,5,6,4]
<strong>Output:</strong> 5
<strong>Explanation:</strong> Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= nums[i] &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
   <li>
    <code>
     nums[i] != nums[i + 1]
    </code>
    for all valid
    <code>
     i
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 162 -->
<pre>/*
 * @lc app=leetcode id=162 lang=cpp
 *
 * [162] Find Peak Element
 */

// @lc code=start
class Solution {
public:
    int findPeakElement(vector&lt;int&gt;&amp; a) {
        int start=0,end=a.size()-1;
        while(start&lt;end-1) {
            int mid=(start+end)/2;
            if(a[mid]&gt;a[mid+1]  &amp;&amp; a[mid]&gt;a[mid-1]) return mid;
            else if(a[mid]&gt;a[mid+1]) end=mid-1;
            else start=mid+1;
        }
        return a[start] &gt; a[end] ? start : end;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 165. Compare Version Numbers
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two version numbers,
   <code>
    version1
   </code>
   and
   <code>
    version2
   </code>
   , compare them.
  </p>
  <ul>
  </ul>
  <p>
   Version numbers consist of
   <strong>
    one or more revisions
   </strong>
   joined by a dot
   <code>
    '.'
   </code>
   . Each revision consists of
   <strong>
    digits
   </strong>
   and may contain leading
   <strong>
    zeros
   </strong>
   . Every revision contains
   <strong>
    at least one character
   </strong>
   . Revisions are
   <strong>
    0-indexed from left to right
   </strong>
   , with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example
   <code>
    2.5.33
   </code>
   and
   <code>
    0.1
   </code>
   are valid version numbers.
  </p>
  <p>
   To compare version numbers, compare their revisions in
   <strong>
    left-to-right order
   </strong>
   . Revisions are compared using their
   <strong>
    integer value ignoring any leading zeros
   </strong>
   . This means that revisions
   <code>
    1
   </code>
   and
   <code>
    001
   </code>
   are considered
   <strong>
    equal
   </strong>
   . If a version number does not specify a revision at an index, then
   <strong>
    treat the revision as
    <code>
     0
    </code>
   </strong>
   . For example, version
   <code>
    1.0
   </code>
   is less than version
   <code>
    1.1
   </code>
   because their revision 0s are the same, but their revision 1s are
   <code>
    0
   </code>
   and
   <code>
    1
   </code>
   respectively, and
   <code>
    0 &lt; 1
   </code>
   .
  </p>
  <p>
   <em>
    Return the following:
   </em>
  </p>
  <ul>
   <li>
    If
    <code>
     version1 &lt; version2
    </code>
    , return
    <code>
     -1
    </code>
    .
   </li>
   <li>
    If
    <code>
     version1 &gt; version2
    </code>
    , return
    <code>
     1
    </code>
    .
   </li>
   <li>
    Otherwise, return
    <code>
     0
    </code>
    .
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> version1 = "1.01", version2 = "1.001"
<strong>Output:</strong> 0
<strong>Explanation:</strong> Ignoring leading zeroes, both "01" and "001" represent the same integer "1".
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> version1 = "1.0", version2 = "1.0.0"
<strong>Output:</strong> 0
<strong>Explanation:</strong> version1 does not specify revision 2, which means it is treated as "0".
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> version1 = "0.1", version2 = "1.1"
<strong>Output:</strong> -1
<strong>Explanation:</strong> version1's revision 0 is "0", while version2's revision 0 is "1". 0 &lt; 1, so version1 &lt; version2.
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> version1 = "1.0.1", version2 = "1"
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> version1 = "7.5.2.4", version2 = "7.5.3"
<strong>Output:</strong> -1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= version1.length, version2.length &lt;= 500
    </code>
   </li>
   <li>
    <code>
     version1
    </code>
    and
    <code>
     version2
    </code>
    only contain digits and
    <code>
     '.'
    </code>
    .
   </li>
   <li>
    <code>
     version1
    </code>
    and
    <code>
     version2
    </code>
    <strong>
     are valid version numbers
    </strong>
    .
   </li>
   <li>
    All the given revisions in
    <code>
     version1
    </code>
    and
    <code>
     version2
    </code>
    can be stored in a
    <strong>
     32-bit integer
    </strong>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 165 -->
<pre>/*
 * @lc app=leetcode id=165 lang=cpp
 *
 * [165] Compare Version Numbers
 */

// @lc code=start
class Solution {
public:
    int compareVersion(string version1, string version2) {
        queue&lt;int&gt;s1;
        queue&lt;int&gt;s2;
        string s=&quot;&quot;;
        version1+=&#x27;.&#x27;;
        version2+=&#x27;.&#x27;;
        for(int i = 0; i &lt;version1.size(); i++){
            if(version1[i]==&#x27;.&#x27;){
                s1.push(stoi(s));
                cout&lt;&lt;s&lt;&lt;endl;
                s=&quot;&quot;;
            }
            else{
                s=s+version1[i];
            }
        }
        s=&quot;&quot;;
        for(int i = 0; i &lt;version2.size(); i++){
            if(version2[i]==&#x27;.&#x27;){
                s2.push(stoi(s));
                cout&lt;&lt;s&lt;&lt;endl;
                s=&quot;&quot;;
            }
            else{
                s=s+version2[i];
            }
        }
        while(!s1.empty() &amp;&amp; !s2.empty()){
            cout&lt;&lt;s1.front()&lt;&lt;s2.front()&lt;&lt;endl;
            if(s1.front()&gt;s2.front()) return 1;
            else if(s1.front()&lt;s2.front()) return -1;
            s1.pop();
            s2.pop();
        }
        cout&lt;&lt;&#x27;h&#x27;;
        while(!s1.empty()){
            if(s1.front()&gt;0) return 1;
            s1.pop();
        }
        while(!s2.empty()){
            if(s2.front()&gt;0) return -1;
            s2.pop();
        }
        return 0;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 166. Fraction to Recurring Decimal
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two integers representing the
   <code>
    numerator
   </code>
   and
   <code>
    denominator
   </code>
   of a fraction, return
   <em>
    the fraction in string format
   </em>
   .
  </p>
  <p>
   If the fractional part is repeating, enclose the repeating part in parentheses.
  </p>
  <p>
   If multiple answers are possible, return
   <strong>
    any of them
   </strong>
   .
  </p>
  <p>
   It is
   <strong>
    guaranteed
   </strong>
   that the length of the answer string is less than
   <code>
    10
    <sup>
     4
    </sup>
   </code>
   for all the given inputs.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> numerator = 1, denominator = 2
<strong>Output:</strong> "0.5"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> numerator = 2, denominator = 1
<strong>Output:</strong> "2"
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> numerator = 2, denominator = 3
<strong>Output:</strong> "0.(6)"
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> numerator = 4, denominator = 333
<strong>Output:</strong> "0.(012)"
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> numerator = 1, denominator = 5
<strong>Output:</strong> "0.2"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= numerator, denominator &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
   <li>
    <code>
     denominator != 0
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 166 -->
<pre>/*
 * @lc app=leetcode id=166 lang=cpp
 *
 * [166] Fraction to Recurring Decimal
 */

// @lc code=start
class Solution {
public:
    string fractionToDecimal(int numerator, int denominator) {
        return to_string((double)numerator/(double)denominator);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 167. Two Sum II - Input array is sorted
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of integers
   <code>
    numbers
   </code>
   that is already
   <strong>
    <em>
     sorted in non-decreasing order
    </em>
   </strong>
   , find two numbers such that they add up to a specific
   <code>
    target
   </code>
   number.
  </p>
  <p>
   Return
   <em>
    the indices of the two numbers (
    <strong>
     1-indexed
    </strong>
    ) as an integer array
   </em>
   <code>
    answer
   </code>
   <em>
    of size
   </em>
   <code>
    2
   </code>
   <em>
    , where
   </em>
   <code>
    1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length
   </code>
   .
  </p>
  <p>
   The tests are generated such that there is
   <strong>
    exactly one solution
   </strong>
   . You
   <strong>
    may not
   </strong>
   use the same element twice.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> numbers = [2,7,11,15], target = 9
<strong>Output:</strong> [1,2]
<strong>Explanation:</strong> The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> numbers = [2,3,4], target = 6
<strong>Output:</strong> [1,3]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> numbers = [-1,0], target = -1
<strong>Output:</strong> [1,2]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     2 &lt;= numbers.length &lt;= 3 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -1000 &lt;= numbers[i] &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     numbers
    </code>
    is sorted in
    <strong>
     non-decreasing order
    </strong>
    .
   </li>
   <li>
    <code>
     -1000 &lt;= target &lt;= 1000
    </code>
   </li>
   <li>
    The tests are generated such that there is
    <strong>
     exactly one solution
    </strong>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 167 -->
<pre>/*
 * @lc app=leetcode id=167 lang=cpp
 *
 * [167] Two Sum II - Input Array Is Sorted
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        map&lt;int,int&gt;m;
        for(int i=0; i&lt;nums.size();i++){
            if(m.find(target-nums[i])==m.end()){
                m[nums[i]]=i;
            }
            else{
                return {m[target-nums[i]]+1,i+1};
            }
        }
        return {-1,-1};
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 168. Excel Sheet Column Title
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer
   <code>
    columnNumber
   </code>
   , return
   <em>
    its corresponding column title as it appears in an Excel sheet
   </em>
   .
  </p>
  <p>
   For example:
  </p>
  <pre>A -&gt; 1
B -&gt; 2
C -&gt; 3
...
Z -&gt; 26
AA -&gt; 27
AB -&gt; 28 
...
</pre>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> columnNumber = 1
<strong>Output:</strong> "A"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> columnNumber = 28
<strong>Output:</strong> "AB"
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> columnNumber = 701
<strong>Output:</strong> "ZY"
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> columnNumber = 2147483647
<strong>Output:</strong> "FXSHRXW"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= columnNumber &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 168 -->
<pre>/*
 * @lc app=leetcode id=168 lang=cpp
 *
 * [168] Excel Sheet Column Title
 */

// @lc code=start
class Solution {
public:
    string convertToTitle(int columnNumber) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 169. Majority Element
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array
   <code>
    nums
   </code>
   of size
   <code>
    n
   </code>
   , return
   <em>
    the majority element
   </em>
   .
  </p>
  <p>
   The majority element is the element that appears more than
   <code>
    ⌊n / 2⌋
   </code>
   times. You may assume that the majority element always exists in the array.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,2,3]
<strong>Output:</strong> 3
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,2,1,1,1,2,2]
<strong>Output:</strong> 2
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == nums.length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 5 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= nums[i] &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow-up:
  </strong>
  Could you solve the problem in linear time and in
  <code>
   O(1)
  </code>
  space?
 </div>
</div>
</body></html>
<!-- Solution for Question 169 -->
<pre>/*
 * @lc app=leetcode id=169 lang=cpp
 *
 * [169] Majority Element
 */

// @lc code=start
class Solution {
public:
    int majorityElement(vector&lt;int&gt;&amp; nums) {
        map&lt;int,int&gt;m;
        int max=INT_MIN,max_ele=INT_MIN;
        for(int i=0;i&lt;nums.size();i++){
            m[nums[i]]++;
            if(m[nums[i]]&gt;max){
                max=m[nums[i]];
                max_ele=nums[i];
            }
        }
        return max_ele;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 172. Factorial Trailing Zeroes
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer
   <code>
    n
   </code>
   , return
   <em>
    the number of trailing zeroes in
    <code>
     n!
    </code>
   </em>
   .
  </p>
  <p>
   <b>
    Follow up:
   </b>
   Could you write a solution that works in logarithmic time complexity?
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 3
<strong>Output:</strong> 0
<strong>Explanation:</strong> 3! = 6, no trailing zero.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 5
<strong>Output:</strong> 1
<strong>Explanation:</strong> 5! = 120, one trailing zero.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 0
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= n &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 172 -->
<pre>/*
 * @lc app=leetcode id=172 lang=cpp
 *
 * [172] Factorial Trailing Zeroes
 */

// @lc code=start
class Solution {
public:
    int trailingZeroes(int n) {
        if (n &lt; 5) return 0;
        return n/5 + trailingZeroes(n/5);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 173. Binary Search Tree Iterator
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Implement the
   <code>
    BSTIterator
   </code>
   class that represents an iterator over the
   <strong>
    <a href="https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)" target="_blank">
     in-order traversal
    </a>
   </strong>
   of a binary search tree (BST):
  </p>
  <ul>
   <li>
    <code>
     BSTIterator(TreeNode root)
    </code>
    Initializes an object of the
    <code>
     BSTIterator
    </code>
    class. The
    <code>
     root
    </code>
    of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.
   </li>
   <li>
    <code>
     boolean hasNext()
    </code>
    Returns
    <code>
     true
    </code>
    if there exists a number in the traversal to the right of the pointer, otherwise returns
    <code>
     false
    </code>
    .
   </li>
   <li>
    <code>
     int next()
    </code>
    Moves the pointer to the right, then returns the number at the pointer.
   </li>
  </ul>
  <p>
   Notice that by initializing the pointer to a non-existent smallest number, the first call to
   <code>
    next()
   </code>
   will return the smallest element in the BST.
  </p>
  <p>
   You may assume that
   <code>
    next()
   </code>
   calls will always be valid. That is, there will be at least a next number in the in-order traversal when
   <code>
    next()
   </code>
   is called.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/bst-tree.png" style="width: 189px; height: 178px;"/>
  <pre><strong>Input</strong>
["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
<strong>Output</strong>
[null, 3, 7, true, 9, true, 15, true, 20, false]

<strong>Explanation</strong>
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // return 3
bSTIterator.next();    // return 7
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 9
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 15
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 20
bSTIterator.hasNext(); // return False
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [1, 10
     <sup>
      5
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     0 &lt;= Node.val &lt;= 10
     <sup>
      6
     </sup>
    </code>
   </li>
   <li>
    At most
    <code>
     10
     <sup>
      5
     </sup>
    </code>
    calls will be made to
    <code>
     hasNext
    </code>
    , and
    <code>
     next
    </code>
    .
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
  </p>
  <ul>
   <li>
    Could you implement
    <code>
     next()
    </code>
    and
    <code>
     hasNext()
    </code>
    to run in average
    <code>
     O(1)
    </code>
    time and use
    <code>
     O(h)
    </code>
    memory, where
    <code>
     h
    </code>
    is the height of the tree?
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 173 -->
<pre>/*
 * @lc app=leetcode id=173 lang=cpp
 *
 * [173] Binary Search Tree Iterator
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class BSTIterator {
public:
    vector&lt;int&gt;a;
    int index=0;
    BSTIterator(TreeNode* root) {
        inorder(root);
    }
    void inorder(TreeNode* root){
        if(root){
            inorder(root-&gt;left);
            a.push_back(root-&gt;val);
            inorder(root-&gt;right);
        }
    }
    int next() {
        return a[index++];
    }

    bool hasNext() {
        if(index&lt;a.size()){
            return true;
        }
        return false;
    }
};

/**
 * Your BSTIterator object will be instantiated and called as such:
 * BSTIterator* obj = new BSTIterator(root);
 * int param_1 = obj-&gt;next();
 * bool param_2 = obj-&gt;hasNext();
 */
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 174. Dungeon Game
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   The demons had captured the princess and imprisoned her in
   <strong>
    the bottom-right corner
   </strong>
   of a
   <code>
    dungeon
   </code>
   . The
   <code>
    dungeon
   </code>
   consists of
   <code>
    m x n
   </code>
   rooms laid out in a 2D grid. Our valiant knight was initially positioned in
   <strong>
    the top-left room
   </strong>
   and must fight his way through
   <code>
    dungeon
   </code>
   to rescue the princess.
  </p>
  <p>
   The knight has an initial health point represented by a positive integer. If at any point his health point drops to
   <code>
    0
   </code>
   or below, he dies immediately.
  </p>
  <p>
   Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).
  </p>
  <p>
   To reach the princess as quickly as possible, the knight decides to move only
   <strong>
    rightward
   </strong>
   or
   <strong>
    downward
   </strong>
   in each step.
  </p>
  <p>
   Return
   <em>
    the knight's minimum initial health so that he can rescue the princess
   </em>
   .
  </p>
  <p>
   <strong>
    Note
   </strong>
   that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/dungeon-grid-1.jpg" style="width: 253px; height: 253px;"/>
  <pre><strong>Input:</strong> dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]
<strong>Output:</strong> 7
<strong>Explanation:</strong> The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-&gt; RIGHT -&gt; DOWN -&gt; DOWN.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> dungeon = [[0]]
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == dungeon.length
    </code>
   </li>
   <li>
    <code>
     n == dungeon[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m, n &lt;= 200
    </code>
   </li>
   <li>
    <code>
     -1000 &lt;= dungeon[i][j] &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 174 -->
<pre>/*
 * @lc app=leetcode id=174 lang=cpp
 *
 * [174] Dungeon Game
 */

// @lc code=start
class Solution {
public:
    int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; a) {
        int m=a.size(),n=a[0].size();
        a[m-1][n-1] = a[m-1][n-1]&gt;0?1:1-a[m-1][n-1];
        int i,j;
        j=n-1;
        for(int i=m-2;i&gt;=0;i--){
           a[i][j]=a[i+1][j]-a[i][j];
           if(a[i][j]&lt;=0) a[i][j]=1;
        }
        i=m-1;
        for(int j=n-2;j&gt;=0;j--){
            a[i][j]=a[i][j+1]-a[i][j];
            if(a[i][j]&lt;=0) a[i][j]=1;
        }
        for(int i=m-2;i&gt;=0;i--){
            for(int j=n-2;j&gt;=0;j--){
                a[i][j]=min(a[i][j+1],a[i+1][j])-a[i][j];
                if(a[i][j]&lt;=0) a[i][j]=1;
            }
        }

        for(int i=0;i&lt;m;i++){
            for(int j=0;j&lt;n;j++){
                cout&lt;&lt;a[i][j]&lt;&lt;&#x27; &#x27;;
            }
            cout&lt;&lt;&#x27;\n&#x27;;
        }

        return a[0][0];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 179. Largest Number
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a list of non-negative integers
   <code>
    nums
   </code>
   , arrange them such that they form the largest number.
  </p>
  <p>
   <strong>
    Note:
   </strong>
   The result may be very large, so you need to return a string instead of an integer.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [10,2]
<strong>Output:</strong> "210"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,30,34,5,9]
<strong>Output:</strong> "9534330"
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1]
<strong>Output:</strong> "1"
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [10]
<strong>Output:</strong> "10"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     0 &lt;= nums[i] &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 179 -->
<pre>/*
 * @lc app=leetcode id=179 lang=cpp
 *
 * [179] Largest Number
 */

// @lc code=start

    bool compare(string a,string b){
        return a+b &gt; b+a;
    }
class Solution {
public:
    string largestNumber(vector&lt;int&gt;&amp; nums) {
        vector&lt;string&gt;s;
        for(int x:nums){
            s.push_back(to_string(x));
        }
        sort(s.begin(), s.end(),compare);
        string ans=&quot;&quot;;
        for(int i=0; i&lt;s.size(); i++){
            ans+=s[i];
        }
        return ans[0]==&#x27;0&#x27;?&quot;0&quot;:ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
872. Leaf-Similar Trees<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a
   <strong>
    leaf value sequence
   </strong>
   <em>
    .
   </em>
  </p>
  <p>
   <img alt="" src="./output_files/tree.png" style="width: 400px; height: 336px;"/>
  </p>
  <p>
   For example, in the given tree above, the leaf value sequence is
   <code>
    (6, 7, 4, 9, 8)
   </code>
   .
  </p>
  <p>
   Two binary trees are considered
   <em>
    leaf-similar
   </em>
   if their leaf value sequence is the same.
  </p>
  <p>
   Return
   <code>
    true
   </code>
   if and only if the two given trees with head nodes
   <code>
    root1
   </code>
   and
   <code>
    root2
   </code>
   are leaf-similar.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/leaf-similar-1.jpg" style="width: 750px; height: 297px;"/>
  <pre><strong>Input:</strong> root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root1 = [1], root2 = [1]
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root1 = [1], root2 = [2]
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> root1 = [1,2], root2 = [2,2]
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <img alt="" src="./output_files/leaf-similar-2.jpg" style="width: 450px; height: 165px;"/>
  <pre><strong>Input:</strong> root1 = [1,2,3], root2 = [1,3,2]
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in each tree will be in the range
    <code>
     [1, 200]
    </code>
    .
   </li>
   <li>
    Both of the given trees will have values in the range
    <code>
     [0, 200]
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 181 -->
<pre>select e1.name as Employee  from Employee e1
inner join Employee e2
on e1.managerId=e2.id
where e1.salary&gt;e2.salary
</pre><html><head></head><body>
874. Walking Robot Simulation<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   A robot on an infinite XY-plane starts at point
   <code>
    (0, 0)
   </code>
   and faces north. The robot can receive one of three possible types of
   <code>
    commands
   </code>
   :
  </p>
  <ul>
   <li>
    <code>
     -2
    </code>
    : turn left
    <code>
     90
    </code>
    degrees,
   </li>
   <li>
    <code>
     -1
    </code>
    : turn right
    <code>
     90
    </code>
    degrees, or
   </li>
   <li>
    <code>
     1 &lt;= k &lt;= 9
    </code>
    : move forward
    <code>
     k
    </code>
    units.
   </li>
  </ul>
  <p>
   Some of the grid squares are
   <code>
    obstacles
   </code>
   . The
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   obstacle is at grid point
   <code>
    obstacles[i] = (x
    <sub>
     i
    </sub>
    , y
    <sub>
     i
    </sub>
    )
   </code>
   .
  </p>
  <p>
   If the robot would try to move onto them, the robot stays on the previous grid square instead (but still continues following the rest of the route.)
  </p>
  <p>
   Return
   <em>
    the maximum Euclidean distance that the robot will be from the origin
    <strong>
     squared
    </strong>
    (i.e. if the distance is
   </em>
   <code>
    5
   </code>
   <em>
    , return
   </em>
   <code>
    25
   </code>
   <em>
    )
   </em>
   .
  </p>
  <p>
   <strong>
    Note:
   </strong>
  </p>
  <ul>
   <li>
    North means +Y direction.
   </li>
   <li>
    East means +X direction.
   </li>
   <li>
    South means -Y direction.
   </li>
   <li>
    West means -X direction.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> commands = [4,-1,3], obstacles = []
<strong>Output:</strong> 25
<strong>Explanation:</strong> The robot starts at (0, 0):
1. Move north 4 units to (0, 4).
2. Turn right.
3. Move east 3 units to (3, 4).
The furthest point away from the origin is (3, 4), which is 3<sup>2</sup> + 4<sup>2</sup> = 25 units away.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> commands = [4,-1,4,-2,4], obstacles = [[2,4]]
<strong>Output:</strong> 65
<strong>Explanation:</strong> The robot starts at (0, 0):
1. Move north 4 units to (0, 4).
2. Turn right.
3. Move east 1 unit and get blocked by the obstacle at (2, 4), robot is at (1, 4).
4. Turn left.
5. Move north 4 units to (1, 8).
The furthest point away from the origin is (1, 8), which is 1<sup>2</sup> + 8<sup>2</sup> = 65 units away.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= commands.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     commands[i]
    </code>
    is one of the values in the list
    <code>
     [-2,-1,1,2,3,4,5,6,7,8,9]
    </code>
    .
   </li>
   <li>
    <code>
     0 &lt;= obstacles.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -3 * 10
     <sup>
      4
     </sup>
     &lt;= x
     <sub>
      i
     </sub>
     , y
     <sub>
      i
     </sub>
     &lt;= 3 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    The answer is guaranteed to be less than
    <code>
     2
     <sup>
      31
     </sup>
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 182 -->
<pre></pre><html><head></head><body>
<div id="title">
 188. Best Time to Buy and Sell Stock IV
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an integer array
   <code>
    prices
   </code>
   where
   <code>
    prices[i]
   </code>
   is the price of a given stock on the
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   day, and an integer
   <code>
    k
   </code>
   .
  </p>
  <p>
   Find the maximum profit you can achieve. You may complete at most
   <code>
    k
   </code>
   transactions.
  </p>
  <p>
   <strong>
    Note:
   </strong>
   You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> k = 2, prices = [2,4,1]
<strong>Output:</strong> 2
<strong>Explanation:</strong> Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> k = 2, prices = [3,2,6,5,0,3]
<strong>Output:</strong> 7
<strong>Explanation:</strong> Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= k &lt;= 100
    </code>
   </li>
   <li>
    <code>
     0 &lt;= prices.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     0 &lt;= prices[i] &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 188 -->
<pre>/*
 * @lc app=leetcode id=188 lang=cpp
 *
 * [188] Best Time to Buy and Sell Stock IV
 */

// @lc code=start
class Solution {
public:
    int find(vector&lt;int&gt;&amp;prices,int i,int state,vector&lt;vector&lt;int&gt;&gt;&amp;dp,int k)
    {
        if(i&gt;=prices.size() || state&gt;=2*k) return 0;
        if(dp[i][state]!=-1) return dp[i][state];
        if(state%2==0)
        {
            return dp[i][state] = max(-prices[i]+find(prices,i+1,state+1,dp,k),find(prices,i+1,state,dp,k));
        }
        else
        {
            return dp[i][state] = max(prices[i]+find(prices,i+1,state+1,dp,k),find(prices,i+1,state,dp,k));
        }
    }
    int maxProfit(int k, vector&lt;int&gt;&amp; prices) {
        int n=prices.size();
        vector&lt;vector&lt;int&gt;&gt;dp(n,vector&lt;int&gt;(2*k,-1));
        return find(prices,0,0,dp,k);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 189. Rotate Array
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array, rotate the array to the right by
   <code>
    k
   </code>
   steps, where
   <code>
    k
   </code>
   is non-negative.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3,4,5,6,7], k = 3
<strong>Output:</strong> [5,6,7,1,2,3,4]
<strong>Explanation:</strong>
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [-1,-100,3,99], k = 2
<strong>Output:</strong> [3,99,-1,-100]
<strong>Explanation:</strong> 
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= nums[i] &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
   <li>
    <code>
     0 &lt;= k &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
  </p>
  <ul>
   <li>
    Try to come up with as many solutions as you can. There are at least
    <strong>
     three
    </strong>
    different ways to solve this problem.
   </li>
   <li>
    Could you do it in-place with
    <code>
     O(1)
    </code>
    extra space?
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 189 -->
<pre>/*
 * @lc app=leetcode id=189 lang=cpp
 *
 * [189] Rotate Array
 */

// @lc code=start
class Solution {
public:
    void rotate(vector&lt;int&gt;&amp; a, int k) {
        k=k%a.size();
        reverse(a.begin(), a.end());
        reverse(a.begin(), a.begin()+k);
        reverse(a.begin()+k, a.end());
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 190. Reverse Bits
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Reverse bits of a given 32 bits unsigned integer.
  </p>
  <p>
   <strong>
    Note:
   </strong>
  </p>
  <ul>
   <li>
    Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
   </li>
   <li>
    In Java, the compiler represents the signed integers using
    <a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank">
     2's complement notation
    </a>
    . Therefore, in
    <strong>
     Example 2
    </strong>
    above, the input represents the signed integer
    <code>
     -3
    </code>
    and the output represents the signed integer
    <code>
     -1073741825
    </code>
    .
   </li>
  </ul>
  <p>
   <b>
    Follow up
   </b>
   :
  </p>
  <p>
   If this function is called many times, how would you optimize it?
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 00000010100101000001111010011100
<strong>Output:</strong>    964176192 (00111001011110000010100101000000)
<strong>Explanation: </strong>The input binary string <strong>00000010100101000001111010011100</strong> represents the unsigned integer 43261596, so return 964176192 which its binary representation is <strong>00111001011110000010100101000000</strong>.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 11111111111111111111111111111101
<strong>Output:</strong>   3221225471 (10111111111111111111111111111111)
<strong>Explanation: </strong>The input binary string <strong>11111111111111111111111111111101</strong> represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is <strong>10111111111111111111111111111111</strong>.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The input must be a
    <strong>
     binary string
    </strong>
    of length
    <code>
     32
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 190 -->
<pre>/*
 * @lc app=leetcode id=190 lang=cpp
 *
 * [190] Reverse Bits
 */

// @lc code=start
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t ans=0;
        for(int i=0; i&lt;32; i++){
            ans+=(((n&gt;&gt;i)&amp;1)&lt;&lt;(31-i));
        }
        return ans;
    }
};
// @lc code=end
</pre><html><head></head><body>
<div id="title">
 191. Number of 1 Bits
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the
   <a href="http://en.wikipedia.org/wiki/Hamming_weight" target="_blank">
    Hamming weight
   </a>
   ).
  </p>
  <p>
   <strong>
    Note:
   </strong>
  </p>
  <ul>
   <li>
    Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.
   </li>
   <li>
    In Java, the compiler represents the signed integers using
    <a href="https://en.wikipedia.org/wiki/Two%27s_complement" target="_blank">
     2's complement notation
    </a>
    . Therefore, in
    <strong>
     Example 3
    </strong>
    , the input represents the signed integer.
    <code>
     -3
    </code>
    .
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 00000000000000000000000000001011
<strong>Output:</strong> 3
<strong>Explanation:</strong> The input binary string <strong>00000000000000000000000000001011</strong> has a total of three '1' bits.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 00000000000000000000000010000000
<strong>Output:</strong> 1
<strong>Explanation:</strong> The input binary string <strong>00000000000000000000000010000000</strong> has a total of one '1' bit.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 11111111111111111111111111111101
<strong>Output:</strong> 31
<strong>Explanation:</strong> The input binary string <strong>11111111111111111111111111111101</strong> has a total of thirty one '1' bits.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The input must be a
    <strong>
     binary string
    </strong>
    of length
    <code>
     32
    </code>
    .
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow up:
  </strong>
  If this function is called many times, how would you optimize it?
 </div>
</div>
</body></html>
<!-- Solution for Question 191 -->
<pre>/*
 * @lc app=leetcode id=191 lang=cpp
 *
 * [191] Number of 1 Bits
 */

// @lc code=start
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int ans=0;
        while(n!=0){
            if(n%2==1) ans+=1;
            n=n&gt;&gt;1;
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
914. X of a Kind in a Deck of Cards<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   In a deck of cards, each card has an integer written on it.
  </p>
  <p>
   Return
   <code>
    true
   </code>
   if and only if you can choose
   <code>
    X &gt;= 2
   </code>
   such that it is possible to split the entire deck into 1 or more groups of cards, where:
  </p>
  <ul>
   <li>
    Each group has exactly
    <code>
     X
    </code>
    cards.
   </li>
   <li>
    All the cards in each group have the same integer.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> deck = [1,2,3,4,4,3,2,1]
<strong>Output:</strong> true
<strong>Explanation</strong>: Possible partition [1,1],[2,2],[3,3],[4,4].
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> deck = [1,1,1,2,2,2,3,3]
<strong>Output:</strong> false
<strong>Explanation</strong>: No possible partition.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> deck = [1]
<strong>Output:</strong> false
<strong>Explanation</strong>: No possible partition.
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> deck = [1,1]
<strong>Output:</strong> true
<strong>Explanation</strong>: Possible partition [1,1].
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> deck = [1,1,2,2,2,2]
<strong>Output:</strong> true
<strong>Explanation</strong>: Possible partition [1,1],[2,2],[2,2].
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= deck.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= deck[i] &lt; 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 192 -->
<pre></pre><html><head></head><body>
925. Long Pressed Name<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Your friend is typing his
   <code>
    name
   </code>
   into a keyboard. Sometimes, when typing a character
   <code>
    c
   </code>
   , the key might get
   <em>
    long pressed
   </em>
   , and the character will be typed 1 or more times.
  </p>
  <p>
   You examine the
   <code>
    typed
   </code>
   characters of the keyboard. Return
   <code>
    True
   </code>
   if it is possible that it was your friends name, with some characters (possibly none) being long pressed.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> name = "alex", typed = "aaleex"
<strong>Output:</strong> true
<strong>Explanation: </strong>'a' and 'e' in 'alex' were long pressed.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> name = "saeed", typed = "ssaaedd"
<strong>Output:</strong> false
<strong>Explanation: </strong>'e' must have been pressed twice, but it wasn't in the typed output.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> name = "leelee", typed = "lleeelee"
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> name = "laiden", typed = "laiden"
<strong>Output:</strong> true
<strong>Explanation: </strong>It's not necessary to long press any character.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= name.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     1 &lt;= typed.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     name
    </code>
    and
    <code>
     typed
    </code>
    contain only lowercase English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 195 -->
<pre></pre><html><head></head><body>
929. Unique Email Addresses<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Every
   <strong>
    valid email
   </strong>
   consists of a
   <strong>
    local name
   </strong>
   and a
   <strong>
    domain name
   </strong>
   , separated by the
   <code>
    '@'
   </code>
   sign. Besides lowercase letters, the email may contain one or more
   <code>
    '.'
   </code>
   or
   <code>
    '+'
   </code>
   .
  </p>
  <ul>
   <li>
    For example, in
    <code>
     "alice@leetcode.com"
    </code>
    ,
    <code>
     "alice"
    </code>
    is the
    <strong>
     local name
    </strong>
    , and
    <code>
     "leetcode.com"
    </code>
    is the
    <strong>
     domain name
    </strong>
    .
   </li>
  </ul>
  <p>
   If you add periods
   <code>
    '.'
   </code>
   between some characters in the
   <strong>
    local name
   </strong>
   part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule
   <strong>
    does not apply
   </strong>
   to
   <strong>
    domain names
   </strong>
   .
  </p>
  <ul>
   <li>
    For example,
    <code>
     "alice.z@leetcode.com"
    </code>
    and
    <code>
     "alicez@leetcode.com"
    </code>
    forward to the same email address.
   </li>
  </ul>
  <p>
   If you add a plus
   <code>
    '+'
   </code>
   in the
   <strong>
    local name
   </strong>
   , everything after the first plus sign
   <strong>
    will be ignored
   </strong>
   . This allows certain emails to be filtered. Note that this rule
   <strong>
    does not apply
   </strong>
   to
   <strong>
    domain names
   </strong>
   .
  </p>
  <ul>
   <li>
    For example,
    <code>
     "m.y+name@email.com"
    </code>
    will be forwarded to
    <code>
     "my@email.com"
    </code>
    .
   </li>
  </ul>
  <p>
   It is possible to use both of these rules at the same time.
  </p>
  <p>
   Given an array of strings
   <code>
    emails
   </code>
   where we send one email to each
   <code>
    email[i]
   </code>
   , return
   <em>
    the number of different addresses that actually receive mails
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> emails = ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"]
<strong>Output:</strong> 2
<strong>Explanation:</strong> "testemail@leetcode.com" and "testemail@lee.tcode.com" actually receive mails.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> emails = ["a@leetcode.com","b@leetcode.com","c@leetcode.com"]
<strong>Output:</strong> 3
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= emails.length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     1 &lt;= emails[i].length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     email[i]
    </code>
    consist of lowercase English letters,
    <code>
     '+'
    </code>
    ,
    <code>
     '.'
    </code>
    and
    <code>
     '@'
    </code>
    .
   </li>
   <li>
    Each
    <code>
     emails[i]
    </code>
    contains exactly one
    <code>
     '@'
    </code>
    character.
   </li>
   <li>
    All local and domain names are non-empty.
   </li>
   <li>
    Local names do not start with a
    <code>
     '+'
    </code>
    character.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 196 -->
<pre></pre><html><head></head><body>
<div id="title">
 198. House Robber
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and
   <b>
    it will automatically contact the police if two adjacent houses were broken into on the same night
   </b>
   .
  </p>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   representing the amount of money of each house, return
   <em>
    the maximum amount of money you can rob tonight
    <b>
     without alerting the police
    </b>
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,7,9,3,1]
<strong>Output:</strong> 12
<strong>Explanation:</strong> Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     0 &lt;= nums[i] &lt;= 400
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 198 -->
<pre>/*
 * @lc app=leetcode id=198 lang=cpp
 *
 * [198] House Robber
 */

// @lc code=start
class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        int ans=0;
        if(nums.size()==0) return 0;
        if(nums.size()==1) return nums[0];
        vector&lt;int&gt;dp(nums.size(),0);
        dp[0]=nums[0];
        dp[1]=max(nums[0],nums[1]);
        for(int i=2; i&lt;nums.size(); i++)
        {
            dp[i]=max(dp[i-1],dp[i-2]+nums[i]);
        }
        return dp[nums.size()-1];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 199. Binary Tree Right Side View
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree, imagine yourself standing on the
   <strong>
    right side
   </strong>
   of it, return
   <em>
    the values of the nodes you can see ordered from top to bottom
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/tree(1).jpg" style="width: 401px; height: 301px;"/>
  <pre><strong>Input:</strong> root = [1,2,3,null,5,null,4]
<strong>Output:</strong> [1,3,4]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1,null,3]
<strong>Output:</strong> [1,3]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [0, 100]
    </code>
    .
   </li>
   <li>
    <code>
     -100 &lt;= Node.val &lt;= 100
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 199 -->
<pre>/*
 * @lc app=leetcode id=199 lang=cpp
 *
 * [199] Binary Tree Right Side View
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; rightSideView(TreeNode* root) {
        if(root == NULL)
        {
            return {};
        }
        queue&lt;TreeNode *&gt; q;
        vector&lt;int&gt;ans;
        q.push(root);
        ans.push_back(root-&gt;val);
        while(!q.empty()) {
            int count=q.size();
            while(count)
            {
            TreeNode* node = q.front();
            //cout&lt;&lt;node-&gt;val;
            q.pop();
            if(node-&gt;right)
            q.push(node-&gt;right);
            if(node-&gt;left)
            q.push(node-&gt;left);
           //ans.push_back(q.front()-&gt;val);
           count--;
        }
        if(q.front()!=NULL &amp;&amp; !q.empty())
        ans.push_back(q.front()-&gt;val);
        //cout&lt;&lt;&#x27;t&#x27;;
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 200. Number of Islands
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an
   <code>
    m x n
   </code>
   2D binary grid
   <code>
    grid
   </code>
   which represents a map of
   <code>
    '1'
   </code>
   s (land) and
   <code>
    '0'
   </code>
   s (water), return
   <em>
    the number of islands
   </em>
   .
  </p>
  <p>
   An
   <strong>
    island
   </strong>
   is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
<strong>Output:</strong> 3
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == grid.length
    </code>
   </li>
   <li>
    <code>
     n == grid[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m, n &lt;= 300
    </code>
   </li>
   <li>
    <code>
     grid[i][j]
    </code>
    is
    <code>
     '0'
    </code>
    or
    <code>
     '1'
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 200 -->
<pre>/*
 * @lc app=leetcode id=200 lang=cpp
 *
 * [200] Number of Islands
 */

// @lc code=start
class Solution {
public:
    void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid,int x,int y)
    {
        if(x&lt;0 || x&gt;=grid.size() || y&lt;0 || y&gt;=grid[0].size() || grid[x][y]!=&#x27;1&#x27;)
        {
            return ;
        }
        grid[x][y] = &#x27;*&#x27;;
        dfs(grid,x-1,y);
        dfs(grid,x+1,y);
        dfs(grid,x,y-1);
        dfs(grid,x,y+1);
    }
    int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
        int ans =0 ;
        for(int i=0; i&lt;grid.size();i++)
        {
            for(int j=0; j&lt;grid[0].size();j++)
            {
                if(grid[i][j]==&#x27;1&#x27;)
                {
                ans++;
                dfs(grid,i,j);
                }
            }
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 201. Bitwise AND of Numbers Range
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two integers
   <code>
    left
   </code>
   and
   <code>
    right
   </code>
   that represent the range
   <code>
    [left, right]
   </code>
   , return
   <em>
    the bitwise AND of all numbers in this range, inclusive
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> left = 5, right = 7
<strong>Output:</strong> 4
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> left = 0, right = 0
<strong>Output:</strong> 0
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> left = 1, right = 2147483647
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= left &lt;= right &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 201 -->
<pre>/*
 * @lc app=leetcode id=201 lang=cpp
 *
 * [201] Bitwise AND of Numbers Range
 */

// @lc code=start
class Solution {
public:
    int get(int left){
        int quol=0;
        if(left==INT_MAX) quol=31;
        else{
            while(pow(2,quol)&lt;=left){
                quol++;
            }
        }
        return quol;
    }
    int ans=-1;
    int rangeBitwiseAnd(int left, int right) {
        if(left==0) return 0;
        if(left==right) return left;
        int l=get(left);
        int r=get(right);
        if(l==r) return value(left,right);
        return 0;
    }

    int value(int left, int right) {
        if(left==right) return right;
        return left &amp; value(left+1,right);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 202. Happy Number
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Write an algorithm to determine if a number
   <code>
    n
   </code>
   is happy.
  </p>
  <p>
   A
   <strong>
    happy number
   </strong>
   is a number defined by the following process:
  </p>
  <ul>
   <li>
    Starting with any positive integer, replace the number by the sum of the squares of its digits.
   </li>
   <li>
    Repeat the process until the number equals 1 (where it will stay), or it
    <strong>
     loops endlessly in a cycle
    </strong>
    which does not include 1.
   </li>
   <li>
    Those numbers for which this process
    <strong>
     ends in 1
    </strong>
    are happy.
   </li>
  </ul>
  <p>
   Return
   <code>
    true
   </code>
   <em>
    if
   </em>
   <code>
    n
   </code>
   <em>
    is a happy number, and
   </em>
   <code>
    false
   </code>
   <em>
    if not
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 19
<strong>Output:</strong> true
<strong>Explanation:</strong>
1<sup>2</sup> + 9<sup>2</sup> = 82
8<sup>2</sup> + 2<sup>2</sup> = 68
6<sup>2</sup> + 8<sup>2</sup> = 100
1<sup>2</sup> + 0<sup>2</sup> + 0<sup>2</sup> = 1
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 2
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 202 -->
<pre>/*
 * @lc app=leetcode id=202 lang=cpp
 *
 * [202] Happy Number
 */

// @lc code=start
class Solution {
public:
    bool isHappy(int n) {
        set&lt;int&gt;a;
        for(int sum=0;a.find(n)==a.end();n=sum,sum=0){
            a.insert(n);
            while(n&gt;0){
                sum=sum+(n%10)*(n%10);
                n=n/10;
            }
        }
        return a.find(1) != a.end();
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 204. Count Primes
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Count the number of prime numbers less than a non-negative number,
   <code>
    n
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 10
<strong>Output:</strong> 4
<strong>Explanation:</strong> There are 4 prime numbers less than 10, they are 2, 3, 5, 7.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 0
<strong>Output:</strong> 0
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= n &lt;= 5 * 10
     <sup>
      6
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 204 -->
<pre>/*
 * @lc app=leetcode id=204 lang=cpp
 *
 * [204] Count Primes
 */

// @lc code=start
class Solution {
public:
    int countPrimes(int n) {
        if(n&lt;=1) return 0;
        vector&lt;bool&gt;a(n,1);
        a[0]=a[1]=false;
        for(long long i=2; i&lt;n; i++){
            if(a[i]==0) continue;
            for(long long j=i*i; j&lt;n; j=j+i){
                a[j]=false;
            }
        }
        int c=count(a.begin(),a.end(),1);
        return c;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 205. Isomorphic Strings
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two strings
   <code>
    s
   </code>
   and
   <code>
    t
   </code>
   ,
   <em>
    determine if they are isomorphic
   </em>
   .
  </p>
  <p>
   Two strings
   <code>
    s
   </code>
   and
   <code>
    t
   </code>
   are isomorphic if the characters in
   <code>
    s
   </code>
   can be replaced to get
   <code>
    t
   </code>
   .
  </p>
  <p>
   All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "egg", t = "add"
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "foo", t = "bar"
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "paper", t = "title"
<strong>Output:</strong> true
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 5 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     t.length == s.length
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    and
    <code>
     t
    </code>
    consist of any valid ascii character.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 205 -->
<pre>/*
 * @lc app=leetcode id=205 lang=cpp
 *
 * [205] Isomorphic Strings
 */

// @lc code=start
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        if(s.length() != t.length()) return false;
        map&lt;char,char&gt;m1;
        map&lt;char,char&gt;m2;
        for(int i = 0; i &lt; s.length();i++){
            cout&lt;&lt;i;
            if(m1.find(s[i])==m1.end() &amp;&amp; m2.find(t[i])==m2.end() ){
                m1[s[i]]=t[i];
                m2[t[i]]=s[i];
            }
            else{
                if(m1[s[i]]!=t[i] || m2[t[i]]!=s[i]) return false;
            }
        }
        return true;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 206. Reverse Linked List
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    head
   </code>
   of a singly linked list, reverse the list, and return
   <em>
    the reversed list
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/rev1ex1.jpg" style="width: 542px; height: 222px;"/>
  <pre><strong>Input:</strong> head = [1,2,3,4,5]
<strong>Output:</strong> [5,4,3,2,1]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/rev1ex2.jpg" style="width: 182px; height: 222px;"/>
  <pre><strong>Input:</strong> head = [1,2]
<strong>Output:</strong> [2,1]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> head = []
<strong>Output:</strong> []
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the list is the range
    <code>
     [0, 5000]
    </code>
    .
   </li>
   <li>
    <code>
     -5000 &lt;= Node.val &lt;= 5000
    </code>
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   A linked list can be reversed either iteratively or recursively. Could you implement both?
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 206 -->
<pre>/*
 * @lc app=leetcode id=206 lang=cpp
 *
 * [206] Reverse Linked List
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *current = head;
        ListNode *prev=NULL,*new_node=NULL;
        while(current!=NULL){
            new_node = current-&gt;next;
            current-&gt;next=prev;
            prev=current;
            current=new_node;
        }
        return prev;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 207. Course Schedule
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   There are a total of
   <code>
    numCourses
   </code>
   courses you have to take, labeled from
   <code>
    0
   </code>
   to
   <code>
    numCourses - 1
   </code>
   . You are given an array
   <code>
    prerequisites
   </code>
   where
   <code>
    prerequisites[i] = [a
    <sub>
     i
    </sub>
    , b
    <sub>
     i
    </sub>
    ]
   </code>
   indicates that you
   <strong>
    must
   </strong>
   take course
   <code>
    b
    <sub>
     i
    </sub>
   </code>
   first if you want to take course
   <code>
    a
    <sub>
     i
    </sub>
   </code>
   .
  </p>
  <ul>
   <li>
    For example, the pair
    <code>
     [0, 1]
    </code>
    , indicates that to take course
    <code>
     0
    </code>
    you have to first take course
    <code>
     1
    </code>
    .
   </li>
  </ul>
  <p>
   Return
   <code>
    true
   </code>
   if you can finish all courses. Otherwise, return
   <code>
    false
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]
<strong>Output:</strong> true
<strong>Explanation:</strong> There are a total of 2 courses to take. 
To take course 1 you should have finished course 0. So it is possible.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> numCourses = 2, prerequisites = [[1,0],[0,1]]
<strong>Output:</strong> false
<strong>Explanation:</strong> There are a total of 2 courses to take. 
To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= numCourses &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= prerequisites.length &lt;= 5000
    </code>
   </li>
   <li>
    <code>
     prerequisites[i].length == 2
    </code>
   </li>
   <li>
    <code>
     0 &lt;= a
     <sub>
      i
     </sub>
     , b
     <sub>
      i
     </sub>
     &lt; numCourses
    </code>
   </li>
   <li>
    All the pairs prerequisites[i] are
    <strong>
     unique
    </strong>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 207 -->
<pre>/*
 * @lc app=leetcode id=207 lang=cpp
 *
 * [207] Course Schedule
 */

// @lc code=start
class Solution {
public:
    bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) {
    map&lt;int,vector&lt;int&gt;&gt;graph;
    vector&lt;int&gt;ind(numCourses,0);
    for(auto x:prerequisites){
        ind[x[1]]++;
        graph[x[0]].push_back(x[1]);
    }
    int nodes=0;
    queue&lt;int&gt;q;
    for(int i=0;i&lt;numCourses;i++){
        if(ind[i]==0) q.push(i);
    }
    while(!q.empty()){
        int t=q.front();
        q.pop();
        nodes++;
        for(int i=0;i&lt;graph[t].size();i++){
            int j=graph[t][i];
            ind[j]--;
            if(ind[j]==0)q.push(j);
        }
    }
    return nodes==numCourses;
    }
};
// @lc ode=end

</pre><html><head></head><body>
<div id="title">
 208. Implement Trie (Prefix Tree)
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   A
   <a href="https://en.wikipedia.org/wiki/Trie" target="_blank">
    <strong>
     trie
    </strong>
   </a>
   (pronounced as "try") or
   <strong>
    prefix tree
   </strong>
   is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.
  </p>
  <p>
   Implement the Trie class:
  </p>
  <ul>
   <li>
    <code>
     Trie()
    </code>
    Initializes the trie object.
   </li>
   <li>
    <code>
     void insert(String word)
    </code>
    Inserts the string
    <code>
     word
    </code>
    into the trie.
   </li>
   <li>
    <code>
     boolean search(String word)
    </code>
    Returns
    <code>
     true
    </code>
    if the string
    <code>
     word
    </code>
    is in the trie (i.e., was inserted before), and
    <code>
     false
    </code>
    otherwise.
   </li>
   <li>
    <code>
     boolean startsWith(String prefix)
    </code>
    Returns
    <code>
     true
    </code>
    if there is a previously inserted string
    <code>
     word
    </code>
    that has the prefix
    <code>
     prefix
    </code>
    , and
    <code>
     false
    </code>
    otherwise.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input</strong>
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
<strong>Output</strong>
[null, null, true, false, true, null, true]

<strong>Explanation</strong>
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // return True
trie.search("app");     // return False
trie.startsWith("app"); // return True
trie.insert("app");
trie.search("app");     // return True
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= word.length, prefix.length &lt;= 2000
    </code>
   </li>
   <li>
    <code>
     word
    </code>
    and
    <code>
     prefix
    </code>
    consist only of lowercase English letters.
   </li>
   <li>
    At most
    <code>
     3 * 10
     <sup>
      4
     </sup>
    </code>
    calls
    <strong>
     in total
    </strong>
    will be made to
    <code>
     insert
    </code>
    ,
    <code>
     search
    </code>
    , and
    <code>
     startsWith
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 208 -->
<pre>/*
 * @lc app=leetcode id=208 lang=cpp
 *
 * [208] Implement Trie (Prefix Tree)
 */

// @lc code=start

class TrieNode{
    public:
        map&lt;char, TrieNode*&gt; children;
        bool end=false;
};

class Trie {
public:
    TrieNode * root;
    Trie() {
        root= new TrieNode();
    }

    void insert(string word) {
        TrieNode *node = root;
        for(char c: word){
            if(node-&gt;children.find(c)==node-&gt;children.end()){
                node-&gt;children[c]= new TrieNode();
            }
            node=node-&gt;children[c];
        }
        node-&gt;end=true;
    }

    bool searchmain(string word,bool prefix) {
        TrieNode *node = root;
        for(char c: word){
            if(node-&gt;children.find(c)==node-&gt;children.end()){
                return false;
            }
            node=node-&gt;children[c];
        }
        if(prefix==true) return true;
        return node!=NULL &amp;&amp; node-&gt;end;
    }

    bool search(string word) {
        return searchmain(word,false);
    }

    bool startsWith(string prefix) {
        return searchmain(prefix,true);
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj-&gt;insert(word);
 * bool param_2 = obj-&gt;search(word);
 * bool param_3 = obj-&gt;startsWith(prefix);
 */
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 209. Minimum Size Subarray Sum
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of positive integers
   <code>
    nums
   </code>
   and a positive integer
   <code>
    target
   </code>
   , return the minimal length of a
   <strong>
    contiguous subarray
   </strong>
   <code>
    [nums
    <sub>
     l
    </sub>
    , nums
    <sub>
     l+1
    </sub>
    , ..., nums
    <sub>
     r-1
    </sub>
    , nums
    <sub>
     r
    </sub>
    ]
   </code>
   of which the sum is greater than or equal to
   <code>
    target
   </code>
   . If there is no such subarray, return
   <code>
    0
   </code>
   instead.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> target = 7, nums = [2,3,1,2,4,3]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The subarray [4,3] has the minimal length under the problem constraint.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> target = 4, nums = [1,4,4]
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> target = 11, nums = [1,1,1,1,1,1,1,1]
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= target &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     1 &lt;= nums[i] &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow up:
  </strong>
  If you have figured out the
  <code>
   O(n)
  </code>
  solution, try coding another solution of which the time complexity is
  <code>
   O(n log(n))
  </code>
  .
 </div>
</div>
</body></html>
<!-- Solution for Question 209 -->
<pre>/*
 * @lc app=leetcode id=209 lang=cpp
 *
 * [209] Minimum Size Subarray Sum
 */

// @lc code=start
class Solution {
public:
    int minSubArrayLen(int target, vector&lt;int&gt;&amp; nums) {
        int start = 0;
        int sum=0;
        int maxx=INT_MAX;
        int end=0;
        int n=nums.size();
        while(end&lt;n){
            sum+=nums[end++];
            while(sum&gt;=target){
                maxx=min(maxx,end-start);
                sum=sum-nums[start++];
            }
        }
        return maxx==INT_MAX?0:maxx;

    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 210. Course Schedule II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   There are a total of
   <code>
    numCourses
   </code>
   courses you have to take, labeled from
   <code>
    0
   </code>
   to
   <code>
    numCourses - 1
   </code>
   . You are given an array
   <code>
    prerequisites
   </code>
   where
   <code>
    prerequisites[i] = [a
    <sub>
     i
    </sub>
    , b
    <sub>
     i
    </sub>
    ]
   </code>
   indicates that you
   <strong>
    must
   </strong>
   take course
   <code>
    b
    <sub>
     i
    </sub>
   </code>
   first if you want to take course
   <code>
    a
    <sub>
     i
    </sub>
   </code>
   .
  </p>
  <ul>
   <li>
    For example, the pair
    <code>
     [0, 1]
    </code>
    , indicates that to take course
    <code>
     0
    </code>
    you have to first take course
    <code>
     1
    </code>
    .
   </li>
  </ul>
  <p>
   Return
   <em>
    the ordering of courses you should take to finish all courses
   </em>
   . If there are many valid answers, return
   <strong>
    any
   </strong>
   of them. If it is impossible to finish all courses, return
   <strong>
    an empty array
   </strong>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> numCourses = 2, prerequisites = [[1,0]]
<strong>Output:</strong> [0,1]
<strong>Explanation:</strong> There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
<strong>Output:</strong> [0,2,1,3]
<strong>Explanation:</strong> There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> numCourses = 1, prerequisites = []
<strong>Output:</strong> [0]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= numCourses &lt;= 2000
    </code>
   </li>
   <li>
    <code>
     0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1)
    </code>
   </li>
   <li>
    <code>
     prerequisites[i].length == 2
    </code>
   </li>
   <li>
    <code>
     0 &lt;= a
     <sub>
      i
     </sub>
     , b
     <sub>
      i
     </sub>
     &lt; numCourses
    </code>
   </li>
   <li>
    <code>
     a
     <sub>
      i
     </sub>
     != b
     <sub>
      i
     </sub>
    </code>
   </li>
   <li>
    All the pairs
    <code>
     [a
     <sub>
      i
     </sub>
     , b
     <sub>
      i
     </sub>
     ]
    </code>
    are
    <strong>
     distinct
    </strong>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 210 -->
<pre>/*
 * @lc app=leetcode id=210 lang=cpp
 *
 * [210] Course Schedule II
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) {
    map&lt;int,vector&lt;int&gt;&gt;graph;
    vector&lt;int&gt;ind(numCourses,0);
    vector&lt;int&gt;ans;
    for(auto x:prerequisites){
        ind[x[0]]++;
        graph[x[1]].push_back(x[0]);
    }
    int nodes=0;
    queue&lt;int&gt;q;
    for(int i=0;i&lt;numCourses;i++){
        if(ind[i]==0) q.push(i);
    }
    while(!q.empty()){
        int t=q.front();
        q.pop();
        nodes++;
        ans.push_back(t);
        for(int i=0;i&lt;graph[t].size();i++){
            int j=graph[t][i];
            ind[j]--;
            if(ind[j]==0)q.push(j);
        }
    }
    vector&lt;int&gt;ans2={};
    return nodes==numCourses?ans:ans2;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 212. Word Search II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an
   <code>
    m x n
   </code>
   <code>
    board
   </code>
   of characters and a list of strings
   <code>
    words
   </code>
   , return
   <em>
    all words on the board
   </em>
   .
  </p>
  <p>
   Each word must be constructed from letters of sequentially adjacent cells, where
   <strong>
    adjacent cells
   </strong>
   are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/search1.jpg" style="width: 322px; height: 322px;"/>
  <pre><strong>Input:</strong> board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
<strong>Output:</strong> ["eat","oath"]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/search2.jpg" style="width: 162px; height: 162px;"/>
  <pre><strong>Input:</strong> board = [["a","b"],["c","d"]], words = ["abcb"]
<strong>Output:</strong> []
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == board.length
    </code>
   </li>
   <li>
    <code>
     n == board[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m, n &lt;= 12
    </code>
   </li>
   <li>
    <code>
     board[i][j]
    </code>
    is a lowercase English letter.
   </li>
   <li>
    <code>
     1 &lt;= words.length &lt;= 3 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     1 &lt;= words[i].length &lt;= 10
    </code>
   </li>
   <li>
    <code>
     words[i]
    </code>
    consists of lowercase English letters.
   </li>
   <li>
    All the strings of
    <code>
     words
    </code>
    are unique.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 212 -->
<pre>/*
 * @lc app=leetcode id=212 lang=cpp
 *
 * [212] Word Search II
 */

// @lc code=start
class Solution {
public:
    bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board,int i,int j,string s){
        if(!s.size()) return true;
        if(i&lt;0 || j&lt;0 || i&gt;=board.size() || j&gt;= board[0].size() || board[i][j]!=s[0] || board[i][j]==&#x27;*&#x27;) return false;
        char c = board[i][j];
        board[i][j]=&#x27;*&#x27;;
        s=s.substr(1);
        bool ans = dfs(board,i+1,j,s) || dfs(board,i-1,j,s) ||dfs(board,i,j-1,s) ||dfs(board,i,j+1,s);
        board[i][j]=c;
        return ans;
    }
    vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) {
        set&lt;string&gt;a;
        map&lt;char,vector&lt;pair&lt;int,int&gt;&gt;&gt;m;
        for(int i=0;i&lt;board.size();i++){
            for(int j=0;j&lt;board[i].size();j++){
                m[board[i][j]].push_back({i,j});
            }
        }
        for(int i=0;i&lt;words.size();i++){
            for(auto x:m[words[i][0]]){
                if(dfs(board,x.first,x.second,words[i])){
                    a.insert(words[i]);
                }
            }
        }
        vector&lt;string&gt;ans;
        for(auto x:a)ans.push_back(x);
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 213. House Robber II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are
   <strong>
    arranged in a circle.
   </strong>
   That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and
   <b>
    it will automatically contact the police if two adjacent houses were broken into on the same night
   </b>
   .
  </p>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   representing the amount of money of each house, return
   <em>
    the maximum amount of money you can rob tonight
    <strong>
     without alerting the police
    </strong>
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,3,2]
<strong>Output:</strong> 3
<strong>Explanation:</strong> You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3,1]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> 3
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     0 &lt;= nums[i] &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 213 -->
<pre>/*
 * @lc app=leetcode id=213 lang=cpp
 *
 * [213] House Robber II
 */

// @lc code=start
class Solution {
public:
int f(vector&lt;int&gt;nums)
{
    int ans=0;
    if(nums.size()==0) return 0;
    if(nums.size()==1) return nums[0];
    vector&lt;int&gt;dp(nums.size(),0);
    dp[0]=nums[0];
    dp[1]=max(nums[0],nums[1]);
    for(int i=2; i&lt;nums.size(); i++){
        dp[i]=max(dp[i-1],dp[i-2]+nums[i]);
    }
    return dp[nums.size()-1];
}
    int rob(vector&lt;int&gt;&amp; nums) {
        int j=nums.size()-1;
        vector&lt;int&gt;a1,a2;
        if(nums.size()==1) return nums[0];
        for(int i=0;i&lt;nums.size();i++){
            if(i!=0){
                a2.push_back(nums[i]);
            }
            if(i!=nums.size()-1){
                a1.push_back(nums[i]);
            }
        }
        return max(f(a1),f(a2));
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 214. Shortest Palindrome
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given a string
   <code>
    s
   </code>
   . You can convert
   <code>
    s
   </code>
   to a palindrome by adding characters in front of it.
  </p>
  <p>
   Return
   <em>
    the shortest palindrome you can find by performing this transformation
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "aacecaaa"
<strong>Output:</strong> "aaacecaaa"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "abcd"
<strong>Output:</strong> "dcbabcd"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= s.length &lt;= 5 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consists of lowercase English letters only.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 214 -->
<pre>/*
 * @lc app=leetcode id=214 lang=cpp
 *
 * [214] Shortest Palindrome
 */

// @lc code=start
class Solution {
public:
    string shortestPalindrome(string s) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 215. Kth Largest Element in an Array
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   and an integer
   <code>
    k
   </code>
   , return
   <em>
    the
   </em>
   <code>
    k
    <sup>
     th
    </sup>
   </code>
   <em>
    largest element in the array
   </em>
   .
  </p>
  <p>
   Note that it is the
   <code>
    k
    <sup>
     th
    </sup>
   </code>
   largest element in the sorted order, not the
   <code>
    k
    <sup>
     th
    </sup>
   </code>
   distinct element.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,2,1,5,6,4], k = 2
<strong>Output:</strong> 5
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,2,3,1,2,4,5,5,6], k = 4
<strong>Output:</strong> 4
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= k &lt;= nums.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= nums[i] &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 215 -->
<pre>/*
 * @lc app=leetcode id=215 lang=cpp
 *
 * [215] Kth Largest Element in an Array
 */

// @lc code=start
class Solution {
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
        priority_queue&lt;int&gt; p;
        for(int x:nums){
            p.push(x);
        }
        int i=0;
        while(i!=k-1){
            p.pop();
            i++;
        }
        return p.top();
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 216. Combination Sum III
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Find all valid combinations of
   <code>
    k
   </code>
   numbers that sum up to
   <code>
    n
   </code>
   such that the following conditions are true:
  </p>
  <ul>
   <li>
    Only numbers
    <code>
     1
    </code>
    through
    <code>
     9
    </code>
    are used.
   </li>
   <li>
    Each number is used
    <strong>
     at most once
    </strong>
    .
   </li>
  </ul>
  <p>
   Return
   <em>
    a list of all possible valid combinations
   </em>
   . The list must not contain the same combination twice, and the combinations may be returned in any order.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> k = 3, n = 7
<strong>Output:</strong> [[1,2,4]]
<strong>Explanation:</strong>
1 + 2 + 4 = 7
There are no other valid combinations.</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> k = 3, n = 9
<strong>Output:</strong> [[1,2,6],[1,3,5],[2,3,4]]
<strong>Explanation:</strong>
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
There are no other valid combinations.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> k = 4, n = 1
<strong>Output:</strong> []
<strong>Explanation:</strong> There are no valid combinations.
Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 &gt; 1, there are no valid combination.
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> k = 3, n = 2
<strong>Output:</strong> []
<strong>Explanation:</strong> There are no valid combinations.
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> k = 9, n = 45
<strong>Output:</strong> [[1,2,3,4,5,6,7,8,9]]
<strong>Explanation:</strong>
1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45
There are no other valid combinations.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     2 &lt;= k &lt;= 9
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 60
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 216 -->
<pre>/*
 * @lc app=leetcode id=216 lang=cpp
 *
 * [216] Combination Sum III
 */

// @lc code=start
class Solution {
public:
 vector&lt;vector&lt;int&gt;&gt;a;
    void ans(int i,int k,int n,int index,vector&lt;int&gt;b)
    {
        if(k==i)
        {
            if(n==0)a.push_back(b);
            return;
        }
        if(n&lt;0 || k&lt;0) return;
        for(int j=index;j&lt;10;j++){
            if(n-j&gt;=0){
                b.push_back(j);
                ans(i+1,k,n-j,j+1,b);
                b.pop_back();
            }
        }
    }
    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) {
        int i=0,index=1;
        vector&lt;int&gt;b;
        ans(i,k,n,index,b);
        return a;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 217. Contains Duplicate
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   , return
   <code>
    true
   </code>
   if any value appears
   <strong>
    at least twice
   </strong>
   in the array, and return
   <code>
    false
   </code>
   if every element is distinct.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3,1]
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,1,1,3,3,4,3,2,4,2]
<strong>Output:</strong> true
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      9
     </sup>
     &lt;= nums[i] &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 217 -->
<pre>/*
 * @lc app=leetcode id=217 lang=cpp
 *
 * [217] Contains Duplicate
 */

// @lc code=start
class Solution {
public:
    bool containsDuplicate(vector&lt;int&gt;&amp; nums) {
        map&lt;int,int&gt;m;
        for(auto x : nums)
        {
            if(m[x]!=0)
            {
                return 1;
            }
            m[x]++;
        }
        return 0 ;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 219. Contains Duplicate II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   and an integer
   <code>
    k
   </code>
   , return
   <code>
    true
   </code>
   if there are two
   <strong>
    distinct indices
   </strong>
   <code>
    i
   </code>
   and
   <code>
    j
   </code>
   in the array such that
   <code>
    nums[i] == nums[j]
   </code>
   and
   <code>
    abs(i - j) &lt;= k
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3,1], k = 3
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,0,1,1], k = 1
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3,1,2,3], k = 2
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      9
     </sup>
     &lt;= nums[i] &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= k &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 219 -->
<pre>/*
 * @lc app=leetcode id=219 lang=cpp
 *
 * [219] Contains Duplicate II
 */

// @lc code=start
class Solution {
public:
    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {
        map&lt;int,vector&lt;int&gt;&gt;m;
        for(int i=0; i&lt;nums.size(); i++){
            if(m.find(nums[i])==m.end()){
                m[nums[i]].push_back(i);
            }
            else{
                for(int j=0; j&lt;m[nums[i]].size(); j++){
                    if(k&gt;=abs(m[nums[i]][j]-i)) return true;
                }
                m[nums[i]].push_back(i);
            }
        }
        return false;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 220. Contains Duplicate III
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   and two integers
   <code>
    k
   </code>
   and
   <code>
    t
   </code>
   , return
   <code>
    true
   </code>
   if there are
   <strong>
    two distinct indices
   </strong>
   <code>
    i
   </code>
   and
   <code>
    j
   </code>
   in the array such that
   <code>
    abs(nums[i] - nums[j]) &lt;= t
   </code>
   and
   <code>
    abs(i - j) &lt;= k
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3,1], k = 3, t = 0
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,0,1,1], k = 1, t = 2
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,5,9,1,5,9], k = 2, t = 3
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= nums.length &lt;= 2 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= nums[i] &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
   <li>
    <code>
     0 &lt;= k &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= t &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 220 -->
<pre>/*
 * @lc app=leetcode id=220 lang=cpp
 *
 * [220] Contains Duplicate III
 */

// @lc code=start
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int valueDiff) {
        map&lt;int,vector&lt;int&gt;&gt;m;
        for(int i=0; i&lt;nums.size(); i++){
            for(int j=i+1; j&lt;nums.size(); j++){
                if(abs(i-j)&lt;=k){
                    if(abs(nums[i]-nums[j])&lt;=valueDiff){
                        return true;
                    }
                }
            }
        }
        return false;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 221. Maximal Square
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an
   <code>
    m x n
   </code>
   binary
   <code>
    matrix
   </code>
   filled with
   <code>
    0
   </code>
   's and
   <code>
    1
   </code>
   's,
   <em>
    find the largest square containing only
   </em>
   <code>
    1
   </code>
   's
   <em>
    and return its area
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/max1grid.jpg" style="width: 400px; height: 319px;"/>
  <pre><strong>Input:</strong> matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
<strong>Output:</strong> 4
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/max2grid.jpg" style="width: 165px; height: 165px;"/>
  <pre><strong>Input:</strong> matrix = [["0","1"],["1","0"]]
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> matrix = [["0"]]
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == matrix.length
    </code>
   </li>
   <li>
    <code>
     n == matrix[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m, n &lt;= 300
    </code>
   </li>
   <li>
    <code>
     matrix[i][j]
    </code>
    is
    <code>
     '0'
    </code>
    or
    <code>
     '1'
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 221 -->
<pre>/*
 * @lc app=leetcode id=221 lang=cpp
 *
 * [221] Maximal Square
 */

// @lc code=start
class Solution {
public:
    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        vector&lt;vector&lt;int&gt;&gt;dp(m,vector&lt;int&gt;(n,0));
        int a=0;
        for(int i=0;i&lt;m;i++){
            for(int j=0;j&lt;n;j++){
                if(matrix[i][j]==&#x27;0&#x27; || !i || !j) dp[i][j]=matrix[i][j]-&#x27;0&#x27;;
                else{
                    dp[i][j]=min({dp[i-1][j-1],dp[i-1][j],dp[i][j-1]})+1;
                }
                a=max(a,dp[i][j]);
            }
        }

        for(auto x:dp){
            for(int y:x){
                cout&lt;&lt;y&lt;&lt;&#x27; &#x27;;
            }
            cout&lt;&lt;endl;
        }
        return a*a;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 222. Count Complete Tree Nodes
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a
   <strong>
    complete
   </strong>
   binary tree, return the number of the nodes in the tree.
  </p>
  <p>
   According to
   <strong>
    <a href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees" target="_blank">
     Wikipedia
    </a>
   </strong>
   , every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between
   <code>
    1
   </code>
   and
   <code>
    2
    <sup>
     h
    </sup>
   </code>
   nodes inclusive at the last level
   <code>
    h
   </code>
   .
  </p>
  <p>
   Design an algorithm that runs in less than
   <code data-stringify-type="code">
    O(n)
   </code>
   time complexity.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/complete.jpg" style="width: 372px; height: 302px;"/>
  <pre><strong>Input:</strong> root = [1,2,3,4,5,6]
<strong>Output:</strong> 6
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = []
<strong>Output:</strong> 0
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1]
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [0, 5 * 10
     <sup>
      4
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     0 &lt;= Node.val &lt;= 5 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    The tree is guaranteed to be
    <strong>
     complete
    </strong>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 222 -->
<pre>/*
 * @lc app=leetcode id=222 lang=cpp
 *
 * [222] Count Complete Tree Nodes
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void inorder(TreeNode *root,int &amp; count){
        if(root){
            count++;
            inorder(root-&gt;left,count);
            inorder(root-&gt;right,count);
        }
    }
    int countNodes(TreeNode* root) {
        int count=0;
        inorder(root,count);
        return count;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 223. Rectangle Area
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the coordinates of two
   <strong>
    rectilinear
   </strong>
   rectangles in a 2D plane, return
   <em>
    the total area covered by the two rectangles
   </em>
   .
  </p>
  <p>
   The first rectangle is defined by its
   <strong>
    bottom-left
   </strong>
   corner
   <code>
    (ax1, ay1)
   </code>
   and its
   <strong>
    top-right
   </strong>
   corner
   <code>
    (ax2, ay2)
   </code>
   .
  </p>
  <p>
   The second rectangle is defined by its
   <strong>
    bottom-left
   </strong>
   corner
   <code>
    (bx1, by1)
   </code>
   and its
   <strong>
    top-right
   </strong>
   corner
   <code>
    (bx2, by2)
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="Rectangle Area" src="./output_files/rectangle-plane.png" style="width: 700px; height: 365px;"/>
  <pre><strong>Input:</strong> ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2
<strong>Output:</strong> 45
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2
<strong>Output:</strong> 16
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= ax1, ay1, ax2, ay2, bx1, by1, bx2, by2 &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 223 -->
<pre>/*
 * @lc app=leetcode id=223 lang=cpp
 *
 * [223] Rectangle Area
 */

// @lc code=start
class Solution {
public:

    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {
        int area1 = abs(ax1-ax2)*abs(ay1-ay2);
        int area2 = abs(bx1-bx2)*abs(by1-by2);
        if(ax1&gt;=bx2 || ay1&gt;=by2 || ax2&lt;=bx1 || ay2&lt;=by1)
            return area1 + area2;
        return area1 + area2 - (min(bx2,ax2) - max(ax1,bx1))*(min(by2,ay2) - max(ay1,by1));
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 226. Invert Binary Tree
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree, invert the tree, and return
   <em>
    its root
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/invert1-tree.jpg" style="width: 500px; height: 165px;"/>
  <pre><strong>Input:</strong> root = [4,2,7,1,3,6,9]
<strong>Output:</strong> [4,7,2,9,6,3,1]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/invert2-tree.jpg" style="width: 500px; height: 120px;"/>
  <pre><strong>Input:</strong> root = [2,1,3]
<strong>Output:</strong> [2,3,1]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [0, 100]
    </code>
    .
   </li>
   <li>
    <code>
     -100 &lt;= Node.val &lt;= 100
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 226 -->
<pre>/*
 * @lc app=leetcode id=226 lang=cpp
 *
 * [226] Invert Binary Tree
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root)
        {
            swap(root-&gt;right,root-&gt;left);
            invertTree(root-&gt;left);
            invertTree(root-&gt;right);
        }
        return root;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 227. Basic Calculator II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    s
   </code>
   which represents an expression,
   <em>
    evaluate this expression and return its value
   </em>
   .
  </p>
  <p>
   The integer division should truncate toward zero.
  </p>
  <p>
   You may assume that the given expression is always valid. All intermediate results will be in the range of
   <code>
    [-2
    <sup>
     31
    </sup>
    , 2
    <sup>
     31
    </sup>
    - 1]
   </code>
   .
  </p>
  <p>
   <strong>
    Note:
   </strong>
   You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as
   <code>
    eval()
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "3+2*2"
<strong>Output:</strong> 7
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = " 3/2 "
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = " 3+5 / 2 "
<strong>Output:</strong> 5
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 3 * 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consists of integers and operators
    <code>
     ('+', '-', '*', '/')
    </code>
    separated by some number of spaces.
   </li>
   <li>
    <code>
     s
    </code>
    represents
    <strong>
     a valid expression
    </strong>
    .
   </li>
   <li>
    All the integers in the expression are non-negative integers in the range
    <code>
     [0, 2
     <sup>
      31
     </sup>
     - 1]
    </code>
    .
   </li>
   <li>
    The answer is
    <strong>
     guaranteed
    </strong>
    to fit in a
    <strong>
     32-bit integer
    </strong>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 227 -->
<pre>/*
 * @lc app=leetcode id=227 lang=cpp
 *
 * [227] Basic Calculator II
 */

// @lc code=start
class Solution {
public:
    int calculate(string s) {
        stack&lt;int&gt;a;
        long n=0;
        char sign=&#x27;+&#x27;;
        for(int i=0; i&lt;s.length();i++){
            if(isdigit(s[i])) n=n*10 + (s[i] - &#x27;0&#x27;);
            if(!isdigit(s[i]) &amp;&amp; !isspace(s[i]) || i==s.length()-1){
                if(sign == &#x27;+&#x27;) a.push(n);
                else if(sign == &#x27;-&#x27;) a.push(-n);
                else{
                    int temp=a.top();
                    a.pop();
                    if(sign == &#x27;*&#x27;){
                        a.push(temp*n);
                    }
                    else{
                        a.push(temp/n);
                    }
                }
                sign=s[i];
                n=0;
            }
        }
        while(!a.empty()){
            n=n+a.top();
            a.pop();
        }
        return n;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 228. Summary Ranges
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given a
   <strong>
    sorted unique
   </strong>
   integer array
   <code>
    nums
   </code>
   .
  </p>
  <p>
   Return
   <em>
    the
    <strong>
     smallest sorted
    </strong>
    list of ranges that
    <strong>
     cover all the numbers in the array exactly
    </strong>
   </em>
   . That is, each element of
   <code>
    nums
   </code>
   is covered by exactly one of the ranges, and there is no integer
   <code>
    x
   </code>
   such that
   <code>
    x
   </code>
   is in one of the ranges but not in
   <code>
    nums
   </code>
   .
  </p>
  <p>
   Each range
   <code>
    [a,b]
   </code>
   in the list should be output as:
  </p>
  <ul>
   <li>
    <code>
     "a-&gt;b"
    </code>
    if
    <code>
     a != b
    </code>
   </li>
   <li>
    <code>
     "a"
    </code>
    if
    <code>
     a == b
    </code>
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [0,1,2,4,5,7]
<strong>Output:</strong> ["0-&gt;2","4-&gt;5","7"]
<strong>Explanation:</strong> The ranges are:
[0,2] --&gt; "0-&gt;2"
[4,5] --&gt; "4-&gt;5"
[7,7] --&gt; "7"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [0,2,3,4,6,8,9]
<strong>Output:</strong> ["0","2-&gt;4","6","8-&gt;9"]
<strong>Explanation:</strong> The ranges are:
[0,0] --&gt; "0"
[2,4] --&gt; "2-&gt;4"
[6,6] --&gt; "6"
[8,9] --&gt; "8-&gt;9"
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = []
<strong>Output:</strong> []
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [-1]
<strong>Output:</strong> ["-1"]
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [0]
<strong>Output:</strong> ["0"]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= nums.length &lt;= 20
    </code>
   </li>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= nums[i] &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
   <li>
    All the values of
    <code>
     nums
    </code>
    are
    <strong>
     unique
    </strong>
    .
   </li>
   <li>
    <code>
     nums
    </code>
    is sorted in ascending order.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 228 -->
<pre>/*
 * @lc app=leetcode id=228 lang=cpp
 *
 * [228] Summary Ranges
 */

// @lc code=start
class Solution {
public:
    vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) {
        vector&lt;string&gt;ans;
        if(nums.size() == 1) return {to_string(nums[0])};
        int start=0;
        int end=0;
        nums.push_back(0);
        for(int i = 1; i &lt; nums.size();i++){
            if((long long) nums[i]==(long long) nums[end]+1){
                end++;
            }
            else{
                if(start==end){
                    ans.push_back(to_string(nums[start]));
                }
                else{
                    ans.push_back(to_string(nums[start])+&quot;-&gt;&quot;+to_string(nums[end]));
                }
                start=end+1;
                end=end+1;
            }
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 229. Majority Element II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array of size
   <code>
    n
   </code>
   , find all elements that appear more than
   <code>
    ⌊ n/3 ⌋
   </code>
   times.
  </p>
  <p>
   <strong>
    Follow-up:
   </strong>
   Could you solve the problem in linear time and in O(1) space?
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,2,3]
<strong>Output:</strong> [3]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1]
<strong>Output:</strong> [1]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2]
<strong>Output:</strong> [1,2]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 5 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      9
     </sup>
     &lt;= nums[i] &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 229 -->
<pre>/*
 * @lc app=leetcode id=229 lang=cpp
 *
 * [229] Majority Element II
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) {
        int s=nums.size();
        vector&lt;int&gt;ans;
        map&lt;int,int&gt;m;
        for(int n:nums)
        {
            m[n]++;
        }
        for(auto n:m)
        {
            if(n.second&gt;s/3)
            {
                ans.push_back(n.first);
            }
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 230. Kth Smallest Element in a BST
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary search tree, and an integer
   <code>
    k
   </code>
   , return
   <em>
    the
   </em>
   <code>
    k
    <sup>
     th
    </sup>
   </code>
   (
   <strong>
    1-indexed
   </strong>
   )
   <em>
    smallest element in the tree
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/kthtree1.jpg" style="width: 212px; height: 301px;"/>
  <pre><strong>Input:</strong> root = [3,1,4,null,2], k = 1
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/kthtree2.jpg" style="width: 382px; height: 302px;"/>
  <pre><strong>Input:</strong> root = [5,3,6,2,4,null,null,1], k = 3
<strong>Output:</strong> 3
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is
    <code>
     n
    </code>
    .
   </li>
   <li>
    <code>
     1 &lt;= k &lt;= n &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= Node.val &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow up:
  </strong>
  If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?
 </div>
</div>
</body></html>
<!-- Solution for Question 230 -->
<pre>/*
 * @lc app=leetcode id=230 lang=cpp
 *
 * [230] Kth Smallest Element in a BST
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt;a;
    void inorder(TreeNode *root){
        if(root)
        {
            inorder(root-&gt;left);
            a.push_back(root-&gt;val);
            inorder(root-&gt;right);
        }
    }
    int kthSmallest(TreeNode* root, int k) {
        inorder(root);
        return a[k-1];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 231. Power of Two
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer
   <code>
    n
   </code>
   , return
   <em>
    <code>
     true
    </code>
    if it is a power of two. Otherwise, return
    <code>
     false
    </code>
   </em>
   .
  </p>
  <p>
   An integer
   <code>
    n
   </code>
   is a power of two, if there exists an integer
   <code>
    x
   </code>
   such that
   <code>
    n == 2
    <sup>
     x
    </sup>
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1
<strong>Output:</strong> true
<strong>Explanation: </strong>2<sup>0</sup> = 1
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 16
<strong>Output:</strong> true
<strong>Explanation: </strong>2<sup>4</sup> = 16
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 3
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 4
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 5
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= n &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow up:
  </strong>
  Could you solve it without loops/recursion?
 </div>
</div>
</body></html>
<!-- Solution for Question 231 -->
<pre>/*
 * @lc app=leetcode id=231 lang=cpp
 *
 * [231] Power of Two
 */

// @lc code=start
class Solution {
public:
    bool isPowerOfTwo(int n) {
        if(n&lt;=0) return 0;
        n=(n&amp;(n-1));
        if(n==0) return 1;
        return 0;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 233. Number of Digit One
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer
   <code>
    n
   </code>
   , count
   <em>
    the total number of digit
   </em>
   <code>
    1
   </code>
   <em>
    appearing in all non-negative integers less than or equal to
   </em>
   <code>
    n
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 13
<strong>Output:</strong> 6
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 0
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= n &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 233 -->
<pre>/*
 * @lc app=leetcode id=233 lang=cpp
 *
 * [233] Number of Digit One
 */

// @lc code=start
class Solution {
public:
    int countDigitOne(int n) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 234. Palindrome Linked List
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    head
   </code>
   of a singly linked list, return
   <code>
    true
   </code>
   if it is a palindrome.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/pal1linked-list.jpg" style="width: 422px; height: 62px;"/>
  <pre><strong>Input:</strong> head = [1,2,2,1]
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/pal2linked-list.jpg" style="width: 182px; height: 62px;"/>
  <pre><strong>Input:</strong> head = [1,2]
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the list is in the range
    <code>
     [1, 10
     <sup>
      5
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     0 &lt;= Node.val &lt;= 9
    </code>
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow up:
  </strong>
  Could you do it in
  <code>
   O(n)
  </code>
  time and
  <code>
   O(1)
  </code>
  space?
 </div>
</div>
</body></html>
<!-- Solution for Question 234 -->
<pre>/*
 * @lc app=leetcode id=234 lang=cpp
 *
 * [234] Palindrome Linked List
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 235. Lowest Common Ancestor of a Binary Search Tree
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.
  </p>
  <p>
   According to the
   <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank">
    definition of LCA on Wikipedia
   </a>
   : “The lowest common ancestor is defined between two nodes
   <code>
    p
   </code>
   and
   <code>
    q
   </code>
   as the lowest node in
   <code>
    T
   </code>
   that has both
   <code>
    p
   </code>
   and
   <code>
    q
   </code>
   as descendants (where we allow
   <b>
    a node to be a descendant of itself
   </b>
   ).”
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/binarysearchtree_improved.png" style="width: 200px; height: 190px;"/>
  <pre><strong>Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
<strong>Output:</strong> 6
<strong>Explanation:</strong> The LCA of nodes 2 and 8 is 6.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/binarysearchtree_improved.png" style="width: 200px; height: 190px;"/>
  <pre><strong>Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
<strong>Output:</strong> 2
<strong>Explanation:</strong> The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [2,1], p = 2, q = 1
<strong>Output:</strong> 2
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [2, 10
     <sup>
      5
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     -10
     <sup>
      9
     </sup>
     &lt;= Node.val &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
   <li>
    All
    <code>
     Node.val
    </code>
    are
    <strong>
     unique
    </strong>
    .
   </li>
   <li>
    <code>
     p != q
    </code>
   </li>
   <li>
    <code>
     p
    </code>
    and
    <code>
     q
    </code>
    will exist in the BST.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 235 -->
<pre>/*
 * @lc app=leetcode id=235 lang=cpp
 *
 * [235] Lowest Common Ancestor of a Binary Search Tree
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==NULL || p-&gt;val==root-&gt;val || q-&gt;val==root-&gt;val) return root;
        TreeNode *left= lowestCommonAncestor(root-&gt;left,p,q);
        TreeNode *right= lowestCommonAncestor(root-&gt;right,p,q);
        if(!left){
            return right;
        }
        if(!right){
            return left;
        }
        return root;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 236. Lowest Common Ancestor of a Binary Tree
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
  </p>
  <p>
   According to the
   <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank">
    definition of LCA on Wikipedia
   </a>
   : “The lowest common ancestor is defined between two nodes
   <code>
    p
   </code>
   and
   <code>
    q
   </code>
   as the lowest node in
   <code>
    T
   </code>
   that has both
   <code>
    p
   </code>
   and
   <code>
    q
   </code>
   as descendants (where we allow
   <b>
    a node to be a descendant of itself
   </b>
   ).”
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/binarytree.png" style="width: 200px; height: 190px;"/>
  <pre><strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
<strong>Output:</strong> 3
<strong>Explanation:</strong> The LCA of nodes 5 and 1 is 3.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/binarytree.png" style="width: 200px; height: 190px;"/>
  <pre><strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
<strong>Output:</strong> 5
<strong>Explanation:</strong> The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1,2], p = 1, q = 2
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [2, 10
     <sup>
      5
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     -10
     <sup>
      9
     </sup>
     &lt;= Node.val &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
   <li>
    All
    <code>
     Node.val
    </code>
    are
    <strong>
     unique
    </strong>
    .
   </li>
   <li>
    <code>
     p != q
    </code>
   </li>
   <li>
    <code>
     p
    </code>
    and
    <code>
     q
    </code>
    will exist in the tree.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 236 -->
<pre>/*
 * @lc app=leetcode id=236 lang=cpp
 *
 * [236] Lowest Common Ancestor of a Binary Tree
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==NULL || p-&gt;val==root-&gt;val || q-&gt;val==root-&gt;val) return root;
        TreeNode *left= lowestCommonAncestor(root-&gt;left,p,q);
        TreeNode *right= lowestCommonAncestor(root-&gt;right,p,q);
        if(!left){
            return right;
        }
        if(!right){
            return left;
        }
        return root;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 237. Delete Node in a Linked List
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Write a function to
   <strong>
    delete a node
   </strong>
   in a singly-linked list. You will
   <strong>
    not
   </strong>
   be given access to the
   <code>
    head
   </code>
   of the list, instead you will be given access to
   <strong>
    the node to be deleted
   </strong>
   directly.
  </p>
  <p>
   It is
   <strong>
    guaranteed
   </strong>
   that the node to be deleted is
   <strong>
    not a tail node
   </strong>
   in the list.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/node1.jpg" style="width: 450px; height: 322px;"/>
  <pre><strong>Input:</strong> head = [4,5,1,9], node = 5
<strong>Output:</strong> [4,1,9]
<strong>Explanation: </strong>You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/node2.jpg" style="width: 450px; height: 354px;"/>
  <pre><strong>Input:</strong> head = [4,5,1,9], node = 1
<strong>Output:</strong> [4,5,9]
<strong>Explanation: </strong>You are given the third node with value 1, the linked list should become 4 -&gt; 5 -&gt; 9 after calling your function.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> head = [1,2,3,4], node = 3
<strong>Output:</strong> [1,2,4]
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> head = [0,1], node = 0
<strong>Output:</strong> [1]
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> head = [-3,5,-99], node = -3
<strong>Output:</strong> [5,-99]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of the nodes in the given list is in the range
    <code>
     [2, 1000]
    </code>
    .
   </li>
   <li>
    <code>
     -1000 &lt;= Node.val &lt;= 1000
    </code>
   </li>
   <li>
    The value of each node in the list is
    <strong>
     unique
    </strong>
    .
   </li>
   <li>
    The
    <code>
     node
    </code>
    to be deleted is
    <strong>
     in the list
    </strong>
    and is
    <strong>
     not a tail
    </strong>
    node
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 237 -->
<pre>/*
 * @lc app=leetcode id=237 lang=cpp
 *
 * [237] Delete Node in a Linked List
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        node-&gt;val=node-&gt;next-&gt;val;
        node-&gt;next=node-&gt;next-&gt;next;
        return;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 238. Product of Array Except Self
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   , return
   <em>
    an array
   </em>
   <code>
    answer
   </code>
   <em>
    such that
   </em>
   <code>
    answer[i]
   </code>
   <em>
    is equal to the product of all the elements of
   </em>
   <code>
    nums
   </code>
   <em>
    except
   </em>
   <code>
    nums[i]
   </code>
   .
  </p>
  <p>
   The product of any prefix or suffix of
   <code>
    nums
   </code>
   is
   <strong>
    guaranteed
   </strong>
   to fit in a
   <strong>
    32-bit
   </strong>
   integer.
  </p>
  <p>
   You must write an algorithm that runs in
   <code>
    O(n)
   </code>
   time and without using the division operation.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> [24,12,8,6]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [-1,1,0,-3,3]
<strong>Output:</strong> [0,0,9,0,0]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     2 &lt;= nums.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     -30 &lt;= nums[i] &lt;= 30
    </code>
   </li>
   <li>
    The product of any prefix or suffix of
    <code>
     nums
    </code>
    is
    <strong>
     guaranteed
    </strong>
    to fit in a
    <strong>
     32-bit
    </strong>
    integer.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   Can you solve the problem in
   <code>
    O(1)
   </code>
   extra space complexity? (The output array
   <strong>
    does not
   </strong>
   count as extra space for space complexity analysis.)
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 238 -->
<pre>/*
 * @lc app=leetcode id=238 lang=cpp
 *
 * [238] Product of Array Except Self
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt; right,left;
        int sum_l=1,sum_r=1;
        for(int i=0;i&lt;nums.size();i++)
        {
        left.push_back(sum_l);
        right.push_back(sum_r);
        sum_l=sum_l*nums[i];
        sum_r=sum_r*nums[nums.size()-i-1];
        }
        for(int i=0;i&lt;left.size();i++)
        {
            left[i]=(left[i]*right[nums.size()-i-1]);
        }
        return left;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 239. Sliding Window Maximum
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an array of integers
   <code>
    nums
   </code>
   , there is a sliding window of size
   <code>
    k
   </code>
   which is moving from the very left of the array to the very right. You can only see the
   <code>
    k
   </code>
   numbers in the window. Each time the sliding window moves right by one position.
  </p>
  <p>
   Return
   <em>
    the max sliding window
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,3,-1,-3,5,3,6,7], k = 3
<strong>Output:</strong> [3,3,5,5,6,7]
<strong>Explanation:</strong> 
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       <strong>3</strong>
 1 [3  -1  -3] 5  3  6  7       <strong>3</strong>
 1  3 [-1  -3  5] 3  6  7      <strong> 5</strong>
 1  3  -1 [-3  5  3] 6  7       <strong>5</strong>
 1  3  -1  -3 [5  3  6] 7       <strong>6</strong>
 1  3  -1  -3  5 [3  6  7]      <strong>7</strong>
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1], k = 1
<strong>Output:</strong> [1]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,-1], k = 1
<strong>Output:</strong> [1,-1]
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [9,11], k = 2
<strong>Output:</strong> [11]
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [4,-2], k = 2
<strong>Output:</strong> [4]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= nums[i] &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     1 &lt;= k &lt;= nums.length
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 239 -->
<pre>/*
 * @lc app=leetcode id=239 lang=cpp
 *
 * [239] Sliding Window Maximum
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; a, int k) {
        vector&lt;int&gt;ans;
        if(k==0) return ans;
        priority_queue&lt;pair&lt;int,int&gt;&gt;pq;
        for(int i=0; i&lt;k;i++){
            pq.push({a[i],i});
        }
        ans.push_back(pq.top().first);
        cout&lt;&lt;pq.top().first&lt;&lt;endl;
        for(int i=k; i&lt;a.size();i++){
            while(!pq.empty() &amp;&amp; pq.top().second &lt;=i-k){
                pq.pop();
            }
            pq.push({a[i],i});
            ans.push_back(pq.top().first);
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 240. Search a 2D Matrix II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Write an efficient algorithm that searches for a
   <code>
    target
   </code>
   value in an
   <code>
    m x n
   </code>
   integer
   <code>
    matrix
   </code>
   . The
   <code>
    matrix
   </code>
   has the following properties:
  </p>
  <ul>
   <li>
    Integers in each row are sorted in ascending from left to right.
   </li>
   <li>
    Integers in each column are sorted in ascending from top to bottom.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/searchgrid2.jpg" style="width: 300px; height: 300px;"/>
  <pre><strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/searchgrid.jpg" style="width: 300px; height: 300px;"/>
  <pre><strong>Input:</strong> matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == matrix.length
    </code>
   </li>
   <li>
    <code>
     n == matrix[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n, m &lt;= 300
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      9
     </sup>
     &lt;= matrix[i][j] &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
   <li>
    All the integers in each row are
    <strong>
     sorted
    </strong>
    in ascending order.
   </li>
   <li>
    All the integers in each column are
    <strong>
     sorted
    </strong>
    in ascending order.
   </li>
   <li>
    <code>
     -10
     <sup>
      9
     </sup>
     &lt;= target &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 240 -->
<pre>/*
 * @lc app=leetcode id=240 lang=cpp
 *
 * [240] Search a 2D Matrix II
 */

// @lc code=start
class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {
        int m=matrix.size(),n=matrix[0].size(),r=0,c=n-1;
        while(r&lt;m &amp;&amp; c&gt;=0){
            if(matrix[r][c]==target) return true;
            matrix[r][c] &gt; target ? c--:r++;
        }
        return false;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 241. Different Ways to Add Parentheses
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    expression
   </code>
   of numbers and operators, return
   <em>
    all possible results from computing all the different possible ways to group numbers and operators
   </em>
   . You may return the answer in
   <strong>
    any order
   </strong>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> expression = "2-1-1"
<strong>Output:</strong> [0,2]
<strong>Explanation:</strong>
((2-1)-1) = 0 
(2-(1-1)) = 2
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> expression = "2*3-4*5"
<strong>Output:</strong> [-34,-14,-10,-10,10]
<strong>Explanation:</strong>
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= expression.length &lt;= 20
    </code>
   </li>
   <li>
    <code>
     expression
    </code>
    consists of digits and the operator
    <code>
     '+'
    </code>
    ,
    <code>
     '-'
    </code>
    , and
    <code>
     '*'
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 241 -->
<pre>/*
 * @lc app=leetcode id=241 lang=cpp
 *
 * [241] Different Ways to Add Parentheses
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; diffWaysToCompute(string expression) {

    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 242. Valid Anagram
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two strings
   <code>
    s
   </code>
   and
   <code>
    t
   </code>
   , return
   <code>
    true
   </code>
   <em>
    if
   </em>
   <code>
    t
   </code>
   <em>
    is an anagram of
   </em>
   <code>
    s
   </code>
   <em>
    , and
   </em>
   <code>
    false
   </code>
   <em>
    otherwise
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "anagram", t = "nagaram"
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "rat", t = "car"
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length, t.length &lt;= 5 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    and
    <code>
     t
    </code>
    consist of lowercase English letters.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   What if the inputs contain Unicode characters? How would you adapt your solution to such a case?
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 242 -->
<pre>/*
 * @lc app=leetcode id=242 lang=cpp
 *
 * [242] Valid Anagram
 */

// @lc code=start
class Solution {
public:
    bool isAnagram(string s, string t) {
        sort(s.begin(), s.end());
        sort(t.begin(), t.end());
        return s==t;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 258. Add Digits
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer
   <code>
    num
   </code>
   , repeatedly add all its digits until the result has only one digit, and return it.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = 38
<strong>Output:</strong> 2
<strong>Explanation:</strong> The process is
38 --&gt; 3 + 8 --&gt; 11
11 --&gt; 1 + 1 --&gt; 2 
Since 2 has only one digit, return it.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = 0
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= num &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   Could you do it without any loop/recursion in
   <code>
    O(1)
   </code>
   runtime?
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 258 -->
<pre>/*
 * @lc app=leetcode id=258 lang=cpp
 *
 * [258] Add Digits
 */

// @lc code=start
class Solution {
public:
    int addDigits(int num) {
        /*
        while(num&gt;=10){
            string s = to_string(num);
            num=0;
            for(int i=0; i&lt;s.length(); i++){
                num=num+s[i]-&#x27;0&#x27;;
            }
        }
        return num;
        */
       if(num==0) return 0;
       else if(num%9==0) return 9;
       else return num%9;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 260. Single Number III
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   , in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in
   <strong>
    any order
   </strong>
   .
  </p>
  <p>
   You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,1,3,2,5]
<strong>Output:</strong> [3,5]
<strong>Explanation: </strong> [5, 3] is also a valid answer.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [-1,0]
<strong>Output:</strong> [-1,0]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [0,1]
<strong>Output:</strong> [1,0]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     2 &lt;= nums.length &lt;= 3 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= nums[i] &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
   <li>
    Each integer in
    <code>
     nums
    </code>
    will appear twice, only two integers will appear once.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 260 -->
<pre>/*
 * @lc app=leetcode id=260 lang=cpp
 *
 * [260] Single Number III
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) {
        long long ans=nums[0];
        for(int i=1; i&lt;nums.size(); i++){
            ans=ans^nums[i];
        }
        int x=0,y=0;
        long long mask=ans &amp; (-ans);
        for(int i=0; i&lt;nums.size(); i++){
            if((nums[i] &amp; mask )== 0) x=x^nums[i];
            else y=y^nums[i];
        }
        return {x,y};
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 263. Ugly Number
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   An
   <strong>
    ugly number
   </strong>
   is a positive integer whose prime factors are limited to
   <code>
    2
   </code>
   ,
   <code>
    3
   </code>
   , and
   <code>
    5
   </code>
   .
  </p>
  <p>
   Given an integer
   <code>
    n
   </code>
   , return
   <code>
    true
   </code>
   <em>
    if
   </em>
   <code>
    n
   </code>
   <em>
    is an
    <strong>
     ugly number
    </strong>
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 6
<strong>Output:</strong> true
<strong>Explanation:</strong> 6 = 2 × 3</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 8
<strong>Output:</strong> true
<strong>Explanation:</strong> 8 = 2 × 2 × 2
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 14
<strong>Output:</strong> false
<strong>Explanation:</strong> 14 is not ugly since it includes the prime factor 7.
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1
<strong>Output:</strong> true
<strong>Explanation:</strong> 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= n &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 263 -->
<pre>/*
 * @lc app=leetcode id=263 lang=cpp
 *
 * [263] Ugly Number
 */

// @lc code=start
class Solution {
public:
    bool isUgly(int k) {
        if(k&lt;=0) return false;
        if(k&lt;=2) return true;
        for(int i=2;i&lt;6;i++){
            while(k%i==0) k=k/i;
        }
        return k==1;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 264. Ugly Number II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   An
   <strong>
    ugly number
   </strong>
   is a positive integer whose prime factors are limited to
   <code>
    2
   </code>
   ,
   <code>
    3
   </code>
   , and
   <code>
    5
   </code>
   .
  </p>
  <p>
   Given an integer
   <code>
    n
   </code>
   , return
   <em>
    the
   </em>
   <code>
    n
    <sup>
     th
    </sup>
   </code>
   <em>
    <strong>
     ugly number
    </strong>
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 10
<strong>Output:</strong> 12
<strong>Explanation:</strong> [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1
<strong>Output:</strong> 1
<strong>Explanation:</strong> 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 1690
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 264 -->
<pre>/*
 * @lc app=leetcode id=264 lang=cpp
 *
 * [264] Ugly Number II
 */

// @lc code=start
class Solution {
public:
    int nthUglyNumber(int n) {
        if(n&lt;=0) return 0;
        if(n==1) return 1;
        vector&lt;int&gt;k(n);
        k[0]=1;
        int t2=0,t3=0,t5=0;
        for(int i=1;i&lt;n;i++){
            k[i]=min({k[t2]*2,k[t3]*3,k[t5]*5});
            if(k[i]==k[t2]*2) t2++;
            if(k[i]==k[t3]*3) t3++;
            if(k[i]==k[t5]*5) t5++;
        }
        return k[n-1];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 273. Integer to English Words
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Convert a non-negative integer
   <code>
    num
   </code>
   to its English words representation.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = 123
<strong>Output:</strong> "One Hundred Twenty Three"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = 12345
<strong>Output:</strong> "Twelve Thousand Three Hundred Forty Five"
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = 1234567
<strong>Output:</strong> "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = 1234567891
<strong>Output:</strong> "One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= num &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 273 -->
<pre>/*
 * @lc app=leetcode id=273 lang=cpp
 *
 * [273] Integer to English Words
 */

// @lc code=start
class Solution {
public:
    string ones[20] = {&quot;&quot;, &quot; One&quot;, &quot; Two&quot;, &quot; Three&quot;, &quot; Four&quot;, &quot; Five&quot;, &quot; Six&quot;, &quot; Seven&quot;, &quot; Eight&quot;, &quot; Nine&quot;, &quot; Ten&quot;, &quot; Eleven&quot;, &quot; Twelve&quot;, &quot; Thirteen&quot;, &quot; Fourteen&quot;, &quot; Fifteen&quot;, &quot; Sixteen&quot;, &quot; Seventeen&quot;, &quot; Eighteen&quot;, &quot; Nineteen&quot;};
    string tens[10] = {&quot;&quot;, &quot; Ten&quot;, &quot; Twenty&quot;, &quot; Thirty&quot;, &quot; Forty&quot;, &quot; Fifty&quot;, &quot; Sixty&quot;, &quot; Seventy&quot;, &quot; Eighty&quot;, &quot; Ninety&quot;};
    string thousands[4] = {&quot;&quot;, &quot; Thousand&quot;, &quot; Million&quot;, &quot; Billion&quot;};
    string find(int num){
        if(num&lt;20) return ones[num];
        else if(num&lt;100) return tens[num/10] + find(num%10);
        else if(num &lt; 1000) return ones[num/100] + &quot; Hundred&quot; + find(num%100);
        for(int i=3;i&gt;=0;i--){
            if(num&gt;=pow(1000,i)) return find(num/pow(1000,i)) + thousands[i] + find(num% (int) pow(1000,i));
        }
        return &quot;&quot;;
    }
    string numberToWords(int num) {
        if(num==0) return &quot;Zero&quot;;
        return find(num).substr(1);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 274. H-Index
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of integers
   <code>
    citations
   </code>
   where
   <code>
    citations[i]
   </code>
   is the number of citations a researcher received for their
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   paper, return compute the researcher's
   <code>
    h
   </code>
   <strong>
    -index
   </strong>
   .
  </p>
  <p>
   According to the
   <a href="https://en.wikipedia.org/wiki/H-index" target="_blank">
    definition of h-index on Wikipedia
   </a>
   : A scientist has an index
   <code>
    h
   </code>
   if
   <code>
    h
   </code>
   of their
   <code>
    n
   </code>
   papers have at least
   <code>
    h
   </code>
   citations each, and the other
   <code>
    n − h
   </code>
   papers have no more than
   <code>
    h
   </code>
   citations each.
  </p>
  <p>
   If there are several possible values for
   <code>
    h
   </code>
   , the maximum one is taken as the
   <code>
    h
   </code>
   <strong>
    -index
   </strong>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> citations = [3,0,6,1,5]
<strong>Output:</strong> 3
<strong>Explanation:</strong> [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.
Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> citations = [1,3,1]
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == citations.length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 5000
    </code>
   </li>
   <li>
    <code>
     0 &lt;= citations[i] &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 274 -->
<pre>/*
 * @lc app=leetcode id=274 lang=cpp
 *
 * [274] H-Index
 */

// @lc code=start
class Solution {
public:
int hIndex(vector&lt;int&gt;&amp; citations) {
    sort(citations.begin(), citations.end());
    
    int start = 0,end=citations.size()-1;
    int n=citations.size();
    while (start &lt;= end){
        int mid = (start +end)/2;
        if(citations[n-mid-1]&gt;=mid+1) start=mid+1;
        else end=mid-1;
    }
    return start;
}
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 275. H-Index II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of integers
   <code>
    citations
   </code>
   where
   <code>
    citations[i]
   </code>
   is the number of citations a researcher received for their
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   paper and
   <code>
    citations
   </code>
   is sorted in an
   <strong>
    ascending order
   </strong>
   , return compute the researcher's
   <code>
    h
   </code>
   <strong>
    -index
   </strong>
   .
  </p>
  <p>
   According to the
   <a href="https://en.wikipedia.org/wiki/H-index" target="_blank">
    definition of h-index on Wikipedia
   </a>
   : A scientist has an index
   <code>
    h
   </code>
   if
   <code>
    h
   </code>
   of their
   <code>
    n
   </code>
   papers have at least
   <code>
    h
   </code>
   citations each, and the other
   <code>
    n − h
   </code>
   papers have no more than
   <code>
    h
   </code>
   citations each.
  </p>
  <p>
   If there are several possible values for
   <code>
    h
   </code>
   , the maximum one is taken as the
   <code>
    h
   </code>
   <strong>
    -index
   </strong>
   .
  </p>
  <p>
   You must write an algorithm that runs in logarithmic time.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> citations = [0,1,3,5,6]
<strong>Output:</strong> 3
<strong>Explanation:</strong> [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.
Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> citations = [1,2,100]
<strong>Output:</strong> 2
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == citations.length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= citations[i] &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     citations
    </code>
    is sorted in
    <strong>
     ascending order
    </strong>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 275 -->
<pre>/*
 * @lc app=leetcode id=275 lang=cpp
 *
 * [275] H-Index II
 */

// @lc code=start
class Solution {
public:
    int hIndex(vector&lt;int&gt;&amp; citations) {
        int start = 0,end=citations.size()-1;
        int n=citations.size();
        while (start &lt;= end){
            int mid = (start +end)/2;
            if(citations[n-mid-1]&gt;=mid+1) start=mid+1;
            else end=mid-1;
        }
        return start;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 278. First Bad Version
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.
  </p>
  <p>
   Suppose you have
   <code>
    n
   </code>
   versions
   <code>
    [1, 2, ..., n]
   </code>
   and you want to find out the first bad one, which causes all the following ones to be bad.
  </p>
  <p>
   You are given an API
   <code>
    bool isBadVersion(version)
   </code>
   which returns whether
   <code>
    version
   </code>
   is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 5, bad = 4
<strong>Output:</strong> 4
<strong>Explanation:</strong>
call isBadVersion(3) -&gt; false
call isBadVersion(5) -&gt; true
call isBadVersion(4) -&gt; true
Then 4 is the first bad version.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1, bad = 1
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= bad &lt;= n &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 278 -->
<pre>/*
 * @lc app=leetcode id=278 lang=cpp
 *
 * [278] First Bad Version
 */

// @lc code=start
// The API isBadVersion is defined for you.
// bool isBadVersion(int version);

class Solution {
public:
    int firstBadVersion(int n) {
        int start=0,end=n;
        while(start&lt;end){
            int mid = (start)/2+(end)/2;
            if(isBadVersion(mid)){
                end=mid;
            }
            else{
                start=mid+1;
            }
        }
        return start;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 279. Perfect Squares
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer
   <code>
    n
   </code>
   , return
   <em>
    the least number of perfect square numbers that sum to
   </em>
   <code>
    n
   </code>
   .
  </p>
  <p>
   A
   <strong>
    perfect square
   </strong>
   is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example,
   <code>
    1
   </code>
   ,
   <code>
    4
   </code>
   ,
   <code>
    9
   </code>
   , and
   <code>
    16
   </code>
   are perfect squares while
   <code>
    3
   </code>
   and
   <code>
    11
   </code>
   are not.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 12
<strong>Output:</strong> 3
<strong>Explanation:</strong> 12 = 4 + 4 + 4.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 13
<strong>Output:</strong> 2
<strong>Explanation:</strong> 13 = 4 + 9.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 279 -->
<pre>/*
 * @lc app=leetcode id=279 lang=cpp
 *
 * [279] Perfect Squares
 */

// @lc code=start
class Solution {
public:
    int numSquares(int n) {
        if(n&lt;=2) return n;
        vector&lt;long long&gt;dp(n+1,INT_MAX);
        dp[0]=0;
        dp[1]=1;
        for(int i=2;i&lt;n+1;i++){
            for(int j=1;j&lt;=i/2;j++){
                if(i-j*j&gt;=0)
                dp[i]=min(dp[i],dp[i-(j*j)]+1);
            }
        }
        return dp[n];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 282. Expression Add Operators
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    num
   </code>
   that contains only digits and an integer
   <code>
    target
   </code>
   , return
   <em>
    all possibilities to add the binary operators
   </em>
   <code>
    '+'
   </code>
   ,
   <code>
    '-'
   </code>
   ,
   <em>
    or
   </em>
   <code>
    '*'
   </code>
   <em>
    between the digits of
   </em>
   <code>
    num
   </code>
   <em>
    so that the resultant expression evaluates to the
   </em>
   <code>
    target
   </code>
   <em>
    value
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = "123", target = 6
<strong>Output:</strong> ["1*2*3","1+2+3"]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = "232", target = 8
<strong>Output:</strong> ["2*3+2","2+3*2"]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = "105", target = 5
<strong>Output:</strong> ["1*0+5","10-5"]
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = "00", target = 0
<strong>Output:</strong> ["0*0","0+0","0-0"]
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = "3456237490", target = 9191
<strong>Output:</strong> []
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= num.length &lt;= 10
    </code>
   </li>
   <li>
    <code>
     num
    </code>
    consists of only digits.
   </li>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= target &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 282 -->
<pre>/*
 * @lc app=leetcode id=282 lang=cpp
 *
 * [282] Expression Add Operators
 */

// @lc code=start
class Solution {
public:
    vector&lt;string&gt; addOperators(string num, int target) {
        backtrack(string num,int)
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 283. Move Zeroes
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   , move all
   <code>
    0
   </code>
   's to the end of it while maintaining the relative order of the non-zero elements.
  </p>
  <p>
   <strong>
    Note
   </strong>
   that you must do this in-place without making a copy of the array.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [0,1,0,3,12]
<strong>Output:</strong> [1,3,12,0,0]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [0]
<strong>Output:</strong> [0]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= nums[i] &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow up:
  </strong>
  Could you minimize the total number of operations done?
 </div>
</div>
</body></html>
<!-- Solution for Question 283 -->
<pre>/*
 * @lc app=leetcode id=283 lang=cpp
 *
 * [283] Move Zeroes
 */

// @lc code=start
class Solution {
public:
    void moveZeroes(vector&lt;int&gt;&amp; nums) {
        int count=0;
        for(int i=0;i&lt;nums.size();i++){
            if(nums[i]==0 &amp;&amp; count&lt; nums.size()){
                nums.push_back(0);
                nums.erase(nums.begin()+i);
                i--;
                count++;
            }
        }
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 287. Find the Duplicate Number
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of integers
   <code>
    nums
   </code>
   containing
   <code>
    n + 1
   </code>
   integers where each integer is in the range
   <code>
    [1, n]
   </code>
   inclusive.
  </p>
  <p>
   There is only
   <strong>
    one repeated number
   </strong>
   in
   <code>
    nums
   </code>
   , return
   <em>
    this repeated number
   </em>
   .
  </p>
  <p>
   You must solve the problem
   <strong>
    without
   </strong>
   modifying the array
   <code>
    nums
   </code>
   and uses only constant extra space.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,3,4,2,2]
<strong>Output:</strong> 2
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,1,3,4,2]
<strong>Output:</strong> 3
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,1]
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,1,2]
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     nums.length == n + 1
    </code>
   </li>
   <li>
    <code>
     1 &lt;= nums[i] &lt;= n
    </code>
   </li>
   <li>
    All the integers in
    <code>
     nums
    </code>
    appear only
    <strong>
     once
    </strong>
    except for
    <strong>
     precisely one integer
    </strong>
    which appears
    <strong>
     two or more
    </strong>
    times.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <b>
    Follow up:
   </b>
  </p>
  <ul>
   <li>
    How can we prove that at least one duplicate number must exist in
    <code>
     nums
    </code>
    ?
   </li>
   <li>
    Can you solve the problem in linear runtime complexity?
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 287 -->
<pre>/*
 * @lc app=leetcode id=287 lang=cpp
 *
 * [287] Find the Duplicate Number
 */

// @lc code=start
class Solution {
public:
    int findDuplicate(vector&lt;int&gt;&amp; nums) {
        map&lt;int,int&gt;m;
        for(int i=0; i&lt;nums.size();i++) {
            m[nums[i]]++;
            if(m[nums[i]]&gt;1)
            {
                return nums[i];
            }
        }
        return -1;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 290. Word Pattern
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a
   <code>
    pattern
   </code>
   and a string
   <code>
    s
   </code>
   , find if
   <code>
    s
   </code>
   follows the same pattern.
  </p>
  <p>
   Here
   <b>
    follow
   </b>
   means a full match, such that there is a bijection between a letter in
   <code>
    pattern
   </code>
   and a
   <b>
    non-empty
   </b>
   word in
   <code>
    s
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> pattern = "abba", s = "dog cat cat dog"
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> pattern = "abba", s = "dog cat cat fish"
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> pattern = "aaaa", s = "dog cat cat dog"
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> pattern = "abba", s = "dog dog dog dog"
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= pattern.length &lt;= 300
    </code>
   </li>
   <li>
    <code>
     pattern
    </code>
    contains only lower-case English letters.
   </li>
   <li>
    <code>
     1 &lt;= s.length &lt;= 3000
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    contains only lower-case English letters and spaces
    <code>
     ' '
    </code>
    .
   </li>
   <li>
    <code>
     s
    </code>
    <strong>
     does not contain
    </strong>
    any leading or trailing spaces.
   </li>
   <li>
    All the words in
    <code>
     s
    </code>
    are separated by a
    <strong>
     single space
    </strong>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 290 -->
<pre>/*
 * @lc app=leetcode id=290 lang=cpp
 *
 * [290] Word Pattern
 */

// @lc code=start
class Solution {
public:
    bool wordPattern(string pattern, string s) {
        int space=0;
        s=s+&#x27; &#x27;;
        int j=0;
        map&lt;char,string&gt;m1;
        map&lt;string,char&gt;m2;
        string temp=&quot;&quot;;
        for(int i=0; i&lt;s.length(); i++){
            if(s[i]==&#x27; &#x27;){
                space++;
                cout&lt;&lt;temp&lt;&lt;j&lt;&lt;endl;
                if(m1.find(pattern[j])==m1.end() &amp;&amp; m2.find(temp)==m2.end()){
                    m1[pattern[j]]=temp;
                    m2[temp]=pattern[j];
                }
                else{
                    if(m1[pattern[j]]!=temp || m2[temp]!=pattern[j])return false;
                }
                j++;
                temp=&quot;&quot;;
            }
            else{
                temp=temp+s[i];
            }
        }
        return space==pattern.length()?true:false;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 292. Nim Game
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are playing the following Nim Game with your friend:
  </p>
  <ul>
   <li>
    Initially, there is a heap of stones on the table.
   </li>
   <li>
    You and your friend will alternate taking turns, and
    <strong>
     you go first
    </strong>
    .
   </li>
   <li>
    On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.
   </li>
   <li>
    The one who removes the last stone is the winner.
   </li>
  </ul>
  <p>
   Given
   <code>
    n
   </code>
   , the number of stones in the heap, return
   <code>
    true
   </code>
   <em>
    if you can win the game assuming both you and your friend play optimally, otherwise return
   </em>
   <code>
    false
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 4
<strong>Output:</strong> false
<strong>Explanation:</strong> These are the possible outcomes:
1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.
2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.
3. You remove 3 stones. Your friend removes the last stone. Your friend wins.
In all outcomes, your friend wins.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 2
<strong>Output:</strong> true
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 292 -->
<pre>/*
 * @lc app=leetcode id=292 lang=cpp
 *
 * [292] Nim Game
 */

// @lc code=start
class Solution {
public:
    bool canWinNim(int n) {
        return n%4;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 295. Find Median from Data Stream
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   The
   <strong>
    median
   </strong>
   is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.
  </p>
  <ul>
   <li>
    For example, for
    <code>
     arr = [2,3,4]
    </code>
    , the median is
    <code>
     3
    </code>
    .
   </li>
   <li>
    For example, for
    <code>
     arr = [2,3]
    </code>
    , the median is
    <code>
     (2 + 3) / 2 = 2.5
    </code>
    .
   </li>
  </ul>
  <p>
   Implement the MedianFinder class:
  </p>
  <ul>
   <li>
    <code>
     MedianFinder()
    </code>
    initializes the
    <code>
     MedianFinder
    </code>
    object.
   </li>
   <li>
    <code>
     void addNum(int num)
    </code>
    adds the integer
    <code>
     num
    </code>
    from the data stream to the data structure.
   </li>
   <li>
    <code>
     double findMedian()
    </code>
    returns the median of all elements so far. Answers within
    <code>
     10
     <sup>
      -5
     </sup>
    </code>
    of the actual answer will be accepted.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input</strong>
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
<strong>Output</strong>
[null, null, null, 1.5, null, 2.0]

<strong>Explanation</strong>
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     -10
     <sup>
      5
     </sup>
     &lt;= num &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    There will be at least one element in the data structure before calling
    <code>
     findMedian
    </code>
    .
   </li>
   <li>
    At most
    <code>
     5 * 10
     <sup>
      4
     </sup>
    </code>
    calls will be made to
    <code>
     addNum
    </code>
    and
    <code>
     findMedian
    </code>
    .
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
  </p>
  <ul>
   <li>
    If all integer numbers from the stream are in the range
    <code>
     [0, 100]
    </code>
    , how would you optimize your solution?
   </li>
   <li>
    If
    <code>
     99%
    </code>
    of all integer numbers from the stream are in the range
    <code>
     [0, 100]
    </code>
    , how would you optimize your solution?
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 295 -->
<pre>/*
 * @lc app=leetcode id=295 lang=cpp
 *
 * [295] Find Median from Data Stream
 */

// @lc code=start
class MedianFinder {
public:
    vector&lt;int&gt;a;
    MedianFinder() {

    }

    void addNum(int num) {
        a.insert(lower_bound(a.begin(), a.end(), num),num);
    }

    double findMedian() {
        int n=a.size()/2;
        if(a.size()%2==0){
            return (double)(a[n]+a[n-1])/2;
        }
        return a[a.size()/2];
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj-&gt;addNum(num);
 * double param_2 = obj-&gt;findMedian();
 */
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 297. Serialize and Deserialize Binary Tree
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.
  </p>
  <p>
   Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.
  </p>
  <p>
   <strong>
    Clarification:
   </strong>
   The input/output format is the same as
   <a href="https://bishalsarang.github.io/faq/#binary-tree">
    how LeetCode serializes a binary tree
   </a>
   . You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/serdeser.jpg" style="width: 442px; height: 324px;"/>
  <pre><strong>Input:</strong> root = [1,2,3,null,null,4,5]
<strong>Output:</strong> [1,2,3,null,null,4,5]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1]
<strong>Output:</strong> [1]
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1,2]
<strong>Output:</strong> [1,2]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [0, 10
     <sup>
      4
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     -1000 &lt;= Node.val &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 297 -->
<pre>/*
 * @lc app=leetcode id=297 lang=cpp
 *
 * [297] Serialize and Deserialize Binary Tree
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:

    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        
    }
};

// Your Codec object will be instantiated and called as such:
// Codec ser, deser;
// TreeNode* ans = deser.deserialize(ser.serialize(root));
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 300. Longest Increasing Subsequence
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   , return the length of the longest strictly increasing subsequence.
  </p>
  <p>
   A
   <strong>
    subsequence
   </strong>
   is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example,
   <code>
    [3,6,2,7]
   </code>
   is a subsequence of the array
   <code>
    [0,3,1,6,2,2,7]
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [10,9,2,5,3,7,101,18]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [0,1,0,3,2,3]
<strong>Output:</strong> 4
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [7,7,7,7,7,7,7]
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 2500
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= nums[i] &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
  <p>
  </p>
  <p>
   <b>
    Follow up:
   </b>
   Can you come up with an algorithm that runs in
   <code>
    O(n log(n))
   </code>
   time complexity?
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 300 -->
<pre>/*
 * @lc app=leetcode id=300 lang=cpp
 *
 * [300] Longest Increasing Subsequence
 */

// @lc code=start
class Solution {
public:
    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {

        vector&lt;int&gt;lis(nums.size()+1,1);
        int ans=1;
        for(int i=0; i&lt;nums.size(); i++){
            for(int j=0; j&lt;i; j++){
                if(nums[i]&gt;nums[j])lis[i] = max(lis[i],1+lis[j]);
            }
            ans=max(ans,lis[i]);
        }

        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 304. Range Sum Query 2D - Immutable
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a 2D matrix
   <code>
    matrix
   </code>
   , handle multiple queries of the following type:
  </p>
  <ul>
   <li>
    Calculate the
    <strong>
     sum
    </strong>
    of the elements of
    <code>
     matrix
    </code>
    inside the rectangle defined by its
    <strong>
     upper left corner
    </strong>
    <code>
     (row1, col1)
    </code>
    and
    <strong>
     lower right corner
    </strong>
    <code>
     (row2, col2)
    </code>
    .
   </li>
  </ul>
  <p>
   Implement the NumMatrix class:
  </p>
  <ul>
   <li>
    <code>
     NumMatrix(int[][] matrix)
    </code>
    Initializes the object with the integer matrix
    <code>
     matrix
    </code>
    .
   </li>
   <li>
    <code>
     int sumRegion(int row1, int col1, int row2, int col2)
    </code>
    Returns the
    <strong>
     sum
    </strong>
    of the elements of
    <code>
     matrix
    </code>
    inside the rectangle defined by its
    <strong>
     upper left corner
    </strong>
    <code>
     (row1, col1)
    </code>
    and
    <strong>
     lower right corner
    </strong>
    <code>
     (row2, col2)
    </code>
    .
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/sum-grid.jpg" style="width: 415px; height: 415px;"/>
  <pre><strong>Input</strong>
["NumMatrix", "sumRegion", "sumRegion", "sumRegion"]
[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]
<strong>Output</strong>
[null, 8, 11, 12]

<strong>Explanation</strong>
NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)
numMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)
numMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == matrix.length
    </code>
   </li>
   <li>
    <code>
     n == matrix[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m, n &lt;= 200
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      5
     </sup>
     &lt;= matrix[i][j] &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= row1 &lt;= row2 &lt; m
    </code>
   </li>
   <li>
    <code>
     0 &lt;= col1 &lt;= col2 &lt; n
    </code>
   </li>
   <li>
    At most
    <code>
     10
     <sup>
      4
     </sup>
    </code>
    calls will be made to
    <code>
     sumRegion
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 304 -->
<pre>/*
 * @lc app=leetcode id=304 lang=cpp
 *
 * [304] Range Sum Query 2D - Immutable
 */

// @lc code=start
class NumMatrix {
public:
    int row, col;
    vector&lt;vector&lt;int&gt;&gt; sums;
    NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        row = matrix.size();
        col = row&gt;0 ? matrix[0].size() : 0;
        sums = vector&lt;vector&lt;int&gt;&gt;(row+1, vector&lt;int&gt;(col+1, 0));
        for(int i=1; i&lt;=row; i++) {
            for(int j=1; j&lt;=col; j++) {
                sums[i][j] = matrix[i-1][j-1] +
                             sums[i-1][j] + sums[i][j-1] - sums[i-1][j-1] ;
            }
        }
    }

    int sumRegion(int row1, int col1, int row2, int col2) {
        return sums[row2+1][col2+1] - sums[row2+1][col1]  - sums[row1][col2+1] + sums[row1][col1];
    }
};

/**
 * Your NumMatrix object will be instantiated and called as such:
 * NumMatrix* obj = new NumMatrix(matrix);
 * int param_1 = obj-&gt;sumRegion(row1,col1,row2,col2);
 */
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 306. Additive Number
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Additive number is a string whose digits can form additive sequence.
  </p>
  <p>
   A valid additive sequence should contain
   <b>
    at least
   </b>
   three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.
  </p>
  <p>
   Given a string containing only digits
   <code>
    '0'-'9'
   </code>
   , write a function to determine if it's an additive number.
  </p>
  <p>
   <b>
    Note:
   </b>
   Numbers in the additive sequence
   <b>
    cannot
   </b>
   have leading zeros, so sequence
   <code>
    1, 2, 03
   </code>
   or
   <code>
    1, 02, 3
   </code>
   is invalid.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> "112358"
<strong>Output:</strong> true
<strong>Explanation:</strong> The digits can form an additive sequence: 1, 1, 2, 3, 5, 8. 
             1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> "199100199"
<strong>Output:</strong> true
<strong>Explanation:</strong> The additive sequence is: 1, 99, 100, 199. 
             1 + 99 = 100, 99 + 100 = 199
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <font face="monospace">
     <code>
      num
     </code>
    </font>
    consists only of digits
    <code>
     '0'-'9'
    </code>
    .
   </li>
   <li>
    <code>
     1 &lt;= num.length &lt;= 35
    </code>
   </li>
  </ul>
  <p>
   <b>
    Follow up:
   </b>
   <br/>
   How would you handle overflow for very large input integers?
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 306 -->
<pre>/*
 * @lc app=leetcode id=306 lang=cpp
 *
 * [306] Additive Number
 */

// @lc code=start
class Solution {
public:
int val=0;
    void find(string s,int index,string ans,long long a,long long b){
        if(index==s.length()-1){
            val=1;
            return ;
        }
        for(int i=1;i&lt;s.length()-index;i++){
            string select = s.substr(index,i);
            cout&lt;&lt;select&lt;&lt;&#x27; &#x27;;
            if((select[0]!=&#x27;0&#x27; || select.length()==1) &amp;&amp; select.length()&lt;=10) {
            int x=stoll(select);
            if(a==-1 &amp;&amp; i+index!=s.length()-1){
                find(s,i+index,ans+&#x27; &#x27;+to_string(x),x,b);
            }
            else if(a!=-1&amp;&amp;b==-1 &amp;&amp; i+index!=s.length()-1){
                find(s,i+index,ans+&#x27; &#x27;+to_string(x),a,x);
            }
            else{
                if(a+b==x){
                    find(s,i+index,ans+&#x27; &#x27;+to_string(x),b,x);
                }
            }
            }
        }

    }
    bool isAdditiveNumber(string num) {
        if(num.length()&lt;=2) return false;
        find(num+&#x27;0&#x27;,0,&quot;&quot;,-1,-1);
        return val;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 307. Range Sum Query - Mutable
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   , handle multiple queries of the following types:
  </p>
  <ol>
   <li>
    <strong>
     Update
    </strong>
    the value of an element in
    <code>
     nums
    </code>
    .
   </li>
   <li>
    Calculate the
    <strong>
     sum
    </strong>
    of the elements of
    <code>
     nums
    </code>
    between indices
    <code>
     left
    </code>
    and
    <code>
     right
    </code>
    <strong>
     inclusive
    </strong>
    where
    <code>
     left &lt;= right
    </code>
    .
   </li>
  </ol>
  <p>
   Implement the
   <code>
    NumArray
   </code>
   class:
  </p>
  <ul>
   <li>
    <code>
     NumArray(int[] nums)
    </code>
    Initializes the object with the integer array
    <code>
     nums
    </code>
    .
   </li>
   <li>
    <code>
     void update(int index, int val)
    </code>
    <strong>
     Updates
    </strong>
    the value of
    <code>
     nums[index]
    </code>
    to be
    <code>
     val
    </code>
    .
   </li>
   <li>
    <code>
     int sumRange(int left, int right)
    </code>
    Returns the
    <strong>
     sum
    </strong>
    of the elements of
    <code>
     nums
    </code>
    between indices
    <code>
     left
    </code>
    and
    <code>
     right
    </code>
    <strong>
     inclusive
    </strong>
    (i.e.
    <code>
     nums[left] + nums[left + 1] + ... + nums[right]
    </code>
    ).
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input</strong>
["NumArray", "sumRange", "update", "sumRange"]
[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]
<strong>Output</strong>
[null, 9, null, 8]

<strong>Explanation</strong>
NumArray numArray = new NumArray([1, 3, 5]);
numArray.sumRange(0, 2); // return 1 + 3 + 5 = 9
numArray.update(1, 2);   // nums = [1, 2, 5]
numArray.sumRange(0, 2); // return 1 + 2 + 5 = 8
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 3 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -100 &lt;= nums[i] &lt;= 100
    </code>
   </li>
   <li>
    <code>
     0 &lt;= index &lt; nums.length
    </code>
   </li>
   <li>
    <code>
     -100 &lt;= val &lt;= 100
    </code>
   </li>
   <li>
    <code>
     0 &lt;= left &lt;= right &lt; nums.length
    </code>
   </li>
   <li>
    At most
    <code>
     3 * 10
     <sup>
      4
     </sup>
    </code>
    calls will be made to
    <code>
     update
    </code>
    and
    <code>
     sumRange
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 307 -->
<pre>/*
 * @lc app=leetcode id=307 lang=cpp
 *
 * [307] Range Sum Query - Mutable
 */

// @lc code=start
class NumArray {
public:
    NumArray(vector&lt;int&gt;&amp; nums) {

    }

    void update(int index, int val) {

    }

    int sumRange(int left, int right) {
        
    }
};

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray* obj = new NumArray(nums);
 * obj-&gt;update(index,val);
 * int param_2 = obj-&gt;sumRange(left,right);
 */
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 309. Best Time to Buy and Sell Stock with Cooldown
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an array
   <code>
    prices
   </code>
   where
   <code>
    prices[i]
   </code>
   is the price of a given stock on the
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   day.
  </p>
  <p>
   Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:
  </p>
  <ul>
   <li>
    After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).
   </li>
  </ul>
  <p>
   <strong>
    Note:
   </strong>
   You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> prices = [1,2,3,0,2]
<strong>Output:</strong> 3
<strong>Explanation:</strong> transactions = [buy, sell, cooldown, buy, sell]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> prices = [1]
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= prices.length &lt;= 5000
    </code>
   </li>
   <li>
    <code>
     0 &lt;= prices[i] &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 309 -->
<pre>/*
 * @lc app=leetcode id=309 lang=cpp
 *
 * [309] Best Time to Buy and Sell Stock with Cooldown
 */

// @lc code=start
class Solution {
public:
   int find(vector&lt;int&gt;&amp;prices,int i,bool buy,vector&lt;vector&lt;int&gt;&gt;&amp;dp)
    {
        if(i&gt;=prices.size())
        {
            return 0;
        }
        if(dp[i][buy]!=-1)
        {
            return dp[i][buy];
        }
        if(buy)
        {
            return dp[i][buy] = max(-prices[i]+find(prices,i+1,!buy,dp),find(prices,i+1,buy,dp));
        }
        else
        {
            return dp[i][buy] = max(prices[i]+find(prices,i+2,!buy,dp),find(prices,i+1,buy,dp));
        }
    }
    int maxProfit(vector&lt;int&gt;&amp; prices) {
       int n=prices.size();
        vector&lt;vector&lt;int&gt;&gt;dp(n,vector&lt;int&gt;(2,-1));
        return find(prices,0,1,dp);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 312. Burst Balloons
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given
   <code>
    n
   </code>
   balloons, indexed from
   <code>
    0
   </code>
   to
   <code>
    n - 1
   </code>
   . Each balloon is painted with a number on it represented by an array
   <code>
    nums
   </code>
   . You are asked to burst all the balloons.
  </p>
  <p>
   If you burst the
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   balloon, you will get
   <code>
    nums[i - 1] * nums[i] * nums[i + 1]
   </code>
   coins. If
   <code>
    i - 1
   </code>
   or
   <code>
    i + 1
   </code>
   goes out of bounds of the array, then treat it as if there is a balloon with a
   <code>
    1
   </code>
   painted on it.
  </p>
  <p>
   Return
   <em>
    the maximum coins you can collect by bursting the balloons wisely
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,1,5,8]
<strong>Output:</strong> 167
<strong>Explanation:</strong>
nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,5]
<strong>Output:</strong> 10
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == nums.length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 500
    </code>
   </li>
   <li>
    <code>
     0 &lt;= nums[i] &lt;= 100
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 312 -->
<pre>/*
 * @lc app=leetcode id=312 lang=cpp
 *
 * [312] Burst Balloons
 */

// @lc code=start
class Solution {
public:
    int maxCoins(vector&lt;int&gt;&amp; a) {
        a.push_back(1);
        a.insert(a.begin(),1);
        int n= a.size();
        vector&lt;vector&lt;int&gt;&gt;dp(n,vector&lt;int&gt;(n));
        for(int len=3;len&lt;=n;len++){
            for(int i=0;i+len&lt;=n;i++){
                int j=i+len-1;
                for(int k=i+1;k&lt;j;k++){
                    dp[i][j]=max(dp[i][j],dp[i][k]+dp[k][j]+a[i]*a[j]*a[k]);
                }
            }
        }
        return dp[0][n-1];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 313. Super Ugly Number
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   A
   <strong>
    super ugly number
   </strong>
   is a positive integer whose prime factors are in the array
   <code>
    primes
   </code>
   .
  </p>
  <p>
   Given an integer
   <code>
    n
   </code>
   and an array of integers
   <code>
    primes
   </code>
   , return
   <em>
    the
   </em>
   <code>
    n
    <sup>
     th
    </sup>
   </code>
   <em>
    <strong>
     super ugly number
    </strong>
   </em>
   .
  </p>
  <p>
   The
   <code>
    n
    <sup>
     th
    </sup>
   </code>
   <strong>
    super ugly number
   </strong>
   is
   <strong>
    guaranteed
   </strong>
   to fit in a
   <strong>
    32-bit
   </strong>
   signed integer.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 12, primes = [2,7,13,19]
<strong>Output:</strong> 32
<strong>Explanation:</strong> [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1, primes = [2,3,5]
<strong>Output:</strong> 1
<strong>Explanation:</strong> 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5].
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 10
     <sup>
      6
     </sup>
    </code>
   </li>
   <li>
    <code>
     1 &lt;= primes.length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     2 &lt;= primes[i] &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     primes[i]
    </code>
    is
    <strong>
     guaranteed
    </strong>
    to be a prime number.
   </li>
   <li>
    All the values of
    <code>
     primes
    </code>
    are
    <strong>
     unique
    </strong>
    and sorted in
    <strong>
     ascending order
    </strong>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 313 -->
<pre>/*
 * @lc app=leetcode id=313 lang=cpp
 *
 * [313] Super Ugly Number
 */

// @lc code=start
class Solution {
public:
    int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) {
        if(n&lt;=0) return 0;
        if(n==1) return 1;
        vector&lt;long long&gt;k(n);
        k[0]=1;
        vector&lt;int&gt;t(primes.size(),0);
        for(int i=1;i&lt;n;i++){
            long long minn=INT_MAX;
            for(int j=0;j&lt;primes.size();j++){
                minn=min(minn,k[t[j]]*primes[j]);
            }
            k[i]=minn;
            for(int j=0;j&lt;primes.size();j++){
                if(k[t[j]]*primes[j]==minn) t[j]++;
            }
        }
        return k[n-1];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 318. Maximum Product of Word Lengths
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string array
   <code>
    words
   </code>
   , return
   <em>
    the maximum value of
   </em>
   <code>
    length(word[i]) * length(word[j])
   </code>
   <em>
    where the two words do not share common letters
   </em>
   . If no such two words exist, return
   <code>
    0
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> words = ["abcw","baz","foo","bar","xtfn","abcdef"]
<strong>Output:</strong> 16
<strong>Explanation:</strong> The two words can be "abcw", "xtfn".
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> words = ["a","ab","abc","d","cd","bcd","abcd"]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The two words can be "ab", "cd".
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> words = ["a","aa","aaa","aaaa"]
<strong>Output:</strong> 0
<strong>Explanation:</strong> No such pair of words.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     2 &lt;= words.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     1 &lt;= words[i].length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     words[i]
    </code>
    consists only of lowercase English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 318 -->
<pre>/*
 * @lc app=leetcode id=318 lang=cpp
 *
 * [318] Maximum Product of Word Lengths
 */

// @lc code=start
class Solution {
public:
    int maxProduct(vector&lt;string&gt;&amp; words) {
        int maxx=0;
        for(int i = 0; i &lt; words.size();i++){
            map&lt;char,int&gt;m;
            int s1=words[i].length();
            for(char x: words[i]){
                m[x]++;
            }
            for(int j = i+1; j &lt; words.size();j++){
                int s2=words[j].length();
                int flag=1;
                for(char x: words[j]){
                    if(m[x]&gt;0){
                        flag=0;
                        break;
                    }
                }
                if(flag){
                    maxx=max(maxx,s1*s2);
                }
            }
        }
        return maxx;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 319. Bulb Switcher
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   There are
   <code>
    n
   </code>
   bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.
  </p>
  <p>
   On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   round, you toggle every
   <code>
    i
   </code>
   bulb. For the
   <code>
    n
    <sup>
     th
    </sup>
   </code>
   round, you only toggle the last bulb.
  </p>
  <p>
   Return
   <em>
    the number of bulbs that are on after
    <code>
     n
    </code>
    rounds
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/bulb.jpg" style="width: 421px; height: 321px;"/>
  <pre><strong>Input:</strong> n = 3
<strong>Output:</strong> 1
<strong>Explanation:</strong> At first, the three bulbs are [off, off, off].
After the first round, the three bulbs are [on, on, on].
After the second round, the three bulbs are [on, off, on].
After the third round, the three bulbs are [on, off, off]. 
So you should return 1 because there is only one bulb is on.</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 0
<strong>Output:</strong> 0
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= n &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 319 -->
<pre>/*
 * @lc app=leetcode id=319 lang=cpp
 *
 * [319] Bulb Switcher
 */

// @lc code=start
class Solution {
public:
    int bulbSwitch(int n) {
        //prime numbers cant be cosidereed
        //only number s rehed in oddd times are on others are off and those are only the sqrt numbers 
        return sqrt(n);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 322. Coin Change
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an integer array
   <code>
    coins
   </code>
   representing coins of different denominations and an integer
   <code>
    amount
   </code>
   representing a total amount of money.
  </p>
  <p>
   Return
   <em>
    the fewest number of coins that you need to make up that amount
   </em>
   . If that amount of money cannot be made up by any combination of the coins, return
   <code>
    -1
   </code>
   .
  </p>
  <p>
   You may assume that you have an infinite number of each kind of coin.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> coins = [1,2,5], amount = 11
<strong>Output:</strong> 3
<strong>Explanation:</strong> 11 = 5 + 5 + 1
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> coins = [2], amount = 3
<strong>Output:</strong> -1
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> coins = [1], amount = 0
<strong>Output:</strong> 0
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> coins = [1], amount = 1
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> coins = [1], amount = 2
<strong>Output:</strong> 2
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= coins.length &lt;= 12
    </code>
   </li>
   <li>
    <code>
     1 &lt;= coins[i] &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
   <li>
    <code>
     0 &lt;= amount &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 322 -->
<pre>/*
 * @lc app=leetcode id=322 lang=cpp
 *
 * [322] Coin Change
 */

// @lc code=start
class Solution {
public:
    int coinChange(vector&lt;int&gt;&amp; coins, int amount) {
        vector&lt;long long&gt;dp(amount+1,INT_MAX);
        dp[0]=0;
       //using dp template
       for(int i=1; i&lt;=amount; i++){
        for(int j=0; j&lt;coins.size(); j++){
            if(i&gt;=coins[j]){
                dp[i]=min(dp[i],dp[i-coins[j]]+1);
            }
        }
       }
       return dp[amount]==INT_MAX?-1:dp[amount];
    }

};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 324. Wiggle Sort II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   , reorder it such that
   <code>
    nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]...
   </code>
   .
  </p>
  <p>
   You may assume the input array always has a valid answer.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,5,1,1,6,4]
<strong>Output:</strong> [1,6,1,5,1,4]
<strong>Explanation:</strong> [1,4,1,5,1,6] is also accepted.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,3,2,2,3,1]
<strong>Output:</strong> [2,3,1,3,1,2]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 5 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= nums[i] &lt;= 5000
    </code>
   </li>
   <li>
    It is guaranteed that there will be an answer for the given input
    <code>
     nums
    </code>
    .
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow Up:
  </strong>
  Can you do it in
  <code>
   O(n)
  </code>
  time and/or
  <strong>
   in-place
  </strong>
  with
  <code>
   O(1)
  </code>
  extra space?
 </div>
</div>
</body></html>
<!-- Solution for Question 324 -->
<pre>/*
 * @lc app=leetcode id=324 lang=cpp
 *
 * [324] Wiggle Sort II
 */

// @lc code=start
class Solution {
public:
    void wiggleSort(vector&lt;int&gt;&amp; nums) {
        if(nums.size() == 1) return;
        priority_queue&lt;int&gt;pq;
        for(int x:nums){
            pq.push(x);
        }
        int i=1;
        while(!pq.empty() &amp;&amp; i&lt;nums.size()) {
            nums[i]=pq.top();
            cout&lt;&lt;i;
            i=i+2;
            pq.pop();
        }
        i=0;
        while(!pq.empty() &amp;&amp; i&lt;nums.size()) {
            nums[i]=pq.top();
            i=i+2;
            pq.pop();
        }
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 326. Power of Three
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer
   <code>
    n
   </code>
   , return
   <em>
    <code>
     true
    </code>
    if it is a power of three. Otherwise, return
    <code>
     false
    </code>
   </em>
   .
  </p>
  <p>
   An integer
   <code>
    n
   </code>
   is a power of three, if there exists an integer
   <code>
    x
   </code>
   such that
   <code>
    n == 3
    <sup>
     x
    </sup>
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 27
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 0
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 9
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 45
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= n &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow up:
  </strong>
  Could you solve it without loops/recursion?
 </div>
</div>
</body></html>
<!-- Solution for Question 326 -->
<pre>/*
 * @lc app=leetcode id=326 lang=cpp
 *
 * [326] Power of Three
 */

// @lc code=start
class Solution {
public:
    bool isPowerOfThree(int n) {
        int k=1;
        if(n==1) return true;
        while(pow(3,k)&lt;=n){
            if(pow(3,k)==n) return true;
            k++;
        }
        return false;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 329. Longest Increasing Path in a Matrix
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an
   <code>
    m x n
   </code>
   integers
   <code>
    matrix
   </code>
   , return
   <em>
    the length of the longest increasing path in
   </em>
   <code>
    matrix
   </code>
   .
  </p>
  <p>
   From each cell, you can either move in four directions: left, right, up, or down. You
   <strong>
    may not
   </strong>
   move
   <strong>
    diagonally
   </strong>
   or move
   <strong>
    outside the boundary
   </strong>
   (i.e., wrap-around is not allowed).
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/grid1(1).jpg" style="width: 242px; height: 242px;"/>
  <pre><strong>Input:</strong> matrix = [[9,9,4],[6,6,8],[2,1,1]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The longest increasing path is <code>[1, 2, 6, 9]</code>.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/tmp-grid.jpg" style="width: 253px; height: 253px;"/>
  <pre><strong>Input:</strong> matrix = [[3,4,5],[3,2,6],[2,2,1]]
<strong>Output:</strong> 4
<strong>Explanation: </strong>The longest increasing path is <code>[3, 4, 5, 6]</code>. Moving diagonally is not allowed.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> matrix = [[1]]
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == matrix.length
    </code>
   </li>
   <li>
    <code>
     n == matrix[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m, n &lt;= 200
    </code>
   </li>
   <li>
    <code>
     0 &lt;= matrix[i][j] &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 329 -->
<pre>/*
 * @lc app=leetcode id=329 lang=cpp
 *
 * [329] Longest Increasing Path in a Matrix
 */

// @lc code=start
class Solution {
public:
    int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; matrix,int posx,int posy,vector&lt;vector&lt;int&gt;&gt;&amp; h){
        if(h[posx][posy]!=-1) return h[posx][posy];
        vector&lt;int&gt;newx{0,0,1,-1};
        vector&lt;int&gt;newy{1,-1,0,0};
        int ans=0;
        for(int i=0;i&lt;4;i++){
            int x=newx[i]+posx;
            int y=newy[i]+posy;
            if(x&gt;=0 &amp;&amp; y&gt;=0 &amp;&amp; y&lt;matrix[0].size() &amp;&amp; x&lt;matrix.size()  &amp;&amp; matrix[x][y] &gt; matrix[posx][posy]){
                ans=max(ans,1+dfs(matrix,x,y,h));
            }
        }
        return h[posx][posy]=ans;
    }
    int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int ans = 0;
        vector&lt;vector&lt;int&gt;&gt;h(matrix.size(),vector&lt;int&gt;(matrix[0].size(),-1));
        for(int i = 0; i &lt; matrix.size();i++){
            for(int j = 0; j &lt; matrix[0].size();j++){
                ans = max(ans,1+dfs(matrix,i,j,h));
            }
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 331. Verify Preorder Serialization of a Binary Tree
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   One way to serialize a binary tree is to use
   <strong>
    preorder traversal
   </strong>
   . When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as
   <code>
    '#'
   </code>
   .
  </p>
  <img alt="" src="./output_files/pre-tree.jpg" style="width: 362px; height: 293px;"/>
  <p>
   For example, the above binary tree can be serialized to the string
   <code>
    "9,3,4,#,#,1,#,#,2,#,6,#,#"
   </code>
   , where
   <code>
    '#'
   </code>
   represents a null node.
  </p>
  <p>
   Given a string of comma-separated values
   <code>
    preorder
   </code>
   , return
   <code>
    true
   </code>
   if it is a correct preorder traversal serialization of a binary tree.
  </p>
  <p>
   It is
   <strong>
    guaranteed
   </strong>
   that each comma-separated value in the string must be either an integer or a character
   <code>
    '#'
   </code>
   representing null pointer.
  </p>
  <p>
   You may assume that the input format is always valid.
  </p>
  <ul>
   <li>
    For example, it could never contain two consecutive commas, such as
    <code>
     "1,,3"
    </code>
    .
   </li>
  </ul>
  <p>
   <strong>
    Note:
   </strong>
   You are not allowed to reconstruct the tree.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> preorder = "9,3,4,#,#,1,#,#,2,#,6,#,#"
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> preorder = "1,#"
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> preorder = "9,#,#,1"
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= preorder.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     preorder
    </code>
    consist of integers in the range
    <code>
     [0, 100]
    </code>
    and
    <code>
     '#'
    </code>
    separated by commas
    <code>
     ','
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 331 -->
<pre>/*
 * @lc app=leetcode id=331 lang=cpp
 *
 * [331] Verify Preorder Serialization of a Binary Tree
 */

// @lc code=start
class Solution {
public:
    bool isValidSerialization(string preorder) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 334. Increasing Triplet Subsequence
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   , return
   <code>
    true
   </code>
   <em>
    if there exists a triple of indices
   </em>
   <code>
    (i, j, k)
   </code>
   <em>
    such that
   </em>
   <code>
    i &lt; j &lt; k
   </code>
   <em>
    and
   </em>
   <code>
    nums[i] &lt; nums[j] &lt; nums[k]
   </code>
   . If no such indices exists, return
   <code>
    false
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3,4,5]
<strong>Output:</strong> true
<strong>Explanation:</strong> Any triplet where i &lt; j &lt; k is valid.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [5,4,3,2,1]
<strong>Output:</strong> false
<strong>Explanation:</strong> No triplet exists.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,1,5,0,4,6]
<strong>Output:</strong> true
<strong>Explanation:</strong> The triplet (3, 4, 5) is valid because nums[3] == 0 &lt; nums[4] == 4 &lt; nums[5] == 6.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 5 * 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= nums[i] &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow up:
  </strong>
  Could you implement a solution that runs in
  <code>
   O(n)
  </code>
  time complexity and
  <code>
   O(1)
  </code>
  space complexity?
 </div>
</div>
</body></html>
<!-- Solution for Question 334 -->
<pre>/*
 * @lc app=leetcode id=334 lang=cpp
 *
 * [334] Increasing Triplet Subsequence
 */

// @lc code=start
class Solution {
public:
    bool increasingTriplet(vector&lt;int&gt;&amp; nums) {
        int n=nums.size();
        if(n&lt;3)return false;
        int low=INT_MAX, mid=INT_MAX;
        for(int i=0; i&lt;n; i++){
            if(nums[i]&gt;mid) return true;
            else if(nums[i]&lt;low) low=nums[i];
            else if(nums[i]&lt;mid &amp;&amp; nums[i] &gt; low) mid=nums[i];
        }
        return false;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 337. House Robber III
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   The thief has found himself a new place for his thievery again. There is only one entrance to this area, called
   <code>
    root
   </code>
   .
  </p>
  <p>
   Besides the
   <code>
    root
   </code>
   , each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if
   <strong>
    two directly-linked houses were broken into on the same night
   </strong>
   .
  </p>
  <p>
   Given the
   <code>
    root
   </code>
   of the binary tree, return
   <em>
    the maximum amount of money the thief can rob
    <strong>
     without alerting the police
    </strong>
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/rob1-tree.jpg" style="width: 277px; height: 293px;"/>
  <pre><strong>Input:</strong> root = [3,2,3,null,3,null,1]
<strong>Output:</strong> 7
<strong>Explanation:</strong> Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/rob2-tree.jpg" style="width: 357px; height: 293px;"/>
  <pre><strong>Input:</strong> root = [3,4,5,1,3,null,1]
<strong>Output:</strong> 9
<strong>Explanation:</strong> Maximum amount of money the thief can rob = 4 + 5 = 9.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [1, 10
     <sup>
      4
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     0 &lt;= Node.val &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 337 -->
<pre>/*
 * @lc app=leetcode id=337 lang=cpp
 *
 * [337] House Robber III
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int rob(TreeNode* root) {
        queue&lt;TreeNode *&gt;q;
        q.push(root);
        vector&lt;int&gt;a;
        a.push_back(root-&gt;val);
        while(!q.empty()) {
            int count = q.size();
            int sum=0;
            while(count--){
                TreeNode* node = q.front();
                q.pop();
                if(node-&gt;left){
                    q.push(node-&gt;left);
                    sum+=node-&gt;left-&gt;val;
                }
                if(node-&gt;right){
                    q.push(node-&gt;right);
                    sum+=node-&gt;right-&gt;val;
                }
            }
            a.push_back(sum);
        }
        int n=a.size();
        vector&lt;int&gt;dp(n,0);
        dp[0]=a[0];
        dp[1]=max(a[1],a[0]);
        for(int i=2;i&lt;n;i++){
            dp[i]=max(dp[i-1],dp[i-2]+a[i]);
        }
        return dp[n-1];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 338. Counting Bits
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer
   <code>
    n
   </code>
   , return
   <em>
    an array
   </em>
   <code>
    ans
   </code>
   <em>
    of length
   </em>
   <code>
    n + 1
   </code>
   <em>
    such that for each
   </em>
   <code>
    i
   </code>
   <em>
   </em>
   (
   <code>
    0 &lt;= i &lt;= n
   </code>
   )
   <em>
    ,
   </em>
   <code>
    ans[i]
   </code>
   <em>
    is the
    <strong>
     number of
    </strong>
   </em>
   <code>
    1
   </code>
   <em>
    <strong>
     's
    </strong>
    in the binary representation of
   </em>
   <code>
    i
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 2
<strong>Output:</strong> [0,1,1]
<strong>Explanation:</strong>
0 --&gt; 0
1 --&gt; 1
2 --&gt; 10
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 5
<strong>Output:</strong> [0,1,1,2,1,2]
<strong>Explanation:</strong>
0 --&gt; 0
1 --&gt; 1
2 --&gt; 10
3 --&gt; 11
4 --&gt; 100
5 --&gt; 101
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= n &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
  </p>
  <ul>
   <li>
    It is very easy to come up with a solution with a runtime of
    <code>
     O(n log n)
    </code>
    . Can you do it in linear time
    <code>
     O(n)
    </code>
    and possibly in a single pass?
   </li>
   <li>
    Can you do it without using any built-in function (i.e., like
    <code>
     __builtin_popcount
    </code>
    in C++)?
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 338 -->
<pre>/*
 * @lc app=leetcode id=338 lang=cpp
 *
 * [338] Counting Bits
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; countBits(int n) {
        if(n==0) return {0};
        if(n==1) return {0,1};
        vector&lt;int&gt;result(n+1,0);
        result[0]=0;
        result[1]=1;
        result[2]=1;
        int high=2;
        for(int i=3; i&lt;=n; i++){
            if(pow(2,high)==i){
                high++;
                result[i]=1;
                continue;
            }
            result[i]=result[i-pow(2,high-1)]+1;
        }
        return result;

    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 342. Power of Four
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer
   <code>
    n
   </code>
   , return
   <em>
    <code>
     true
    </code>
    if it is a power of four. Otherwise, return
    <code>
     false
    </code>
   </em>
   .
  </p>
  <p>
   An integer
   <code>
    n
   </code>
   is a power of four, if there exists an integer
   <code>
    x
   </code>
   such that
   <code>
    n == 4
    <sup>
     x
    </sup>
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 16
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 5
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1
<strong>Output:</strong> true
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= n &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow up:
  </strong>
  Could you solve it without loops/recursion?
 </div>
</div>
</body></html>
<!-- Solution for Question 342 -->
<pre>/*
 * @lc app=leetcode id=342 lang=cpp
 *
 * [342] Power of Four
 */

// @lc code=start
class Solution {
public:
    bool isPowerOfFour(int n) {
        if(n&lt;=0) return false;
        while(n&gt;1){
            cout&lt;&lt;n;
            if(n%4!=0) return false;
            n=n/4;
        }
        return true;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 343. Integer Break
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer
   <code>
    n
   </code>
   , break it into the sum of
   <code>
    k
   </code>
   <strong>
    positive integers
   </strong>
   , where
   <code>
    k &gt;= 2
   </code>
   , and maximize the product of those integers.
  </p>
  <p>
   Return
   <em>
    the maximum product you can get
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 2
<strong>Output:</strong> 1
<strong>Explanation:</strong> 2 = 1 + 1, 1 × 1 = 1.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 10
<strong>Output:</strong> 36
<strong>Explanation:</strong> 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     2 &lt;= n &lt;= 58
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 343 -->
<pre>/*
 * @lc app=leetcode id=343 lang=cpp
 *
 * [343] Integer Break
 */

// @lc code=start
class Solution {
public:
    int integerBreak(int n) {
        if(n&lt;=2) return 1;
        vector&lt;int&gt;dp(n+1,0);
        dp[1]=0;
        dp[2]=1;
        for(int i=3;i&lt;=n;i++){
            for(int j=1;j&lt;i;j++){
                dp[i]=max({dp[i],j*(i-j),j*dp[i-j],dp[j]*(i-j)});
            }
        }
        return dp[n];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 344. Reverse String
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Write a function that reverses a string. The input string is given as an array of characters
   <code>
    s
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = ["h","e","l","l","o"]
<strong>Output:</strong> ["o","l","l","e","h"]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = ["H","a","n","n","a","h"]
<strong>Output:</strong> ["h","a","n","n","a","H"]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     s[i]
    </code>
    is a
    <a href="https://en.wikipedia.org/wiki/ASCII#Printable_characters" target="_blank">
     printable ascii character
    </a>
    .
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   Do not allocate extra space for another array. You must do this by modifying the input array
   <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank">
    in-place
   </a>
   with
   <code>
    O(1)
   </code>
   extra memory.
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 344 -->
<pre>/*
 * @lc app=leetcode id=344 lang=cpp
 *
 * [344] Reverse String
 */

// @lc code=start
class Solution {
public:
    void reverseString(vector&lt;char&gt;&amp; s) {
        for(int i=0; i&lt;s.size()/2;i++){
            swap(s[i], s[s.size()-i-1]);
        }
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 345. Reverse Vowels of a String
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    s
   </code>
   , reverse only all the vowels in the string and return it.
  </p>
  <p>
   The vowels are
   <code>
    'a'
   </code>
   ,
   <code>
    'e'
   </code>
   ,
   <code>
    'i'
   </code>
   ,
   <code>
    'o'
   </code>
   , and
   <code>
    'u'
   </code>
   , and they can appear in both cases.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "hello"
<strong>Output:</strong> "holle"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "leetcode"
<strong>Output:</strong> "leotcede"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 3 * 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consist of
    <strong>
     printable ASCII
    </strong>
    characters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 345 -->
<pre>/*
 * @lc app=leetcode id=345 lang=cpp
 *
 * [345] Reverse Vowels of a String
 */

// @lc code=start
class Solution {
public:
    string reverseVowels(string s) {
        int start=0,end=s.length()-1;
        while(start&lt;=end){
            while(!(tolower(s[start])==&#x27;a&#x27;||tolower(s[start])==&#x27;e&#x27;||tolower(s[start])==&#x27;i&#x27;||tolower(s[start])==&#x27;o&#x27;|| tolower(s[start])==&#x27;u&#x27;) &amp;&amp; start&lt;=end){
                start++;
            }
            while(!(tolower(s[end])==&#x27;a&#x27;||tolower(s[end])==&#x27;e&#x27;||tolower(s[end])==&#x27;i&#x27;||tolower(s[end])==&#x27;o&#x27;|| tolower(s[end])==&#x27;u&#x27;) &amp;&amp; start&lt;=end){
                end--;
            }
            cout&lt;&lt;start&lt;&lt;end;
            if(start&lt;=end){
            swap(s[start],s[end]);
            start++;end--;
            }
            else{
                return s;
            }
        }
        return s;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 347. Top K Frequent Elements
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   and an integer
   <code>
    k
   </code>
   , return
   <em>
    the
   </em>
   <code>
    k
   </code>
   <em>
    most frequent elements
   </em>
   . You may return the answer in
   <strong>
    any order
   </strong>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,1,1,2,2,3], k = 2
<strong>Output:</strong> [1,2]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1], k = 1
<strong>Output:</strong> [1]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     k
    </code>
    is in the range
    <code>
     [1, the number of unique elements in the array]
    </code>
    .
   </li>
   <li>
    It is
    <strong>
     guaranteed
    </strong>
    that the answer is
    <strong>
     unique
    </strong>
    .
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   Your algorithm's time complexity must be better than
   <code>
    O(n log n)
   </code>
   , where n is the array's size.
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 347 -->
<pre>/*
 * @lc app=leetcode id=347 lang=cpp
 *
 * [347] Top K Frequent Elements
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) {
        map&lt;int,int&gt;m;
        vector&lt;int&gt;ans;
        for(int i=0; i&lt;nums.size(); i++){
            m[nums[i]]++;
        }
        priority_queue&lt;pair&lt;int,int&gt;&gt; pq;
        for(auto x:m){
            pq.push(make_pair(x.second,x.first));
            if(pq.size()&gt;m.size()-k){
                ans.push_back(pq.top().second);
                pq.pop();
            }

        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 349. Intersection of Two Arrays
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two integer arrays
   <code>
    nums1
   </code>
   and
   <code>
    nums2
   </code>
   , return
   <em>
    an array of their intersection
   </em>
   . Each element in the result must be
   <strong>
    unique
   </strong>
   and you may return the result in
   <strong>
    any order
   </strong>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums1 = [1,2,2,1], nums2 = [2,2]
<strong>Output:</strong> [2]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums1 = [4,9,5], nums2 = [9,4,9,8,4]
<strong>Output:</strong> [9,4]
<strong>Explanation:</strong> [4,9] is also accepted.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums1.length, nums2.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     0 &lt;= nums1[i], nums2[i] &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 349 -->
<pre>/*
 * @lc app=leetcode id=349 lang=cpp
 *
 * [349] Intersection of Two Arrays
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        vector&lt;int&gt;a;
        unordered_set&lt;int&gt; m(nums1.begin(), nums1.end());
        for(int x:nums2){
            if(m.count(x)){
                a.push_back(x);
                m.erase(x);
            }
        }
        return a;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 350. Intersection of Two Arrays II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two integer arrays
   <code>
    nums1
   </code>
   and
   <code>
    nums2
   </code>
   , return
   <em>
    an array of their intersection
   </em>
   . Each element in the result must appear as many times as it shows in both arrays and you may return the result in
   <strong>
    any order
   </strong>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums1 = [1,2,2,1], nums2 = [2,2]
<strong>Output:</strong> [2,2]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums1 = [4,9,5], nums2 = [9,4,9,8,4]
<strong>Output:</strong> [4,9]
<strong>Explanation:</strong> [9,4] is also accepted.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums1.length, nums2.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     0 &lt;= nums1[i], nums2[i] &lt;= 1000
    </code>
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
  </p>
  <ul>
   <li>
    What if the given array is already sorted? How would you optimize your algorithm?
   </li>
   <li>
    What if
    <code>
     nums1
    </code>
    's size is small compared to
    <code>
     nums2
    </code>
    's size? Which algorithm is better?
   </li>
   <li>
    What if elements of
    <code>
     nums2
    </code>
    are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 350 -->
<pre>/*
 * @lc app=leetcode id=350 lang=cpp
 *
 * [350] Intersection of Two Arrays II
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        map&lt;int,int&gt;m;
        for(int x:nums1) {
            m[x]++;
        }
        vector&lt;int&gt;ans;
        for(int x:nums2) {
            if(m[x]-- &gt; 0){
                ans.push_back(x);
            }
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 354. Russian Doll Envelopes
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given a 2D array of integers
   <code>
    envelopes
   </code>
   where
   <code>
    envelopes[i] = [w
    <sub>
     i
    </sub>
    , h
    <sub>
     i
    </sub>
    ]
   </code>
   represents the width and the height of an envelope.
  </p>
  <p>
   One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.
  </p>
  <p>
   Return
   <em>
    the maximum number of envelopes you can Russian doll (i.e., put one inside the other)
   </em>
   .
  </p>
  <p>
   <strong>
    Note:
   </strong>
   You cannot rotate an envelope.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> envelopes = [[5,4],[6,4],[6,7],[2,3]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The maximum number of envelopes you can Russian doll is <code>3</code> ([2,3] =&gt; [5,4] =&gt; [6,7]).
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> envelopes = [[1,1],[1,1],[1,1]]
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= envelopes.length &lt;= 5000
    </code>
   </li>
   <li>
    <code>
     envelopes[i].length == 2
    </code>
   </li>
   <li>
    <code>
     1 &lt;= w
     <sub>
      i
     </sub>
     , h
     <sub>
      i
     </sub>
     &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 354 -->
<pre>/*
 * @lc app=leetcode id=354 lang=cpp
 *
 * [354] Russian Doll Envelopes
 */

// @lc code=start
class Solution {
public:
    static bool comp(vector&lt;int&gt;&amp;a,vector&lt;int&gt;&amp;b){
        if(a[0]==b[0]) return a[1]&gt;b[1];
        return a[0]&lt;b[0];
    }
    int maxEnvelopes(vector&lt;vector&lt;int&gt;&gt;&amp; envelopes) {
        sort(envelopes.begin(), envelopes.end(),comp);
        vector&lt;int&gt; ans;
        for(auto x:envelopes){
            for(int y:x) cout&lt;&lt;y;
            cout&lt;&lt;endl;
        }
        ans.push_back(envelopes[0][1]);
        for(int i=1; i&lt;envelopes.size(); i++) {
            if(envelopes[i][1]&gt;ans.back())
            ans.push_back(envelopes[i][1]);
            else{
                int index = lower_bound(ans.begin(),ans.end(),envelopes[i][1]) - ans.begin();
                ans[index] = envelopes[i][1];
            }
        }
        return ans.size();

    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 357. Count Numbers with Unique Digits
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer
   <code>
    n
   </code>
   , return the count of all numbers with unique digits,
   <code>
    x
   </code>
   , where
   <code>
    0 &lt;= x &lt; 10
    <sup>
     n
    </sup>
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 2
<strong>Output:</strong> 91
<strong>Explanation:</strong> The answer should be the total numbers in the range of 0 ≤ x &lt; 100, excluding 11,22,33,44,55,66,77,88,99
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 0
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= n &lt;= 8
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 357 -->
<pre>/*
 * @lc app=leetcode id=357 lang=cpp
 *
 * [357] Count Numbers with Unique Digits
 */

// @lc code=start
class Solution {
public:
    int countNumbersWithUniqueDigits(int n) {
        if(n==0){
            return 1;
        }
        if(n==1){
            return 10;
        }
        int k=n-1;
        int m=9;
        int ans=9;
        while(k--){
            ans=ans*m;
            m--;
        }
        return ans+countNumbersWithUniqueDigits(n-1);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 367. Valid Perfect Square
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a
   <strong>
    positive
   </strong>
   integer
   <i>
    num
   </i>
   , write a function which returns True if
   <i>
    num
   </i>
   is a perfect square else False.
  </p>
  <p>
   <b>
    Follow up:
   </b>
   <b>
    Do not
   </b>
   use any built-in library function such as
   <code>
    sqrt
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = 16
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = 14
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= num &lt;= 2^31 - 1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 367 -->
<pre>/*
 * @lc app=leetcode id=367 lang=cpp
 *
 * [367] Valid Perfect Square
 */

// @lc code=start
class Solution {
public:
    bool isPerfectSquare(int num) {
        int start=0,end=num;
        while(start&lt;=end)
        {
            int mid=(start+end)/2;
            long long sqr=(long long) mid*mid;
            if(sqr==num) return true;
            else if (sqr&gt;num) end=mid-1;
            else start=mid+1;
        }
        return false;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 368. Largest Divisible Subset
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a set of
   <strong>
    distinct
   </strong>
   positive integers
   <code>
    nums
   </code>
   , return the largest subset
   <code>
    answer
   </code>
   such that every pair
   <code>
    (answer[i], answer[j])
   </code>
   of elements in this subset satisfies:
  </p>
  <ul>
   <li>
    <code>
     answer[i] % answer[j] == 0
    </code>
    , or
   </li>
   <li>
    <code>
     answer[j] % answer[i] == 0
    </code>
   </li>
  </ul>
  <p>
   If there are multiple solutions, return any of them.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> [1,2]
<strong>Explanation:</strong> [1,3] is also accepted.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,4,8]
<strong>Output:</strong> [1,2,4,8]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     1 &lt;= nums[i] &lt;= 2 * 10
     <sup>
      9
     </sup>
    </code>
   </li>
   <li>
    All the integers in
    <code>
     nums
    </code>
    are
    <strong>
     unique
    </strong>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 368 -->
<pre>/*
 * @lc app=leetcode id=368 lang=cpp
 *
 * [368] Largest Divisible Subset
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());
        vector&lt;int&gt;lis(nums.size()+1,1);
        vector&lt;int&gt;a;
        int maxlen=1;
        for(int i=0; i&lt;nums.size(); i++){
            for(int j=0; j&lt;i; j++){
                if(nums[i]%nums[j]==0)lis[i] = max(lis[i],1+lis[j]);
            }
            maxlen = max(maxlen, lis[i]);
        }
        int prev=-1;
        for (int i=nums.size() - 1; i&gt;=0; i--) {
            if(maxlen==lis[i] &amp;&amp; (prev==-1 || prev%nums[i]==0)){
                a.insert(a.begin(),nums[i]);
                maxlen--;
                prev=nums[i];
            }
        }
        return a;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 371. Sum of Two Integers
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two integers
   <code>
    a
   </code>
   and
   <code>
    b
   </code>
   , return
   <em>
    the sum of the two integers without using the operators
   </em>
   <code>
    +
   </code>
   <em>
    and
   </em>
   <code>
    -
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> a = 1, b = 2
<strong>Output:</strong> 3
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> a = 2, b = 3
<strong>Output:</strong> 5
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     -1000 &lt;= a, b &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 371 -->
<pre>/*
 * @lc app=leetcode id=371 lang=cpp
 *
 * [371] Sum of Two Integers
 */

// @lc code=start
class Solution {
public:
    int getSum(int a, int b) {

        /*

        a = 0101
        b = 0111

        First Iteration:

        sum = a ^ b: 0101 ^ 0111 = 0010 (sum without considering carry)
        b = (a &amp; b) &lt;&lt; 1: (0101 &amp; 0111) &lt;&lt; 1 = 0101 &lt;&lt; 1 = 1010 (carry)
        a = sum: a is now 0010

        Second Iteration:

        sum = a ^ b: 0010 ^ 1010 = 1000 (sum without considering carry)
        b = (a &amp; b) &lt;&lt; 1: (0010 &amp; 1010) &lt;&lt; 1 = 0010 &lt;&lt; 1 = 0100 (carry)
        a = sum: a is now 1000

        Third Iteration:

        sum = a ^ b: 1000 ^ 0100 = 1100 (sum without considering carry)
        b = (a &amp; b) &lt;&lt; 1: (1000 &amp; 0100) &lt;&lt; 1 = 0000 (carry)
        a = sum: a is now 1100

        */

        int sum=a;
        while(b!=0){// add carry till it is zero
            sum=a^b; // sum without carrry
            b=(a&amp;b)&lt;&lt;1; // carry
            a=sum;
        }
        return sum;


    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 372. Super Pow
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Your task is to calculate
   <code>
    a
    <sup>
     b
    </sup>
   </code>
   mod
   <code>
    1337
   </code>
   where
   <code>
    a
   </code>
   is a positive integer and
   <code>
    b
   </code>
   is an extremely large positive integer given in the form of an array.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> a = 2, b = [3]
<strong>Output:</strong> 8
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> a = 2, b = [1,0]
<strong>Output:</strong> 1024
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> a = 1, b = [4,3,3,8,5,2]
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> a = 2147483647, b = [2,0,0]
<strong>Output:</strong> 1198
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= a &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
   <li>
    <code>
     1 &lt;= b.length &lt;= 2000
    </code>
   </li>
   <li>
    <code>
     0 &lt;= b[i] &lt;= 9
    </code>
   </li>
   <li>
    <code>
     b
    </code>
    doesn't contain leading zeros.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 372 -->
<pre>/*
 * @lc app=leetcode id=372 lang=cpp
 *
 * [372] Super Pow
 */

// @lc code=start
class Solution {
public:
    int base=1337;
    int power(int a,int n){
        a=a%base;
        int ans=1;
        for(int i=0;i&lt;n;i++){
            ans=(ans*a)%base;
        }
        return ans;
    }
    int superPow(int a, vector&lt;int&gt;&amp; b) {
        if(b.empty()) return 1;
        int n=b.back();
        b.pop_back();
        return power(superPow(a,b),10) * power(a,n) %base;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 374. Guess Number Higher or Lower
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   We are playing the Guess Game. The game is as follows:
  </p>
  <p>
   I pick a number from
   <code>
    1
   </code>
   to
   <code>
    n
   </code>
   . You have to guess which number I picked.
  </p>
  <p>
   Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.
  </p>
  <p>
   You call a pre-defined API
   <code>
    int guess(int num)
   </code>
   , which returns 3 possible results:
  </p>
  <ul>
   <li>
    <code>
     -1
    </code>
    : The number I picked is lower than your guess (i.e.
    <code>
     pick &lt; num
    </code>
    ).
   </li>
   <li>
    <code>
     1
    </code>
    : The number I picked is higher than your guess (i.e.
    <code>
     pick &gt; num
    </code>
    ).
   </li>
   <li>
    <code>
     0
    </code>
    : The number I picked is equal to your guess (i.e.
    <code>
     pick == num
    </code>
    ).
   </li>
  </ul>
  <p>
   Return
   <em>
    the number that I picked
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 10, pick = 6
<strong>Output:</strong> 6
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1, pick = 1
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 2, pick = 1
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 2, pick = 2
<strong>Output:</strong> 2
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
   <li>
    <code>
     1 &lt;= pick &lt;= n
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 374 -->
<pre>/*
 * @lc app=leetcode id=374 lang=cpp
 *
 * [374] Guess Number Higher or Lower
 */

// @lc code=start
/**
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return 	     -1 if num is higher than the picked number
 *			      1 if num is lower than the picked number
 *               otherwise return 0
 * int guess(int num);
 */

class Solution {
public:
    int guessNumber(int n) {
        long long start=0,end=n;
        while(start&lt;=end){
            long long mid=(start+end)/2;
            int val=guess(mid);
            if(val==0) return mid;
            else if ( val==-1) end=mid-1;
            else start=mid+1;
        }
        return -1;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 376. Wiggle Subsequence
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   A
   <strong>
    wiggle sequence
   </strong>
   is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.
  </p>
  <ul>
   <li>
    For example,
    <code>
     [1, 7, 4, 9, 2, 5]
    </code>
    is a
    <strong>
     wiggle sequence
    </strong>
    because the differences
    <code>
     (6, -3, 5, -7, 3)
    </code>
    alternate between positive and negative.
   </li>
   <li>
    In contrast,
    <code>
     [1, 4, 7, 2, 5]
    </code>
    and
    <code>
     [1, 7, 4, 5, 5]
    </code>
    are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.
   </li>
  </ul>
  <p>
   A
   <strong>
    subsequence
   </strong>
   is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.
  </p>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   , return
   <em>
    the length of the longest
    <strong>
     wiggle subsequence
    </strong>
    of
   </em>
   <code>
    nums
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,7,4,9,2,5]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,17,5,10,13,15,10,5,16,8]
<strong>Output:</strong> 7
<strong>Explanation:</strong> There are several subsequences that achieve this length.
One is [1, 17, 10, 13, 10, 16, 8] with differences (16, -7, 3, -3, 6, -8).
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3,4,5,6,7,8,9]
<strong>Output:</strong> 2
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     0 &lt;= nums[i] &lt;= 1000
    </code>
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   Could you solve this in
   <code>
    O(n)
   </code>
   time?
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 376 -->
<pre>/*
 * @lc app=leetcode id=376 lang=cpp
 *
 * [376] Wiggle Subsequence
 */

// @lc code=start
class Solution {
public:
    int wiggleMaxLength(vector&lt;int&gt;&amp; nums) {
        int n=nums.size();
        int high=1,low=1;
        for(int i=1;i&lt;n;i++){
            if(nums[i]&gt;nums[i-1]) high= low+1;
            else if(nums[i]&lt;nums[i-1]) low= high+1;
        }
        return max(high,low);

        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 377. Combination Sum IV
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of
   <strong>
    distinct
   </strong>
   integers
   <code>
    nums
   </code>
   and a target integer
   <code>
    target
   </code>
   , return
   <em>
    the number of possible combinations that add up to
   </em>
   <code>
    target
   </code>
   .
  </p>
  <p>
   The answer is
   <strong>
    guaranteed
   </strong>
   to fit in a
   <strong>
    32-bit
   </strong>
   integer.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3], target = 4
<strong>Output:</strong> 7
<strong>Explanation:</strong>
The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
Note that different sequences are counted as different combinations.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [9], target = 3
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 200
    </code>
   </li>
   <li>
    <code>
     1 &lt;= nums[i] &lt;= 1000
    </code>
   </li>
   <li>
    All the elements of
    <code>
     nums
    </code>
    are
    <strong>
     unique
    </strong>
    .
   </li>
   <li>
    <code>
     1 &lt;= target &lt;= 1000
    </code>
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 377 -->
<pre>/*
 * @lc app=leetcode id=377 lang=cpp
 *
 * [377] Combination Sum IV
 */

// @lc code=start
class Solution {
public:
    int f(vector&lt;int&gt;&amp;nums,int target,vector&lt;int&gt;&amp;dp)
    {
        if(target==0) return 1;
        if(target&lt;0) return 0;
        if(dp[target]!=-1) return dp[target];
        int ans=0;
        for(int j=0;j&lt;nums.size();j++){
            ans=ans+f(nums,target-nums[j],dp);
        }
        return dp[target]=ans;
    }
    int combinationSum4(vector&lt;int&gt;&amp; nums, int target) {
        int i=0;
        vector&lt;int&gt;dp(target+1,-1);
        return f(nums,target,dp);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 378. Kth Smallest Element in a Sorted Matrix
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an
   <code>
    n x n
   </code>
   <code>
    matrix
   </code>
   where each of the rows and columns are sorted in ascending order, return
   <em>
    the
   </em>
   <code>
    k
    <sup>
     th
    </sup>
   </code>
   <em>
    smallest element in the matrix
   </em>
   .
  </p>
  <p>
   Note that it is the
   <code>
    k
    <sup>
     th
    </sup>
   </code>
   smallest element
   <strong>
    in the sorted order
   </strong>
   , not the
   <code>
    k
    <sup>
     th
    </sup>
   </code>
   <strong>
    distinct
   </strong>
   element.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
<strong>Output:</strong> 13
<strong>Explanation:</strong> The elements in the matrix are [1,5,9,10,11,12,13,<u><strong>13</strong></u>,15], and the 8<sup>th</sup> smallest number is 13
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> matrix = [[-5]], k = 1
<strong>Output:</strong> -5
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == matrix.length
    </code>
   </li>
   <li>
    <code>
     n == matrix[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 300
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      9
     </sup>
     &lt;= matrix[i][j] &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
   <li>
    All the rows and columns of
    <code>
     matrix
    </code>
    are
    <strong>
     guaranteed
    </strong>
    to be sorted in
    <strong>
     non-decreasing order
    </strong>
    .
   </li>
   <li>
    <code>
     1 &lt;= k &lt;= n
     <sup>
      2
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 378 -->
<pre>/*
 * @lc app=leetcode id=378 lang=cpp
 *
 * [378] Kth Smallest Element in a Sorted Matrix
 */

// @lc code=start
class Solution {
public:
    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {
        int start=0,end=matrix.size()*matrix[0].size();
        while(start&lt;end) {
            if()
        }
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 383. Ransom Note
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two stings
   <code>
    ransomNote
   </code>
   and
   <code>
    magazine
   </code>
   , return
   <code>
    true
   </code>
   if
   <code>
    ransomNote
   </code>
   can be constructed from
   <code>
    magazine
   </code>
   and
   <code>
    false
   </code>
   otherwise.
  </p>
  <p>
   Each letter in
   <code>
    magazine
   </code>
   can only be used once in
   <code>
    ransomNote
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> ransomNote = "a", magazine = "b"
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> ransomNote = "aa", magazine = "ab"
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> ransomNote = "aa", magazine = "aab"
<strong>Output:</strong> true
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= ransomNote.length, magazine.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     ransomNote
    </code>
    and
    <code>
     magazine
    </code>
    consist of lowercase English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 383 -->
<pre>/*
 * @lc app=leetcode id=383 lang=cpp
 *
 * [383] Ransom Note
 */

// @lc code=start
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        map&lt;char,int&gt;m1;
        map&lt;char,int&gt;m2;
        for(char x:ransomNote) m1[x]++;
        for(char x:magazine) m2[x]++;
        for(auto x:m1){
            if(m2[x.first]&lt;m1[x.first]) return 0;
        }
        return 1;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 386. Lexicographical Numbers
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer
   <code>
    n
   </code>
   , return all the numbers in the range
   <code>
    [1, n]
   </code>
   sorted in lexicographical order.
  </p>
  <p>
   You must write an algorithm that runs in
   <code>
    O(n)
   </code>
   time and uses
   <code>
    O(1)
   </code>
   extra space.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 13
<strong>Output:</strong> [1,10,11,12,13,2,3,4,5,6,7,8,9]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 2
<strong>Output:</strong> [1,2]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 5 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 386 -->
<pre>/*
 * @lc app=leetcode id=386 lang=cpp
 *
 * [386] Lexicographical Numbers
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; lexicalOrder(int n) {
        vector&lt;string&gt;a;
        vector&lt;int&gt;ans;
        for(int i=1;i&lt;=n;i++){
            a.push_back(to_string(i));
        }
        sort(a.begin(),a.end());
        for(int i=1;i&lt;=n;i++){
            ans.push_back(stoi(a[i-1]));
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 387. First Unique Character in a String
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    s
   </code>
   ,
   <em>
    find the first non-repeating character in it and return its index
   </em>
   . If it does not exist, return
   <code>
    -1
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "leetcode"
<strong>Output:</strong> 0
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "loveleetcode"
<strong>Output:</strong> 2
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "aabb"
<strong>Output:</strong> -1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consists of only lowercase English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 387 -->
<pre>/*
 * @lc app=leetcode id=387 lang=cpp
 *
 * [387] First Unique Character in a String
 */

// @lc code=start
class Solution {
public:
    int firstUniqChar(string s) {
        map&lt;char,int&gt;m;
        for(char x:s)m[x]++;
        int i=0;
        for(char x:s){
            if(m[x] == 1) return i;
            i++;
        }
        return -1;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 389. Find the Difference
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given two strings
   <code>
    s
   </code>
   and
   <code>
    t
   </code>
   .
  </p>
  <p>
   String
   <code>
    t
   </code>
   is generated by random shuffling string
   <code>
    s
   </code>
   and then add one more letter at a random position.
  </p>
  <p>
   Return the letter that was added to
   <code>
    t
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "abcd", t = "abcde"
<strong>Output:</strong> "e"
<strong>Explanation:</strong> 'e' is the letter that was added.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "", t = "y"
<strong>Output:</strong> "y"
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "a", t = "aa"
<strong>Output:</strong> "a"
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "ae", t = "aea"
<strong>Output:</strong> "a"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= s.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     t.length == s.length + 1
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    and
    <code>
     t
    </code>
    consist of lower-case English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 389 -->
<pre>/*
 * @lc app=leetcode id=389 lang=cpp
 *
 * [389] Find the Difference
 */

// @lc code=start
class Solution {
public:
    char findTheDifference(string s, string t) {
        if(s.length()==0) return t[0];
        int ans=t[0]^s[0];
        for(int i=1;i&lt;s.length();i++){
            int x=t[i];
            int y=s[i];
            ans=ans^x^y;
        }
        ans=ans^t[t.length()-1];
        char ans1=ans;
        return ans1;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 392. Is Subsequence
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two strings
   <code>
    s
   </code>
   and
   <code>
    t
   </code>
   , return
   <code>
    true
   </code>
   <em>
    if
   </em>
   <code>
    s
   </code>
   <em>
    is a
    <strong>
     subsequence
    </strong>
    of
   </em>
   <code>
    t
   </code>
   <em>
    , or
   </em>
   <code>
    false
   </code>
   <em>
    otherwise
   </em>
   .
  </p>
  <p>
   A
   <strong>
    subsequence
   </strong>
   of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e.,
   <code>
    "ace"
   </code>
   is a subsequence of
   <code>
    "
    <u>
     a
    </u>
    b
    <u>
     c
    </u>
    d
    <u>
     e
    </u>
    "
   </code>
   while
   <code>
    "aec"
   </code>
   is not).
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "abc", t = "ahbgdc"
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "axc", t = "ahbgdc"
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= s.length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     0 &lt;= t.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    and
    <code>
     t
    </code>
    consist only of lowercase English letters.
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow up:
  </strong>
  Suppose there are lots of incoming
  <code>
   s
  </code>
  , say
  <code>
   s
   <sub>
    1
   </sub>
   , s
   <sub>
    2
   </sub>
   , ..., s
   <sub>
    k
   </sub>
  </code>
  where
  <code>
   k &gt;= 10
   <sup>
    9
   </sup>
  </code>
  , and you want to check one by one to see if
  <code>
   t
  </code>
  has its subsequence. In this scenario, how would you change your code?
 </div>
</div>
</body></html>
<!-- Solution for Question 392 -->
<pre>/*
 * @lc app=leetcode id=392 lang=cpp
 *
 * [392] Is Subsequence
 */

// @lc code=start
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int m=s.length(),n=t.length();
        int i=0,j=0;
        while(i&lt;m &amp;&amp; j&lt;n) {
            if(s[i]==t[j]){
                i++;
            }
            j++;
        }
        return i==m;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 394. Decode String
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an encoded string, return its decoded string.
  </p>
  <p>
   The encoding rule is:
   <code>
    k[encoded_string]
   </code>
   , where the
   <code>
    encoded_string
   </code>
   inside the square brackets is being repeated exactly
   <code>
    k
   </code>
   times. Note that
   <code>
    k
   </code>
   is guaranteed to be a positive integer.
  </p>
  <p>
   You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.
  </p>
  <p>
   Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers,
   <code>
    k
   </code>
   . For example, there won't be input like
   <code>
    3a
   </code>
   or
   <code>
    2[4]
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "3[a]2[bc]"
<strong>Output:</strong> "aaabcbc"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "3[a2[c]]"
<strong>Output:</strong> "accaccacc"
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "2[abc]3[cd]ef"
<strong>Output:</strong> "abcabccdcdcdef"
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "abc3[cd]xyz"
<strong>Output:</strong> "abccdcdcdxyz"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 30
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consists of lowercase English letters, digits, and square brackets
    <code>
     '[]'
    </code>
    .
   </li>
   <li>
    <code>
     s
    </code>
    is guaranteed to be
    <strong>
     a valid
    </strong>
    input.
   </li>
   <li>
    All the integers in
    <code>
     s
    </code>
    are in the range
    <code>
     [1, 300]
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 394 -->
<pre>/*
 * @lc app=leetcode id=394 lang=cpp
 *
 * [394] Decode String
 */

// @lc code=start
class Solution {
public:
    string decodeString(string s) {
        int end,start;
        string ans=&quot;&quot;;
        for(int i = s.length()-1; i &gt;=0; i--){
            if(s[i] == &#x27;]&#x27;){
                end=i;
            }
            if(s[i] == &#x27;[&#x27;){
                start=i;
                string value=&quot;&quot;;
                i--;
                value=value+s[i];
                while(i&gt;0 &amp;&amp; s[i-1]-&#x27;0&#x27;&gt;=0 &amp;&amp; s[i-1]-&#x27;0&#x27;&lt;=9){
                    value=s[i-1]+value;
                    i--;
                }
                string a=&quot;&quot;;
                for(int j = 0; j&lt;stoi(value);j++){
                    a=a+s.substr(start+1,end-start-1);
                }
                return decodeString(s.substr(0,i)+a+s.substr(end+1,s.length()-end-1));
            }
        }
        return s;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 396. Rotate Function
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an integer array
   <code>
    nums
   </code>
   of length
   <code>
    n
   </code>
   .
  </p>
  <p>
   Assume
   <code>
    arr
    <sub>
     k
    </sub>
   </code>
   to be an array obtained by rotating
   <code>
    nums
   </code>
   by
   <code>
    k
   </code>
   positions clock-wise. We define the
   <strong>
    rotation function
   </strong>
   <code>
    F
   </code>
   on
   <code>
    nums
   </code>
   as follow:
  </p>
  <ul>
   <li>
    <code>
     F(k) = 0 * arr
     <sub>
      k
     </sub>
     [0] + 1 * arr
     <sub>
      k
     </sub>
     [1] + ... + (n - 1) * arr
     <sub>
      k
     </sub>
     [n - 1].
    </code>
   </li>
  </ul>
  <p>
   Return
   <em>
    the maximum value of
   </em>
   <code>
    F(0), F(1), ..., F(n-1)
   </code>
   .
  </p>
  <p>
   The test cases are generated so that the answer fits in a
   <strong>
    32-bit
   </strong>
   integer.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [4,3,2,6]
<strong>Output:</strong> 26
<strong>Explanation:</strong>
F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26
So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [100]
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == nums.length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     -100 &lt;= nums[i] &lt;= 100
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 396 -->
<pre>/*
 * @lc app=leetcode id=396 lang=cpp
 *
 * [396] Rotate Function
 */

// @lc code=start
class Solution {
public:

    int maxRotateFunction(vector&lt;int&gt;&amp; a) {
        if(a.size()==1){
            return 0;
        }
        int ans=0;
        int sum=0;
        for(int i=0; i&lt;a.size(); i++){
            sum=sum+a[i];
            ans=ans+i*a[i];
        }
        int maxx=ans;
        for(int i=a.size()-1; i&gt;0;i--){
            ans = ans + sum - a[i]*a.size();
            maxx=max(ans,maxx);
        }
        return maxx;
    }
};
// @lc code=end
</pre><html><head></head><body>
<div id="title">
 399. Evaluate Division
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an array of variable pairs
   <code>
    equations
   </code>
   and an array of real numbers
   <code>
    values
   </code>
   , where
   <code>
    equations[i] = [A
    <sub>
     i
    </sub>
    , B
    <sub>
     i
    </sub>
    ]
   </code>
   and
   <code>
    values[i]
   </code>
   represent the equation
   <code>
    A
    <sub>
     i
    </sub>
    / B
    <sub>
     i
    </sub>
    = values[i]
   </code>
   . Each
   <code>
    A
    <sub>
     i
    </sub>
   </code>
   or
   <code>
    B
    <sub>
     i
    </sub>
   </code>
   is a string that represents a single variable.
  </p>
  <p>
   You are also given some
   <code>
    queries
   </code>
   , where
   <code>
    queries[j] = [C
    <sub>
     j
    </sub>
    , D
    <sub>
     j
    </sub>
    ]
   </code>
   represents the
   <code>
    j
    <sup>
     th
    </sup>
   </code>
   query where you must find the answer for
   <code>
    C
    <sub>
     j
    </sub>
    / D
    <sub>
     j
    </sub>
    = ?
   </code>
   .
  </p>
  <p>
   Return
   <em>
    the answers to all queries
   </em>
   . If a single answer cannot be determined, return
   <code>
    -1.0
   </code>
   .
  </p>
  <p>
   <strong>
    Note:
   </strong>
   The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
<strong>Output:</strong> [6.00000,0.50000,-1.00000,1.00000,-1.00000]
<strong>Explanation:</strong> 
Given: <em>a / b = 2.0</em>, <em>b / c = 3.0</em>
queries are: <em>a / c = ?</em>, <em>b / a = ?</em>, <em>a / e = ?</em>, <em>a / a = ?</em>, <em>x / x = ?</em>
return: [6.0, 0.5, -1.0, 1.0, -1.0 ]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]
<strong>Output:</strong> [3.75000,0.40000,5.00000,0.20000]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> equations = [["a","b"]], values = [0.5], queries = [["a","b"],["b","a"],["a","c"],["x","y"]]
<strong>Output:</strong> [0.50000,2.00000,-1.00000,-1.00000]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= equations.length &lt;= 20
    </code>
   </li>
   <li>
    <code>
     equations[i].length == 2
    </code>
   </li>
   <li>
    <code>
     1 &lt;= A
     <sub>
      i
     </sub>
     .length, B
     <sub>
      i
     </sub>
     .length &lt;= 5
    </code>
   </li>
   <li>
    <code>
     values.length == equations.length
    </code>
   </li>
   <li>
    <code>
     0.0 &lt; values[i] &lt;= 20.0
    </code>
   </li>
   <li>
    <code>
     1 &lt;= queries.length &lt;= 20
    </code>
   </li>
   <li>
    <code>
     queries[i].length == 2
    </code>
   </li>
   <li>
    <code>
     1 &lt;= C
     <sub>
      j
     </sub>
     .length, D
     <sub>
      j
     </sub>
     .length &lt;= 5
    </code>
   </li>
   <li>
    <code>
     A
     <sub>
      i
     </sub>
     , B
     <sub>
      i
     </sub>
     , C
     <sub>
      j
     </sub>
     , D
     <sub>
      j
     </sub>
    </code>
    consist of lower case English letters and digits.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 399 -->
<pre>/*
 * @lc app=leetcode id=399 lang=cpp
 *
 * [399] Evaluate Division
 */

// @lc code=start
class Solution {
public:
    vector&lt;double&gt; calcEquation(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;double&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 400. Nth Digit
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer
   <code>
    n
   </code>
   , return the
   <code>
    n
    <sup>
     th
    </sup>
   </code>
   digit of the infinite integer sequence
   <code>
    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 3
<strong>Output:</strong> 3
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 11
<strong>Output:</strong> 0
<strong>Explanation:</strong> The 11<sup>th</sup> digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 400 -->
<pre>/*
 * @lc app=leetcode id=400 lang=cpp
 *
 * [400] Nth Digit
 */

// @lc code=start
class Solution {
public:
    int findNthDigit(int n) {
        int a=9,d=1;
        while(n&gt;(long)a*d){
            n-=a*d;
            a*=10;
            d++;
        }
        // highest crossed power + new number for every d
        int num = pow(10, d - 1) + (n - 1) / d;
        return to_string(num)[ (n-1) %d] -&#x27;0&#x27;;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 401. Binary Watch
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.
  </p>
  <ul>
   <li>
    For example, the below binary watch reads
    <code>
     "4:51"
    </code>
    .
   </li>
  </ul>
  <p>
   <img alt="" src="./output_files/binarywatch.jpg" style="width: 500px; height: 500px;"/>
  </p>
  <p>
   Given an integer
   <code>
    turnedOn
   </code>
   which represents the number of LEDs that are currently on, return
   <em>
    all possible times the watch could represent
   </em>
   . You may return the answer in
   <strong>
    any order
   </strong>
   .
  </p>
  <p>
   The hour must not contain a leading zero.
  </p>
  <ul>
   <li>
    For example,
    <code>
     "01:00"
    </code>
    is not valid. It should be
    <code>
     "1:00"
    </code>
    .
   </li>
  </ul>
  <p>
   The minute must be consist of two digits and may contain a leading zero.
  </p>
  <ul>
   <li>
    For example,
    <code>
     "10:2"
    </code>
    is not valid. It should be
    <code>
     "10:02"
    </code>
    .
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> turnedOn = 1
<strong>Output:</strong> ["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> turnedOn = 9
<strong>Output:</strong> []
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= turnedOn &lt;= 10
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 401 -->
<pre>/*
 * @lc app=leetcode id=401 lang=cpp
 *
 * [401] Binary Watch
 */

// @lc code=start
class Solution {
public:
    vector&lt;string&gt; readBinaryWatch(int turnedOn) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 402. Remove K Digits
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given string num representing a non-negative integer
   <code>
    num
   </code>
   , and an integer
   <code>
    k
   </code>
   , return
   <em>
    the smallest possible integer after removing
   </em>
   <code>
    k
   </code>
   <em>
    digits from
   </em>
   <code>
    num
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = "1432219", k = 3
<strong>Output:</strong> "1219"
<strong>Explanation:</strong> Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = "10200", k = 1
<strong>Output:</strong> "200"
<strong>Explanation:</strong> Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = "10", k = 2
<strong>Output:</strong> "0"
<strong>Explanation:</strong> Remove all the digits from the number and it is left with nothing which is 0.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= k &lt;= num.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     num
    </code>
    consists of only digits.
   </li>
   <li>
    <code>
     num
    </code>
    does not have any leading zeros except for the zero itself.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 402 -->
<pre>/*
 * @lc app=leetcode id=402 lang=cpp
 *
 * [402] Remove K Digits
 */

// @lc code=start
class Solution {
public:
    string removeKdigits(string s, int k) {
        string ans;

        if(k&gt;=s.length()) return &quot;0&quot;;

        ans.push_back(s[0]);
        for(int i=1; i&lt;s.length();i++){
            while(k &amp;&amp; !ans.empty() &amp;&amp; ans.back()&gt;s[i]){
                ans.pop_back();
                k--;
            }
            ans.push_back(s[i]);
        }

        while(k &amp;&amp; !ans.empty()){
            ans.pop_back();
            k--;
        }
        
        if(ans.size()&gt;1 &amp;&amp; ans[0]==&#x27;0&#x27;){
            reverse(ans.begin(), ans.end());
            while(!ans.empty() &amp;&amp; ans.back()==&#x27;0&#x27;) ans.pop_back();
            reverse(ans.begin(), ans.end());
        }


        if(ans.length()==0) return &quot;0&quot;;

        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 404. Sum of Left Leaves
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree, return the sum of all left leaves.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/leftsum-tree.jpg" style="width: 277px; height: 302px;"/>
  <pre><strong>Input:</strong> root = [3,9,20,null,null,15,7]
<strong>Output:</strong> 24
<strong>Explanation:</strong> There are two left leaves in the binary tree, with values 9 and 15 respectively.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1]
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [1, 1000]
    </code>
    .
   </li>
   <li>
    <code>
     -1000 &lt;= Node.val &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 404 -->
<pre>/*
 * @lc app=leetcode id=404 lang=cpp
 *
 * [404] Sum of Left Leaves
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int ans=0;
    int sumOfLeftLeaves(TreeNode* root) {
        if(root!=NULL){
            if(root-&gt;left!=NULL &amp;&amp; root-&gt;left-&gt;left==NULL &amp;&amp; root-&gt;left-&gt;right ==NULL){
                ans=ans+root-&gt;left-&gt;val;
            }
            sumOfLeftLeaves(root-&gt;left);
            sumOfLeftLeaves(root-&gt;right);
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 409. Longest Palindrome
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    s
   </code>
   which consists of lowercase or uppercase letters, return
   <em>
    the length of the
    <strong>
     longest palindrome
    </strong>
   </em>
   that can be built with those letters.
  </p>
  <p>
   Letters are
   <strong>
    case sensitive
   </strong>
   , for example,
   <code>
    "Aa"
   </code>
   is not considered a palindrome here.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "abccccdd"
<strong>Output:</strong> 7
<strong>Explanation:</strong>
One longest palindrome that can be built is "dccaccd", whose length is 7.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "a"
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "bb"
<strong>Output:</strong> 2
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 2000
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consists of lowercase
    <strong>
     and/or
    </strong>
    uppercase English letters only.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 409 -->
<pre>/*
 * @lc app=leetcode id=409 lang=cpp
 *
 * [409] Longest Palindrome
 */

// @lc code=start
class Solution {
public:
    int longestPalindrome(string s) {
        map&lt;char,int&gt;m;
        for(char x:s)m[x]++;
        int count=0;
        int flag=0;
        for(auto x:m){
            if(x.second/2&gt;=1) {
                if(x.second%2==1 &amp;&amp; flag==0){
                    flag=1;
                    count+=x.second;
                }
                else count+=(x.second/2)*2;
                }
            else if(x.second==1 &amp;&amp; flag==0){
                flag=1;
                count++;
            }
        }
        return count;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 412. Fizz Buzz
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer
   <code>
    n
   </code>
   , return
   <em>
    a string array
   </em>
   <code>
    answer
   </code>
   (
   <strong>
    1-indexed
   </strong>
   )
   <em>
    where
   </em>
   :
  </p>
  <ul>
   <li>
    <code>
     answer[i] == "FizzBuzz"
    </code>
    if
    <code>
     i
    </code>
    is divisible by
    <code>
     3
    </code>
    and
    <code>
     5
    </code>
    .
   </li>
   <li>
    <code>
     answer[i] == "Fizz"
    </code>
    if
    <code>
     i
    </code>
    is divisible by
    <code>
     3
    </code>
    .
   </li>
   <li>
    <code>
     answer[i] == "Buzz"
    </code>
    if
    <code>
     i
    </code>
    is divisible by
    <code>
     5
    </code>
    .
   </li>
   <li>
    <code>
     answer[i] == i
    </code>
    if non of the above conditions are true.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 3
<strong>Output:</strong> ["1","2","Fizz"]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 5
<strong>Output:</strong> ["1","2","Fizz","4","Buzz"]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 15
<strong>Output:</strong> ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14","FizzBuzz"]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 412 -->
<pre>/*
 * @lc app=leetcode id=412 lang=cpp
 *
 * [412] Fizz Buzz
 */

// @lc code=start
class Solution {
public:
    vector&lt;string&gt; fizzBuzz(int n) {
        vector&lt;string&gt;ans;
        for(int i=1; i&lt;=n; i++){
            if(i%3==0 &amp;&amp; i%5==0) ans.push_back(&quot;FizzBuzz&quot;);
            else if(i%3==0) ans.push_back(&quot;Fizz&quot;);
            else if(i%5==0) ans.push_back(&quot;Buzz&quot;);
            else ans.push_back(to_string(i));
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 413. Arithmetic Slices
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   An integer array is called arithmetic if it consists of
   <strong>
    at least three elements
   </strong>
   and if the difference between any two consecutive elements is the same.
  </p>
  <ul>
   <li>
    For example,
    <code>
     [1,3,5,7,9]
    </code>
    ,
    <code>
     [7,7,7,7]
    </code>
    , and
    <code>
     [3,-1,-5,-9]
    </code>
    are arithmetic sequences.
   </li>
  </ul>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   , return
   <em>
    the number of arithmetic
    <strong>
     subarrays
    </strong>
    of
   </em>
   <code>
    nums
   </code>
   .
  </p>
  <p>
   A
   <strong>
    subarray
   </strong>
   is a contiguous subsequence of the array.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3,4]
<strong>Output:</strong> 3
<strong>Explanation:</strong> We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1]
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 5000
    </code>
   </li>
   <li>
    <code>
     -1000 &lt;= nums[i] &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 413 -->
<pre>/*
 * @lc app=leetcode id=413 lang=cpp
 *
 * [413] Arithmetic Slices
 */

// @lc code=start
class Solution {
public:
    int numberOfArithmeticSlices(vector&lt;int&gt;&amp; nums) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 415. Add Strings
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two non-negative integers,
   <code>
    num1
   </code>
   and
   <code>
    num2
   </code>
   represented as string, return
   <em>
    the sum of
   </em>
   <code>
    num1
   </code>
   <em>
    and
   </em>
   <code>
    num2
   </code>
   <em>
    as a string
   </em>
   .
  </p>
  <p>
   You must solve the problem without using any built-in library for handling large integers (such as
   <code>
    BigInteger
   </code>
   ). You must also not convert the inputs to integers directly.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> num1 = "11", num2 = "123"
<strong>Output:</strong> "134"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> num1 = "456", num2 = "77"
<strong>Output:</strong> "533"
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> num1 = "0", num2 = "0"
<strong>Output:</strong> "0"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= num1.length, num2.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     num1
    </code>
    and
    <code>
     num2
    </code>
    consist of only digits.
   </li>
   <li>
    <code>
     num1
    </code>
    and
    <code>
     num2
    </code>
    don't have any leading zeros except for the zero itself.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 415 -->
<pre>/*
 * @lc app=leetcode id=415 lang=cpp
 *
 * [415] Add Strings
 */

// @lc code=start
class Solution {
public:
    string addStrings(string num1, string num2) {
      int i=num1.length()-1;
        int j=num2.length()-1;
        int carry=0;
        string s=&quot;&quot;;
        while(i&gt;=0 || j&gt;=0|| carry==1){
            int x;
            if(i==-1 &amp;&amp; j==-1){
                s=to_string(carry)+s;
                carry=0;
            }
            else if(i==-1){
                x=num2[j]-&#x27;0&#x27;+carry;
                s=to_string((x)%10)+s;
                carry=x/10;
                j--;
            }
            else if(j==-1){
                x=num1[i]-&#x27;0&#x27;+carry;
                s=to_string((x)%10)+s;
                carry=x/10;
                i--;
            }
            else{
                x=num2[j]-&#x27;0&#x27;+num1[i]-&#x27;0&#x27;+carry;
                s=to_string((x)%10)+s;
                carry=x/10;
                j--;
                i--;
            }
        }
        return s;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 416. Partition Equal Subset Sum
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a
   <strong>
    non-empty
   </strong>
   array
   <code>
    nums
   </code>
   containing
   <strong>
    only positive integers
   </strong>
   , find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,5,11,5]
<strong>Output:</strong> true
<strong>Explanation:</strong> The array can be partitioned as [1, 5, 5] and [11].
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3,5]
<strong>Output:</strong> false
<strong>Explanation:</strong> The array cannot be partitioned into equal sum subsets.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 200
    </code>
   </li>
   <li>
    <code>
     1 &lt;= nums[i] &lt;= 100
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 416 -->
<pre>/*
 * @lc app=leetcode id=416 lang=cpp
 *
 * [416] Partition Equal Subset Sum
 */

// @lc code=start
class Solution {
public:
    bool canPartition(vector&lt;int&gt;&amp; a) {
        int sum=0;
        for(int i=0;i&lt;a.size();i++){
            sum=sum+a[i];
        }
        if(sum%2!=0) return false;
        int n = a.size();
        sum=sum/2;
        vector&lt;vector&lt;int&gt;&gt;dp(n+1,vector&lt;int&gt;(sum+1,0));
        for(int i=1;i&lt;=n;i++) dp[i][0]=a[i-1];
        for(int i=0;i&lt;=sum;i++) dp[0][i]=0;

        for(int i=1;i&lt;=n;i++){
            for(int j=1;j&lt;=sum;j++){
                if(a[i-1]&lt;=j) dp[i][j]=max(dp[i-1][j-a[i-1]]+ a[i-1],dp[i-1][j]);
                else dp[i][j]=dp[i-1][j];
            }
        }
 
        cout&lt;&lt;&#x27;\n&#x27;;
        for(auto x:dp){
            for(int y:x){
                cout&lt;&lt;y&lt;&lt;&#x27; &#x27;;
            }
            cout&lt;&lt;&#x27;\n&#x27;;
        }
        return dp[n][sum]==sum;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 417. Pacific Atlantic Water Flow
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   There is an
   <code>
    m x n
   </code>
   rectangular island that borders both the
   <strong>
    Pacific Ocean
   </strong>
   and
   <strong>
    Atlantic Ocean
   </strong>
   . The
   <strong>
    Pacific Ocean
   </strong>
   touches the island's left and top edges, and the
   <strong>
    Atlantic Ocean
   </strong>
   touches the island's right and bottom edges.
  </p>
  <p>
   The island is partitioned into a grid of square cells. You are given an
   <code>
    m x n
   </code>
   integer matrix
   <code>
    heights
   </code>
   where
   <code>
    heights[r][c]
   </code>
   represents the
   <strong>
    height above sea level
   </strong>
   of the cell at coordinate
   <code>
    (r, c)
   </code>
   .
  </p>
  <p>
   The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is
   <strong>
    less than or equal to
   </strong>
   the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.
  </p>
  <p>
   Return
   <em>
    a
    <strong>
     2D list
    </strong>
    of grid coordinates
   </em>
   <code>
    result
   </code>
   <em>
    where
   </em>
   <code>
    result[i] = [r
    <sub>
     i
    </sub>
    , c
    <sub>
     i
    </sub>
    ]
   </code>
   <em>
    denotes that rain water can flow from cell
   </em>
   <code>
    (r
    <sub>
     i
    </sub>
    , c
    <sub>
     i
    </sub>
    )
   </code>
   <em>
    to
    <strong>
     both
    </strong>
    the Pacific and Atlantic oceans
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/waterflow-grid.jpg" style="width: 573px; height: 573px;"/>
  <pre><strong>Input:</strong> heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
<strong>Output:</strong> [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> heights = [[2,1],[1,2]]
<strong>Output:</strong> [[0,0],[0,1],[1,0],[1,1]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == heights.length
    </code>
   </li>
   <li>
    <code>
     n == heights[r].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m, n &lt;= 200
    </code>
   </li>
   <li>
    <code>
     0 &lt;= heights[r][c] &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 417 -->
<pre>/*
 * @lc app=leetcode id=417 lang=cpp
 *
 * [417] Pacific Atlantic Water Flow
 */

// @lc code=start
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; heights) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 421. Maximum XOR of Two Numbers in an Array
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   , return
   <em>
    the maximum result of
   </em>
   <code>
    nums[i] XOR nums[j]
   </code>
   , where
   <code>
    0 &lt;= i &lt;= j &lt; n
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,10,5,25,2,8]
<strong>Output:</strong> 28
<strong>Explanation:</strong> The maximum result is 5 XOR 25 = 28.</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [0]
<strong>Output:</strong> 0
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,4]
<strong>Output:</strong> 6
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [8,10,2]
<strong>Output:</strong> 10
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [14,70,53,83,49,91,36,80,92,51,66,70]
<strong>Output:</strong> 127
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 2 * 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= nums[i] &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 421 -->
<pre>/*
 * @lc app=leetcode id=421 lang=cpp
 *
 * [421] Maximum XOR of Two Numbers in an Array
 */

// @lc code=start
class Solution {
public:
    int findMaximumXOR(vector&lt;int&gt;&amp; nums) {
        int maxx=0;
        int n=nums.size();
        for(int i=0;i&lt;n;i++){
            for(int j=i;j&lt;n;j++){
                maxx=max(maxx,nums[i]^nums[j]);
            }
        }
        return maxx;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 429. N-ary Tree Level Order Traversal
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an n-ary tree, return the
   <em>
    level order
   </em>
   traversal of its nodes' values.
  </p>
  <p>
   <em>
    Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).
   </em>
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <p>
   <img src="./output_files/narytreeexample.png" style="width: 100%; max-width: 300px;"/>
  </p>
  <pre><strong>Input:</strong> root = [1,null,3,2,4,null,5,6]
<strong>Output:</strong> [[1],[3,2,4],[5,6]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <p>
   <img alt="" src="./output_files/sample_4_964.png" style="width: 296px; height: 241px;"/>
  </p>
  <pre><strong>Input:</strong> root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
<strong>Output:</strong> [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The height of the n-ary tree is less than or equal to
    <code>
     1000
    </code>
   </li>
   <li>
    The total number of nodes is between
    <code>
     [0, 10
     <sup>
      4
     </sup>
     ]
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 429 -->
<pre>/*
 * @lc app=leetcode id=429 lang=cpp
 *
 * [429] N-ary Tree Level Order Traversal
 */

// @lc code=start
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector&lt;Node*&gt; children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector&lt;Node*&gt; _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) {
        if(root == NULL)  return {};
        vector&lt;vector&lt;int&gt;&gt;a;
        queue&lt;Node *&gt; q;
        q.push(root);
        while(!q.empty()) {
            int count=q.size();
            vector&lt;int&gt;b;
            while(count){
                Node* node = q.front();
                b.push_back(node-&gt;val);
                q.pop();
                for(auto x:node-&gt;children){
                    q.push(x);
                }
                count--;
            }
        a.push_back(b);
        }
        return a;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 434. Number of Segments in a String
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given a string
   <code>
    s
   </code>
   , return
   <em>
    the number of segments in the string
   </em>
   .
  </p>
  <p>
   A
   <strong>
    segment
   </strong>
   is defined to be a contiguous sequence of
   <strong>
    non-space characters
   </strong>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "Hello, my name is John"
<strong>Output:</strong> 5
<strong>Explanation:</strong> The five segments are ["Hello,", "my", "name", "is", "John"]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "Hello"
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "love live! mu'sic forever"
<strong>Output:</strong> 4
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = ""
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= s.length &lt;= 300
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consists of lower-case and upper-case English letters, digits or one of the following characters
    <code>
     "!@#$%^&amp;*()_+-=',.:"
    </code>
    .
   </li>
   <li>
    The only space character in
    <code>
     s
    </code>
    is
    <code>
     ' '
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 434 -->
<pre>/*
 * @lc app=leetcode id=434 lang=cpp
 *
 * [434] Number of Segments in a String
 */

// @lc code=start
class Solution {
public:
    int countSegments(string s) {
        if(s==&quot;&quot;) return 0;
        int i=0;
        s=s+&#x27; &#x27;;
        string temp=&quot;&quot;;
        for(char x:s){
            if(x==&#x27; &#x27;){
                if(temp!=&quot;&quot;) i++;
                temp=&quot;&quot;;
            }
            else{
                temp+=x;
            }
        }
        return i;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 435. Non-overlapping Intervals
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of intervals
   <code>
    intervals
   </code>
   where
   <code>
    intervals[i] = [start
    <sub>
     i
    </sub>
    , end
    <sub>
     i
    </sub>
    ]
   </code>
   , return
   <em>
    the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> intervals = [[1,2],[2,3],[3,4],[1,3]]
<strong>Output:</strong> 1
<strong>Explanation:</strong> [1,3] can be removed and the rest of the intervals are non-overlapping.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> intervals = [[1,2],[1,2],[1,2]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> You need to remove two [1,2] to make the rest of the intervals non-overlapping.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> intervals = [[1,2],[2,3]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> You don't need to remove any of the intervals since they're already non-overlapping.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= intervals.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     intervals[i].length == 2
    </code>
   </li>
   <li>
    <code>
     -5 * 10
     <sup>
      4
     </sup>
     &lt;= start
     <sub>
      i
     </sub>
     &lt; end
     <sub>
      i
     </sub>
     &lt;= 5 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 435 -->
<pre>/*
 * @lc app=leetcode id=435 lang=cpp
 *
 * [435] Non-overlapping Intervals
 */

// @lc code=start
class Solution {
public:
    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 438. Find All Anagrams in a String
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two strings
   <code>
    s
   </code>
   and
   <code>
    p
   </code>
   , return
   <em>
    an array of all the start indices of
   </em>
   <code>
    p
   </code>
   <em>
    's anagrams in
   </em>
   <code>
    s
   </code>
   . You may return the answer in
   <strong>
    any order
   </strong>
   .
  </p>
  <p>
   An
   <strong>
    Anagram
   </strong>
   is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "cbaebabacd", p = "abc"
<strong>Output:</strong> [0,6]
<strong>Explanation:</strong>
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "abab", p = "ab"
<strong>Output:</strong> [0,1,2]
<strong>Explanation:</strong>
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length, p.length &lt;= 3 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    and
    <code>
     p
    </code>
    consist of lowercase English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 438 -->
<pre>/*
 * @lc app=leetcode id=438 lang=cpp
 *
 * [438] Find All Anagrams in a String
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; findAnagrams(string s, string p) {
        vector&lt;int&gt;m(26),m1(26);
        int total = 0,count = 0;
        for(int i=0; i&lt;p.length(); i++){
            m[p[i]-&#x27;a&#x27;]++;
        }
        vector&lt;int&gt;ans;
        for(int i=0; i&lt;s.length(); i++){
            m1[s[i]-&#x27;a&#x27;]++;
            if(i&gt;=p.size()) m1[s[i-p.size()]-&#x27;a&#x27;]--;
            if(m1==m) ans.push_back(i-p.size()+1);
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 441. Arranging Coins
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You have
   <code>
    n
   </code>
   coins and you want to build a staircase with these coins. The staircase consists of
   <code>
    k
   </code>
   rows where the
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   row has exactly
   <code>
    i
   </code>
   coins. The last row of the staircase
   <strong>
    may be
   </strong>
   incomplete.
  </p>
  <p>
   Given the integer
   <code>
    n
   </code>
   , return
   <em>
    the number of
    <strong>
     complete rows
    </strong>
    of the staircase you will build
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/arrangecoins1-grid.jpg" style="width: 253px; height: 253px;"/>
  <pre><strong>Input:</strong> n = 5
<strong>Output:</strong> 2
<strong>Explanation:</strong> Because the 3<sup>rd</sup> row is incomplete, we return 2.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/arrangecoins2-grid.jpg" style="width: 333px; height: 333px;"/>
  <pre><strong>Input:</strong> n = 8
<strong>Output:</strong> 3
<strong>Explanation:</strong> Because the 4<sup>th</sup> row is incomplete, we return 3.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 441 -->
<pre>/*
 * @lc app=leetcode id=441 lang=cpp
 *
 * [441] Arranging Coins
 */

// @lc code=start
class Solution {
public:
    int arrangeCoins(int n) {
        int start=0,end=n;
        while(start&lt;=end)
        {
            long mid=(start+end)/2;
            long sqr= (mid*(mid+1))/2;
            if (sqr&gt;n) end=mid-1;
            else start=mid+1;
        }
        return start-1;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 442. Find All Duplicates in an Array
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   of length
   <code>
    n
   </code>
   where all the integers of
   <code>
    nums
   </code>
   are in the range
   <code>
    [1, n]
   </code>
   and each integer appears
   <strong>
    once
   </strong>
   or
   <strong>
    twice
   </strong>
   , return
   <em>
    an array of all the integers that appears
    <strong>
     twice
    </strong>
   </em>
   .
  </p>
  <p>
   You must write an algorithm that runs in
   <code>
    O(n)
   </code>
   time and uses only constant extra space.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [4,3,2,7,8,2,3,1]
<strong>Output:</strong> [2,3]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,1,2]
<strong>Output:</strong> [1]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1]
<strong>Output:</strong> []
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == nums.length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     1 &lt;= nums[i] &lt;= n
    </code>
   </li>
   <li>
    Each element in
    <code>
     nums
    </code>
    appears
    <strong>
     once
    </strong>
    or
    <strong>
     twice
    </strong>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 442 -->
<pre>/*
 * @lc app=leetcode id=442 lang=cpp
 *
 * [442] Find All Duplicates in an Array
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; nums) {
        map&lt;int,int&gt;m;
        vector&lt;int&gt;a;
        for(int i=0;i&lt;nums.size();i++){
            if(m[nums[i]]==1){
                a.push_back(nums[i]);
            }
            m[nums[i]]=1;
        }
        return a;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 445. Add Two Numbers II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given two
   <strong>
    non-empty
   </strong>
   linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
  </p>
  <p>
   You may assume the two numbers do not contain any leading zero, except the number 0 itself.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/sumii-linked-list.jpg" style="width: 523px; height: 342px;"/>
  <pre><strong>Input:</strong> l1 = [7,2,4,3], l2 = [5,6,4]
<strong>Output:</strong> [7,8,0,7]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> l1 = [2,4,3], l2 = [5,6,4]
<strong>Output:</strong> [8,0,7]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> l1 = [0], l2 = [0]
<strong>Output:</strong> [0]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in each linked list is in the range
    <code>
     [1, 100]
    </code>
    .
   </li>
   <li>
    <code>
     0 &lt;= Node.val &lt;= 9
    </code>
   </li>
   <li>
    It is guaranteed that the list represents a number that does not have leading zeros.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   Could you solve it without reversing the input lists?
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 445 -->
<pre>/*
 * @lc app=leetcode id=445 lang=cpp
 *
 * [445] Add Two Numbers II
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 448. Find All Numbers Disappeared in an Array
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array
   <code>
    nums
   </code>
   of
   <code>
    n
   </code>
   integers where
   <code>
    nums[i]
   </code>
   is in the range
   <code>
    [1, n]
   </code>
   , return
   <em>
    an array of all the integers in the range
   </em>
   <code>
    [1, n]
   </code>
   <em>
    that do not appear in
   </em>
   <code>
    nums
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [4,3,2,7,8,2,3,1]
<strong>Output:</strong> [5,6]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,1]
<strong>Output:</strong> [2]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == nums.length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     1 &lt;= nums[i] &lt;= n
    </code>
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   Could you do it without extra space and in
   <code>
    O(n)
   </code>
   runtime? You may assume the returned list does not count as extra space.
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 448 -->
<pre>/*
 * @lc app=leetcode id=448 lang=cpp
 *
 * [448] Find All Numbers Disappeared in an Array
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt;a;
        map&lt;int,int&gt;m;
        for(int i=0;i&lt;nums.size();i++){
            m[nums[i]]++;
        }
        for(int i=1;i&lt;=nums.size();i++){
            if(m[i]==0){
                a.push_back(i);
            }
        }
        return a;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 450. Delete Node in a BST
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.
  </p>
  <p>
   Basically, the deletion can be divided into two stages:
  </p>
  <ol>
   <li>
    Search for a node to remove.
   </li>
   <li>
    If the node is found, delete the node.
   </li>
  </ol>
  <p>
   <b>
    Follow up:
   </b>
   Can you solve it with time complexity
   <code>
    O(height of tree)
   </code>
   ?
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/del_node_1.jpg" style="width: 800px; height: 214px;"/>
  <pre><strong>Input:</strong> root = [5,3,6,2,4,null,7], key = 3
<strong>Output:</strong> [5,4,6,2,null,null,7]
<strong>Explanation:</strong> Given key to delete is 3. So we find the node with value 3 and delete it.
One valid answer is [5,4,6,2,null,null,7], shown in the above BST.
Please notice that another valid answer is [5,2,6,null,4,null,7] and it's also accepted.
<img alt="" src="./output_files/del_node_supp.jpg" style="width: 350px; height: 255px;"/>
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [5,3,6,2,4,null,7], key = 0
<strong>Output:</strong> [5,3,6,2,4,null,7]
<strong>Explanation:</strong> The tree does not contain a node with value = 0.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [], key = 0
<strong>Output:</strong> []
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [0, 10
     <sup>
      4
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     -10
     <sup>
      5
     </sup>
     &lt;= Node.val &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    Each node has a
    <strong>
     unique
    </strong>
    value.
   </li>
   <li>
    <code>
     root
    </code>
    is a valid binary search tree.
   </li>
   <li>
    <code>
     -10
     <sup>
      5
     </sup>
     &lt;= key &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 450 -->
<pre>/*
 * @lc app=leetcode id=450 lang=cpp
 *
 * [450] Delete Node in a BST
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if(root){
            if(root-&gt;val&gt;key) root-&gt;left=deleteNode(root-&gt;left,key);
            else if(root-&gt;val&lt;key) root-&gt;right=deleteNode(root-&gt;right,key);
            else{
                if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL){
                    return NULL;
                }
                if (!root-&gt;left || !root-&gt;right){
                    if(root-&gt;left) return root-&gt;left;
                    return root-&gt;right;
                }
                TreeNode* temp=root-&gt;left;
                while(temp-&gt;right!=NULL) temp=temp-&gt;right;
                root-&gt;val=temp-&gt;val;
                root-&gt;left=deleteNode(root-&gt;left,temp-&gt;val);
            }
        }
        return root;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 457. Circular Array Loop
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are playing a game involving a
   <strong>
    circular
   </strong>
   array of non-zero integers
   <code>
    nums
   </code>
   . Each
   <code>
    nums[i]
   </code>
   denotes the number of indices forward/backward you must move if you are located at index
   <code>
    i
   </code>
   :
  </p>
  <ul>
   <li>
    If
    <code>
     nums[i]
    </code>
    is positive, move
    <code>
     nums[i]
    </code>
    steps
    <strong>
     forward
    </strong>
    , and
   </li>
   <li>
    If
    <code>
     nums[i]
    </code>
    is negative, move
    <code>
     nums[i]
    </code>
    steps
    <strong>
     backward
    </strong>
    .
   </li>
  </ul>
  <p>
   Since the array is
   <strong>
    circular
   </strong>
   , you may assume that moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element.
  </p>
  <p>
   A
   <strong>
    cycle
   </strong>
   in the array consists of a sequence of indices
   <code>
    seq
   </code>
   of length
   <code>
    k
   </code>
   where:
  </p>
  <ul>
   <li>
    Following the movement rules above results in the repeating index sequence
    <code>
     seq[0] -&gt; seq[1] -&gt; ... -&gt; seq[k - 1] -&gt; seq[0] -&gt; ...
    </code>
   </li>
   <li>
    Every
    <code>
     nums[seq[j]]
    </code>
    is either
    <strong>
     all positive
    </strong>
    or
    <strong>
     all negative
    </strong>
    .
   </li>
   <li>
    <code>
     k &gt; 1
    </code>
   </li>
  </ul>
  <p>
   Return
   <code>
    true
   </code>
   <em>
    if there is a
    <strong>
     cycle
    </strong>
    in
   </em>
   <code>
    nums
   </code>
   <em>
    , or
   </em>
   <code>
    false
   </code>
   <em>
    otherwise
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,-1,1,2,2]
<strong>Output:</strong> true
<strong>Explanation:</strong>
There is a cycle from index 0 -&gt; 2 -&gt; 3 -&gt; 0 -&gt; ...
The cycle's length is 3.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [-1,2]
<strong>Output:</strong> false
<strong>Explanation:</strong>
The sequence from index 1 -&gt; 1 -&gt; 1 -&gt; ... is not a cycle because the sequence's length is 1.
By definition the sequence's length must be strictly greater than 1 to be a cycle.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [-2,1,-1,-2,-2]
<strong>Output:</strong> false
<strong>Explanation:</strong>
The sequence from index 1 -&gt; 2 -&gt; 1 -&gt; ... is not a cycle because nums[1] is positive, but nums[2] is negative.
Every nums[seq[j]] must be either all positive or all negative.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 5000
    </code>
   </li>
   <li>
    <code>
     -1000 &lt;= nums[i] &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     nums[i] != 0
    </code>
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
   Could you solve it in
   <code>
    O(n)
   </code>
   time complexity and
   <code>
    O(1)
   </code>
   extra space complexity?
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 457 -->
<pre>/*
 * @lc app=leetcode id=457 lang=cpp
 *
 * [457] Circular Array Loop
 */

// @lc code=start
class Solution {
public:
    bool circularArrayLoop(vector&lt;int&gt;&amp; nums) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 460. LFU Cache
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Design and implement a data structure for a
   <a href="https://en.wikipedia.org/wiki/Least_frequently_used" target="_blank">
    Least Frequently Used (LFU)
   </a>
   cache.
  </p>
  <p>
   Implement the
   <code>
    LFUCache
   </code>
   class:
  </p>
  <ul>
   <li>
    <code>
     LFUCache(int capacity)
    </code>
    Initializes the object with the
    <code>
     capacity
    </code>
    of the data structure.
   </li>
   <li>
    <code>
     int get(int key)
    </code>
    Gets the value of the
    <code>
     key
    </code>
    if the
    <code>
     key
    </code>
    exists in the cache. Otherwise, returns
    <code>
     -1
    </code>
    .
   </li>
   <li>
    <code>
     void put(int key, int value)
    </code>
    Update the value of the
    <code>
     key
    </code>
    if present, or inserts the
    <code>
     key
    </code>
    if not already present. When the cache reaches its
    <code>
     capacity
    </code>
    , it should invalidate and remove the
    <strong>
     least frequently used
    </strong>
    key before inserting a new item. For this problem, when there is a
    <strong>
     tie
    </strong>
    (i.e., two or more keys with the same frequency), the
    <strong>
     least recently used
    </strong>
    <code>
     key
    </code>
    would be invalidated.
   </li>
  </ul>
  <p>
   To determine the least frequently used key, a
   <strong>
    use counter
   </strong>
   is maintained for each key in the cache. The key with the smallest
   <strong>
    use counter
   </strong>
   is the least frequently used key.
  </p>
  <p>
   When a key is first inserted into the cache, its
   <strong>
    use counter
   </strong>
   is set to
   <code>
    1
   </code>
   (due to the
   <code>
    put
   </code>
   operation). The
   <strong>
    use counter
   </strong>
   for a key in the cache is incremented either a
   <code>
    get
   </code>
   or
   <code>
    put
   </code>
   operation is called on it.
  </p>
  <p>
   The functions
   <code data-stringify-type="code">
    get
   </code>
   and
   <code data-stringify-type="code">
    put
   </code>
   must each run in
   <code>
    O(1)
   </code>
   average time complexity.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input</strong>
["LFUCache", "put", "put", "get", "put", "get", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]
<strong>Output</strong>
[null, null, null, 1, null, -1, 3, null, -1, 3, 4]

<strong>Explanation</strong>
// cnt(x) = the use counter for key x
// cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)
LFUCache lfu = new LFUCache(2);
lfu.put(1, 1);   // cache=[1,_], cnt(1)=1
lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1
lfu.get(1);      // return 1
                 // cache=[1,2], cnt(2)=1, cnt(1)=2
lfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.
                 // cache=[3,1], cnt(3)=1, cnt(1)=2
lfu.get(2);      // return -1 (not found)
lfu.get(3);      // return 3
                 // cache=[3,1], cnt(3)=2, cnt(1)=2
lfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.
                 // cache=[4,3], cnt(4)=1, cnt(3)=2
lfu.get(1);      // return -1 (not found)
lfu.get(3);      // return 3
                 // cache=[3,4], cnt(4)=1, cnt(3)=3
lfu.get(4);      // return 4
                 // cache=[3,4], cnt(4)=2, cnt(3)=3
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= capacity &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= key &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= value &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
   <li>
    At most
    <code>
     2 * 10
     <sup>
      5
     </sup>
    </code>
    calls will be made to
    <code>
     get
    </code>
    and
    <code>
     put
    </code>
    .
   </li>
  </ul>
  <p>
  </p>
  <span style="display: none;">
  </span>
 </div>
</div>
</body></html>
<!-- Solution for Question 460 -->
<pre>/*
 * @lc app=leetcode id=460 lang=cpp
 *
 * [460] LFU Cache
 */

// @lc code=start
class LFUCache {
public:
    map&lt;int,int&gt;count;
    map&lt;int,int&gt;m;

    int frame,time=0;

    priority_queue&lt;
    pair&lt;int,pair&lt;int,int&gt;&gt;,
    vector&lt;pair&lt;int,pair&lt;int,int&gt;&gt;&gt;,
    greater&lt;pair&lt;int,pair&lt;int,int&gt;&gt;&gt;&gt;pq;

    LFUCache(int capacity) {
        frame=capacity;
    }

    int get(int key) {
        if(count[key]==0) return -1;
        put(key,m[key]);
        return m[key];
    }

    void put(int key, int value) {
        if(frame==0) return;
        if(m.find(key)==m.end() &amp;&amp; m.size()==frame){
            // there are values from 1 to count[key] for a vairalbe in ascendig order so we pop unitl we get that count
            while(true){
                auto x=pq.top();
                if(count[x.second.second]==x.first){
                    m.erase(x.second.second);
                    count.erase(x.second.second);
                    pq.pop();
                    break;
                }
                pq.pop();
            }
        }
        count[key]++;
        pq.push({count[key],{time++,key}});
        m[key]=value;
    }
};

/**
 * Your LFUCache object will be instantiated and called as such:
 * LFUCache* obj = new LFUCache(capacity);
 * int param_1 = obj-&gt;get(key);
 * obj-&gt;put(key,value);
 */
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 464. Can I Win
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   In the "100 game" two players take turns adding, to a running total, any integer from
   <code>
    1
   </code>
   to
   <code>
    10
   </code>
   . The player who first causes the running total to
   <strong>
    reach or exceed
   </strong>
   100 wins.
  </p>
  <p>
   What if we change the game so that players
   <strong>
    cannot
   </strong>
   re-use integers?
  </p>
  <p>
   For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total &gt;= 100.
  </p>
  <p>
   Given two integers
   <code>
    maxChoosableInteger
   </code>
   and
   <code>
    desiredTotal
   </code>
   , return
   <code>
    true
   </code>
   if the first player to move can force a win, otherwise, return
   <code>
    false
   </code>
   . Assume both players play
   <strong>
    optimally
   </strong>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> maxChoosableInteger = 10, desiredTotal = 11
<strong>Output:</strong> false
<strong>Explanation:</strong>
No matter which integer the first player choose, the first player will lose.
The first player can choose an integer from 1 up to 10.
If the first player choose 1, the second player can only choose integers from 2 up to 10.
The second player will win by choosing 10 and get a total = 11, which is &gt;= desiredTotal.
Same with other integers chosen by the first player, the second player will always win.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> maxChoosableInteger = 10, desiredTotal = 0
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> maxChoosableInteger = 10, desiredTotal = 1
<strong>Output:</strong> true
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= maxChoosableInteger &lt;= 20
    </code>
   </li>
   <li>
    <code>
     0 &lt;= desiredTotal &lt;= 300
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 464 -->
<pre>/*
 * @lc app=leetcode id=464 lang=cpp
 *
 * [464] Can I Win
 */

// @lc code=start
class Solution {
public:
    bool canIWin(int maxChoosableInteger, int desiredTotal) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 470. Implement Rand10() Using Rand7()
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <strong>
    API
   </strong>
   <code>
    rand7()
   </code>
   that generates a uniform random integer in the range
   <code>
    [1, 7]
   </code>
   , write a function
   <code>
    rand10()
   </code>
   that generates a uniform random integer in the range
   <code>
    [1, 10]
   </code>
   . You can only call the API
   <code>
    rand7()
   </code>
   , and you shouldn't call any other API. Please
   <strong>
    do not
   </strong>
   use a language's built-in random API.
  </p>
  <p>
   Each test case will have one
   <strong>
    internal
   </strong>
   argument
   <code>
    n
   </code>
   , the number of times that your implemented function
   <code>
    rand10()
   </code>
   will be called while testing. Note that this is
   <strong>
    not an argument
   </strong>
   passed to
   <code>
    rand10()
   </code>
   .
  </p>
  <p>
   <strong>
    Follow up:
   </strong>
  </p>
  <ul>
   <li>
    What is the
    <a href="https://en.wikipedia.org/wiki/Expected_value" target="_blank">
     expected value
    </a>
    for the number of calls to
    <code>
     rand7()
    </code>
    function?
   </li>
   <li>
    Could you minimize the number of calls to
    <code>
     rand7()
    </code>
    ?
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1
<strong>Output:</strong> [2]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 2
<strong>Output:</strong> [2,8]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 3
<strong>Output:</strong> [3,8,10]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 470 -->
<pre>/*
 * @lc app=leetcode id=470 lang=cpp
 *
 * [470] Implement Rand10() Using Rand7()
 */

// @lc code=start
// The rand7() API is already defined for you.
// int rand7();
// @return a random integer in the range 1 to 7

class Solution {
public:
    int rand10() {
        int ans=40;
        while(ans&gt;=40){
            ans=(rand7()-1) * 7 + rand7()-1;
        }
        return ans % 10 +1;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 474. Ones and Zeroes
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an array of binary strings
   <code>
    strs
   </code>
   and two integers
   <code>
    m
   </code>
   and
   <code>
    n
   </code>
   .
  </p>
  <p>
   Return
   <em>
    the size of the largest subset of
    <code>
     strs
    </code>
    such that there are
    <strong>
     at most
    </strong>
   </em>
   <code>
    m
   </code>
   <em>
   </em>
   <code>
    0
   </code>
   <em>
    's and
   </em>
   <code>
    n
   </code>
   <em>
   </em>
   <code>
    1
   </code>
   <em>
    's in the subset
   </em>
   .
  </p>
  <p>
   A set
   <code>
    x
   </code>
   is a
   <strong>
    subset
   </strong>
   of a set
   <code>
    y
   </code>
   if all elements of
   <code>
    x
   </code>
   are also elements of
   <code>
    y
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> strs = ["10","0001","111001","1","0"], m = 5, n = 3
<strong>Output:</strong> 4
<strong>Explanation:</strong> The largest subset with at most 5 0's and 3 1's is {"10", "0001", "1", "0"}, so the answer is 4.
Other valid but smaller subsets include {"0001", "1"} and {"10", "1", "0"}.
{"111001"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> strs = ["10","0","1"], m = 1, n = 1
<strong>Output:</strong> 2
<b>Explanation:</b> The largest subset is {"0", "1"}, so the answer is 2.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= strs.length &lt;= 600
    </code>
   </li>
   <li>
    <code>
     1 &lt;= strs[i].length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     strs[i]
    </code>
    consists only of digits
    <code>
     '0'
    </code>
    and
    <code>
     '1'
    </code>
    .
   </li>
   <li>
    <code>
     1 &lt;= m, n &lt;= 100
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 474 -->
<pre>/*
 * @lc app=leetcode id=474 lang=cpp
 *
 * [474] Ones and Zeroes
 */

// @lc code=start
class Solution {
public:
    int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) {
        vector&lt;vector&lt;int&gt;&gt;dp(m+1,vector&lt;int&gt;(n+1));
        for(auto&amp; x:strs){
            int zeros=count(x.begin(),x.end(),&#x27;0&#x27;);
            int ones=x.size()-zeros;
            for(int i=m;i&gt;=zeros;i--){
                for(int j=n;j&gt;=ones;j--){
                    dp[i][j]=max(dp[i][j],1+dp[i-zeros][j-ones]);
                }
            }
        }
        return dp[m][n];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 475. Heaters
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses.
  </p>
  <p>
   Every house can be warmed, as long as the house is within the heater's warm radius range.
  </p>
  <p>
   Given the positions of
   <code>
    houses
   </code>
   and
   <code>
    heaters
   </code>
   on a horizontal line, return
   <em>
    the minimum radius standard of heaters so that those heaters could cover all houses.
   </em>
  </p>
  <p>
   <strong>
    Notice
   </strong>
   that all the
   <code>
    heaters
   </code>
   follow your radius standard, and the warm radius will the same.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> houses = [1,2,3], heaters = [2]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> houses = [1,2,3,4], heaters = [1,4]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The two heater was placed in the position 1 and 4. We need to use radius 1 standard, then all the houses can be warmed.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> houses = [1,5], heaters = [2]
<strong>Output:</strong> 3
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= houses.length, heaters.length &lt;= 3 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     1 &lt;= houses[i], heaters[i] &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 475 -->
<pre>/*
 * @lc app=leetcode id=475 lang=cpp
 *
 * [475] Heaters
 */

// @lc code=start
class Solution {
public:
    int findRadius(vector&lt;int&gt;&amp; houses, vector&lt;int&gt;&amp; heaters) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 476. Number Complement
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   The
   <strong>
    complement
   </strong>
   of an integer is the integer you get when you flip all the
   <code>
    0
   </code>
   's to
   <code>
    1
   </code>
   's and all the
   <code>
    1
   </code>
   's to
   <code>
    0
   </code>
   's in its binary representation.
  </p>
  <ul>
   <li>
    For example, The integer
    <code>
     5
    </code>
    is
    <code>
     "101"
    </code>
    in binary and its
    <strong>
     complement
    </strong>
    is
    <code>
     "010"
    </code>
    which is the integer
    <code>
     2
    </code>
    .
   </li>
  </ul>
  <p>
   Given an integer
   <code>
    num
   </code>
   , return
   <em>
    its complement
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = 5
<strong>Output:</strong> 2
<strong>Explanation:</strong> The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = 1
<strong>Output:</strong> 0
<strong>Explanation:</strong> The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= num &lt; 2
     <sup>
      31
     </sup>
    </code>
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Note:
   </strong>
   This question is the same as 1009:
   <a href="https://leetcode.com/problems/complement-of-base-10-integer/" target="_blank">
    https://leetcode.com/problems/complement-of-base-10-integer/
   </a>
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 476 -->
<pre>/*
 * @lc app=leetcode id=476 lang=cpp
 *
 * [476] Number Complement
 */

// @lc code=start
class Solution {
public:
    int findComplement(int num) {
        int mask=~0;
        while(mask &amp; num ) mask=mask&lt;&lt;1;
        return ~num ^ mask;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 485. Max Consecutive Ones
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a binary array
   <code>
    nums
   </code>
   , return
   <em>
    the maximum number of consecutive
   </em>
   <code>
    1
   </code>
   <em>
    's in the array
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,1,0,1,1,1]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,0,1,1,0,1]
<strong>Output:</strong> 2
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     nums[i]
    </code>
    is either
    <code>
     0
    </code>
    or
    <code>
     1
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 485 -->
<pre>/*
 * @lc app=leetcode id=485 lang=cpp
 *
 * [485] Max Consecutive Ones
 */

// @lc code=start
class Solution {
public:
    int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) {
        int maxx=0;
        int i=0;
        int count=0;
        for(int x:nums){
            if(x==1){
                count++;
                i++;
            }
            else{
                i++;
                maxx=max(maxx,count);
                count=0;
            }
        }
        maxx=max(maxx,count);
        return maxx;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 493. Reverse Pairs
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   , return
   <em>
    the number of
    <strong>
     reverse pairs
    </strong>
    in the array
   </em>
   .
  </p>
  <p>
   A reverse pair is a pair
   <code>
    (i, j)
   </code>
   where
   <code>
    0 &lt;= i &lt; j &lt; nums.length
   </code>
   and
   <code>
    nums[i] &gt; 2 * nums[j]
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,3,2,3,1]
<strong>Output:</strong> 2
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,4,3,5,1]
<strong>Output:</strong> 3
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 5 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= nums[i] &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 493 -->
<pre>/*
 * @lc app=leetcode id=493 lang=cpp
 *
 * [493] Reverse Pairs
 */

// @lc code=start
class Solution {
public:
    int reversePairs(vector&lt;int&gt;&amp; nums) {
        map&lt;pair&lt;long long,long long&gt;,int&gt;m;
        int ans=0;
        vector&lt;long long&gt;num;
        for(int x:nums){
            num.push_back(x);
        }
int reversePairCount = 0;
for(int i=0; i&lt;num.size(); i++) {
	for(int j=i+1; j&lt;num.size(); j++) {
		if( num[i] &gt; 2*num[j]) reversePairCount++;
	}
}
return reversePairCount;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 494. Target Sum
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an integer array
   <code>
    nums
   </code>
   and an integer
   <code>
    target
   </code>
   .
  </p>
  <p>
   You want to build an
   <strong>
    expression
   </strong>
   out of nums by adding one of the symbols
   <code>
    '+'
   </code>
   and
   <code>
    '-'
   </code>
   before each integer in nums and then concatenate all the integers.
  </p>
  <ul>
   <li>
    For example, if
    <code>
     nums = [2, 1]
    </code>
    , you can add a
    <code>
     '+'
    </code>
    before
    <code>
     2
    </code>
    and a
    <code>
     '-'
    </code>
    before
    <code>
     1
    </code>
    and concatenate them to build the expression
    <code>
     "+2-1"
    </code>
    .
   </li>
  </ul>
  <p>
   Return the number of different
   <strong>
    expressions
   </strong>
   that you can build, which evaluates to
   <code>
    target
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,1,1,1,1], target = 3
<strong>Output:</strong> 5
<strong>Explanation:</strong> There are 5 ways to assign symbols to make the sum of nums be target 3.
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1], target = 1
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 20
    </code>
   </li>
   <li>
    <code>
     0 &lt;= nums[i] &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     0 &lt;= sum(nums[i]) &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     -1000 &lt;= target &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 494 -->
<pre>/*
 * @lc app=leetcode id=494 lang=cpp
 *
 * [494] Target Sum
 */

// @lc code=start
class Solution {
public:
    int findTargetSumWays(vector&lt;int&gt;&amp; a, int target) {
        int n= a.size();
        int sum=0;
        for(int i=0; i&lt;n; i++){
            sum+=a[i];
        }
        if(target&gt;sum || (target+sum)%2!=0) return 0;
        vector&lt;vector&lt;int&gt;&gt;dp(n+1,vector&lt;int&gt;(target+1));
        dp[0][0]=1;
        for(int i=1;i&lt;=n;i++){
            for(int j=0;j&lt;=target;j++){
                if(i==0) dp[i][j] = 0;

                else if (j==0) dp[i][j] =1;

                else if(a[i-1]&lt;=j) dp[i][j]= dp[i-1][j-a[i-1]]+dp[i-1][j];
                else dp[i][j]=dp[i-1][j];
            }
        }
        return dp[n][target];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 496. Next Greater Element I
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   The
   <strong>
    next greater element
   </strong>
   of some element
   <code>
    x
   </code>
   in an array is the
   <strong>
    first greater
   </strong>
   element that is
   <strong>
    to the right
   </strong>
   of
   <code>
    x
   </code>
   in the same array.
  </p>
  <p>
   You are given two
   <strong>
    distinct 0-indexed
   </strong>
   integer arrays
   <code>
    nums1
   </code>
   and
   <code>
    nums2
   </code>
   , where
   <code>
    nums1
   </code>
   is a subset of
   <code>
    nums2
   </code>
   .
  </p>
  <p>
   For each
   <code>
    0 &lt;= i &lt; nums1.length
   </code>
   , find the index
   <code>
    j
   </code>
   such that
   <code>
    nums1[i] == nums2[j]
   </code>
   and determine the
   <strong>
    next greater element
   </strong>
   of
   <code>
    nums2[j]
   </code>
   in
   <code>
    nums2
   </code>
   . If there is no next greater element, then the answer for this query is
   <code>
    -1
   </code>
   .
  </p>
  <p>
   Return
   <em>
    an array
   </em>
   <code>
    ans
   </code>
   <em>
    of length
   </em>
   <code>
    nums1.length
   </code>
   <em>
    such that
   </em>
   <code>
    ans[i]
   </code>
   <em>
    is the
    <strong>
     next greater element
    </strong>
    as described above.
   </em>
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums1 = [4,1,2], nums2 = [1,3,4,2]
<strong>Output:</strong> [-1,3,-1]
<strong>Explanation:</strong> The next greater element for each value of nums1 is as follows:
- 4 is underlined in nums2 = [1,3,<u>4</u>,2]. There is no next greater element, so the answer is -1.
- 1 is underlined in nums2 = [<u>1</u>,3,4,2]. The next greater element is 3.
- 2 is underlined in nums2 = [1,3,4,<u>2</u>]. There is no next greater element, so the answer is -1.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums1 = [2,4], nums2 = [1,2,3,4]
<strong>Output:</strong> [3,-1]
<strong>Explanation:</strong> The next greater element for each value of nums1 is as follows:
- 2 is underlined in nums2 = [1,<u>2</u>,3,4]. The next greater element is 3.
- 4 is underlined in nums2 = [1,2,3,<u>4</u>]. There is no next greater element, so the answer is -1.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     0 &lt;= nums1[i], nums2[i] &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    All integers in
    <code>
     nums1
    </code>
    and
    <code>
     nums2
    </code>
    are
    <strong>
     unique
    </strong>
    .
   </li>
   <li>
    All the integers of
    <code>
     nums1
    </code>
    also appear in
    <code>
     nums2
    </code>
    .
   </li>
  </ul>
  <p>
  </p>
  <strong>
   Follow up:
  </strong>
  Could you find an
  <code>
   O(nums1.length + nums2.length)
  </code>
  solution?
 </div>
</div>
</body></html>
<!-- Solution for Question 496 -->
<pre>/*
 * @lc app=leetcode id=496 lang=cpp
 *
 * [496] Next Greater Element I
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 500. Keyboard Row
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of strings
   <code>
    words
   </code>
   , return
   <em>
    the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below
   </em>
   .
  </p>
  <p>
   In the
   <strong>
    American keyboard
   </strong>
   :
  </p>
  <ul>
   <li>
    the first row consists of the characters
    <code>
     "qwertyuiop"
    </code>
    ,
   </li>
   <li>
    the second row consists of the characters
    <code>
     "asdfghjkl"
    </code>
    , and
   </li>
   <li>
    the third row consists of the characters
    <code>
     "zxcvbnm"
    </code>
    .
   </li>
  </ul>
  <img alt="" src="./output_files/keyboard.png" style="width: 800px; max-width: 600px; height: 267px;"/>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> words = ["Hello","Alaska","Dad","Peace"]
<strong>Output:</strong> ["Alaska","Dad"]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> words = ["omk"]
<strong>Output:</strong> []
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> words = ["adsdf","sfd"]
<strong>Output:</strong> ["adsdf","sfd"]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= words.length &lt;= 20
    </code>
   </li>
   <li>
    <code>
     1 &lt;= words[i].length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     words[i]
    </code>
    consists of English letters (both lowercase and uppercase).
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 500 -->
<pre>/*
 * @lc app=leetcode id=500 lang=cpp
 *
 * [500] Keyboard Row
 */

// @lc code=start
class Solution {
public:
    vector&lt;string&gt; findWords(vector&lt;string&gt;&amp; words) {
        vector&lt;int&gt; dict{1,2,2,1,0,1,1,1,0,1,1,1,2,2,0,0,0,0,1,0,0,2,0,2,0,2};
        vector&lt;string&gt;ans;
        for(string x:words){
            int main=dict[(int)(tolower(x[0])-&#x27;a&#x27;)];
            ans.push_back(x);
            for(int i=1; i&lt;x.length(); i++) {
                if(dict[(int)(tolower(x[i])-&#x27;a&#x27;)]!=main){
                    ans.pop_back();
                    break;
                }
            }
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 504. Base 7
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer
   <code>
    num
   </code>
   , return
   <em>
    a string of its
    <strong>
     base 7
    </strong>
    representation
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = 100
<strong>Output:</strong> "202"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = -7
<strong>Output:</strong> "-10"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     -10
     <sup>
      7
     </sup>
     &lt;= num &lt;= 10
     <sup>
      7
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 504 -->
<pre>/*
 * @lc app=leetcode id=504 lang=cpp
 *
 * [504] Base 7
 */

// @lc code=start
class Solution {
public:
    string convertToBase7(int num) {
        string s=&quot;&quot;;
        if(num==0) return &quot;0&quot;;
        int sign=1;
        if(num&lt;0) sign=-1;
        while(num!=0){
            s=to_string(abs(num%7))+s;
            num=num/7;
        }
        return sign==-1?&#x27;-&#x27;+s:s;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 507. Perfect Number
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   A
   <a href="https://en.wikipedia.org/wiki/Perfect_number" target="_blank">
    <strong>
     perfect number
    </strong>
   </a>
   is a
   <strong>
    positive integer
   </strong>
   that is equal to the sum of its
   <strong>
    positive divisors
   </strong>
   , excluding the number itself. A
   <strong>
    divisor
   </strong>
   of an integer
   <code>
    x
   </code>
   is an integer that can divide
   <code>
    x
   </code>
   evenly.
  </p>
  <p>
   Given an integer
   <code>
    n
   </code>
   , return
   <code>
    true
   </code>
   <em>
    if
   </em>
   <code>
    n
   </code>
   <em>
    is a perfect number, otherwise return
   </em>
   <code>
    false
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = 28
<strong>Output:</strong> true
<strong>Explanation:</strong> 28 = 1 + 2 + 4 + 7 + 14
1, 2, 4, 7, and 14 are all divisors of 28.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = 6
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = 496
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = 8128
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> num = 2
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= num &lt;= 10
     <sup>
      8
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 507 -->
<pre>/*
 * @lc app=leetcode id=507 lang=cpp
 *
 * [507] Perfect Number
 */

// @lc code=start
class Solution {
public:
    bool checkPerfectNumber(int num) {
        int ans=0;
        int i=1;
        if(num==1) return false;
        while(i!=num-1){
            if(num%i==0) ans=ans+i;
            i++;
        }
        return ans==num;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 513. Find Bottom Left Tree Value
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree, return the leftmost value in the last row of the tree.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/tree1(3).jpg" style="width: 302px; height: 182px;"/>
  <pre><strong>Input:</strong> root = [2,1,3]
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/tree2(2).jpg" style="width: 432px; height: 421px;"/>
  <pre><strong>Input:</strong> root = [1,2,3,4,null,5,6,null,null,7]
<strong>Output:</strong> 7
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [1, 10
     <sup>
      4
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= Node.val &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 513 -->
<pre>/*
 * @lc app=leetcode id=513 lang=cpp
 *
 * [513] Find Bottom Left Tree Value
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        if(!root) return -1;
        queue&lt;TreeNode*&gt;q;
        q.push(root);
        int leftele=root-&gt;val;
        while(!q.empty()) {
            int n=q.size();
            leftele=q.front()-&gt;val;
            for(int i=0; i&lt;n; i++){
                TreeNode* node = q.front();
                q.pop();
                if(node-&gt;left)q.push(node-&gt;left);
                if(node-&gt;right)q.push(node-&gt;right);
            }
        }
        return leftele;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 515. Find Largest Value in Each Tree Row
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree, return
   <em>
    an array of the largest value in each row
   </em>
   of the tree
   <strong>
    (0-indexed)
   </strong>
   .
  </p>
  <p>
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/largest_e1.jpg" style="width: 450px; height: 258px;"/>
  <pre><strong>Input:</strong> root = [1,3,2,5,3,null,9]
<strong>Output:</strong> [1,3,9]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1,2,3]
<strong>Output:</strong> [1,3]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1]
<strong>Output:</strong> [1]
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1,null,2]
<strong>Output:</strong> [1,2]
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = []
<strong>Output:</strong> []
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree will be in the range
    <code>
     [0, 10
     <sup>
      4
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     -2
     <sup>
      31
     </sup>
     &lt;= Node.val &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 515 -->
<pre>/*
 * @lc app=leetcode id=515 lang=cpp
 *
 * [515] Find Largest Value in Each Tree Row
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector&lt;int&gt; largestValues(TreeNode* root) {
        if(!root) return {};
        vector&lt;int&gt;ans;
        queue&lt;TreeNode*&gt;q;
        q.push(root);
        //ans.push_back(root-&gt;val);
        while(!q.empty()) {
            int n=q.size();
            int maxele=q.front()-&gt;val;
            for(int i=0; i&lt;n; i++){
                TreeNode* node = q.front();
                q.pop();
                maxele=max(maxele,node-&gt;val);
                if(node-&gt;left)q.push(node-&gt;left);
                if(node-&gt;right)q.push(node-&gt;right);
            }
            ans.push_back(maxele);
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 516. Longest Palindromic Subsequence
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    s
   </code>
   , find
   <em>
    the longest palindromic
    <strong>
     subsequence
    </strong>
    's length in
   </em>
   <code>
    s
   </code>
   .
  </p>
  <p>
   A
   <strong>
    subsequence
   </strong>
   is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "bbbab"
<strong>Output:</strong> 4
<strong>Explanation:</strong> One possible longest palindromic subsequence is "bbbb".
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "cbbd"
<strong>Output:</strong> 2
<strong>Explanation:</strong> One possible longest palindromic subsequence is "bb".
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consists only of lowercase English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 516 -->
<pre>/*
 * @lc app=leetcode id=516 lang=cpp
 *
 * [516] Longest Palindromic Subsequence
 */

// @lc code=start
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.length();
        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0));
        for(int i = 0; i &lt; n; i++){
            dp[i][i] = 1;
        }
        for(int len = 1; len &lt; n; len++){
            for(int i = 0; i + len &lt; n; i++){
                int j = i + len;
                if(s[i] == s[j]){
                    dp[i][j] = 2 + dp[i + 1][j - 1];
                }
                else{
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][n-1];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 520. Detect Capital
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   We define the usage of capitals in a word to be right when one of the following cases holds:
  </p>
  <ul>
   <li>
    All letters in this word are capitals, like
    <code>
     "USA"
    </code>
    .
   </li>
   <li>
    All letters in this word are not capitals, like
    <code>
     "leetcode"
    </code>
    .
   </li>
   <li>
    Only the first letter in this word is capital, like
    <code>
     "Google"
    </code>
    .
   </li>
  </ul>
  <p>
   Given a string
   <code>
    word
   </code>
   , return
   <code>
    true
   </code>
   if the usage of capitals in it is right.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> word = "USA"
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> word = "FlaG"
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= word.length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     word
    </code>
    consists of lowercase and uppercase English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 520 -->
<pre>/*
 * @lc app=leetcode id=520 lang=cpp
 *
 * [520] Detect Capital
 */

// @lc code=start
class Solution {
public:
    bool detectCapitalUse(string word) {
        int lo=0,up=0;
        for(int i = word.length()-1; i &gt;= 1; i--){
            if(islower(word[i])) lo++;
            else up++;
        }
        if(isupper(word[0]) &amp;&amp; (up==0 || up==word.length()-1)) return true;
        else if(islower(word[0]) &amp;&amp; lo==word.length()-1) return true;
        return false;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 521. Longest Uncommon Subsequence I
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two strings
   <code>
    a
   </code>
   and
   <code>
    b
   </code>
   , return
   <em>
    the length of the
    <strong>
     longest uncommon subsequence
    </strong>
    between
   </em>
   <code>
    a
   </code>
   <em>
    and
   </em>
   <code>
    b
   </code>
   . If the longest uncommon subsequence does not exist, return
   <code>
    -1
   </code>
   .
  </p>
  <p>
   An
   <strong>
    uncommon subsequence
   </strong>
   between two strings is a string that is a
   <strong>
    subsequence of one but not the other
   </strong>
   .
  </p>
  <p>
   A
   <strong>
    subsequence
   </strong>
   of a string
   <code>
    s
   </code>
   is a string that can be obtained after deleting any number of characters from
   <code>
    s
   </code>
   .
  </p>
  <ul>
   <li>
    For example,
    <code>
     "abc"
    </code>
    is a subsequence of
    <code>
     "aebdc"
    </code>
    because you can delete the underlined characters in
    <code>
     "a
     <u>
      e
     </u>
     b
     <u>
      d
     </u>
     c"
    </code>
    to get
    <code>
     "abc"
    </code>
    . Other subsequences of
    <code>
     "aebdc"
    </code>
    include
    <code>
     "aebdc"
    </code>
    ,
    <code>
     "aeb"
    </code>
    , and
    <code>
     ""
    </code>
    (empty string).
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> a = "aba", b = "cdc"
<strong>Output:</strong> 3
<strong>Explanation:</strong> One longest uncommon subsequence is "aba" because "aba" is a subsequence of "aba" but not "cdc".
Note that "cdc" is also a longest uncommon subsequence.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> a = "aaa", b = "bbb"
<strong>Output:</strong> 3
<strong>Explanation:</strong> The longest uncommon subsequences are "aaa" and "bbb".
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> a = "aaa", b = "aaa"
<strong>Output:</strong> -1
<strong>Explanation:</strong> Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= a.length, b.length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     a
    </code>
    and
    <code>
     b
    </code>
    consist of lower-case English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 521 -->
<pre>/*
 * @lc app=leetcode id=521 lang=cpp
 *
 * [521] Longest Uncommon Subsequence I
 */

// @lc code=start
class Solution {
public:
    int findLUSlength(string a, string b) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 526. Beautiful Arrangement
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Suppose you have
   <code>
    n
   </code>
   integers labeled
   <code>
    1
   </code>
   through
   <code>
    n
   </code>
   . A permutation of those
   <code>
    n
   </code>
   integers
   <code>
    perm
   </code>
   (
   <strong>
    1-indexed
   </strong>
   ) is considered a
   <strong>
    beautiful arrangement
   </strong>
   if for every
   <code>
    i
   </code>
   (
   <code>
    1 &lt;= i &lt;= n
   </code>
   ),
   <strong>
    either
   </strong>
   of the following is true:
  </p>
  <ul>
   <li>
    <code>
     perm[i]
    </code>
    is divisible by
    <code>
     i
    </code>
    .
   </li>
   <li>
    <code>
     i
    </code>
    is divisible by
    <code>
     perm[i]
    </code>
    .
   </li>
  </ul>
  <p>
   Given an integer
   <code>
    n
   </code>
   , return
   <em>
    the
    <strong>
     number
    </strong>
    of the
    <strong>
     beautiful arrangements
    </strong>
    that you can construct
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 2
<strong>Output:</strong> 2
<b>Explanation:</b> 
The first beautiful arrangement is [1,2]:
    - perm[1] = 1 is divisible by i = 1
    - perm[2] = 2 is divisible by i = 2
The second beautiful arrangement is [2,1]:
    - perm[1] = 2 is divisible by i = 1
    - i = 2 is divisible by perm[2] = 1
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 15
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 526 -->
<pre>/*
 * @lc app=leetcode id=526 lang=cpp
 *
 * [526] Beautiful Arrangement
 */

// @lc code=start
class Solution {
public:
    int count=0;
    void permutations(vector&lt;int&gt;&amp; a,int j){
        if(j==a.size()){
            count++;
            return;
        }
        for(int i=j;i&lt;a.size();i++){
            swap(a[i],a[j]);
            if((a[j]%(j+1)==0 || (j+1)%a[j]==0)){
                permutations(a,j+1);
            }
            swap(a[i],a[j]);
        }
    }
    int countArrangement(int n) {
        vector&lt;int&gt;a;
        for(int i=0;i&lt;n;i++) a.push_back(i+1);
        permutations(a,0);
        return count;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 541. Reverse String II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    s
   </code>
   and an integer
   <code>
    k
   </code>
   , reverse the first
   <code>
    k
   </code>
   characters for every
   <code>
    2k
   </code>
   characters counting from the start of the string.
  </p>
  <p>
   If there are fewer than
   <code>
    k
   </code>
   characters left, reverse all of them. If there are less than
   <code>
    2k
   </code>
   but greater than or equal to
   <code>
    k
   </code>
   characters, then reverse the first
   <code>
    k
   </code>
   characters and left the other as original.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "abcdefg", k = 2
<strong>Output:</strong> "bacdfeg"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "abcd", k = 2
<strong>Output:</strong> "bacd"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consists of only lowercase English letters.
   </li>
   <li>
    <code>
     1 &lt;= k &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 541 -->
<pre>/*
 * @lc app=leetcode id=541 lang=cpp
 *
 * [541] Reverse String II
 */

// @lc code=start
class Solution {
public:
    string reverseStr(string s, int k) {
        for(int i = 0; i &lt; s.size(); i=i+k+k) {
            if(i+k&lt;s.size()){
                reverse(s.begin()+i, s.begin()+i+k);
            }
            else if(i+k&gt;=s.size()){
                reverse(s.begin()+i, s.end()); 
            }
        }
        return s;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 542. 01 Matrix
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an
   <code>
    m x n
   </code>
   binary matrix
   <code>
    mat
   </code>
   , return
   <em>
    the distance of the nearest
   </em>
   <code>
    0
   </code>
   <em>
    for each cell
   </em>
   .
  </p>
  <p>
   The distance between two adjacent cells is
   <code>
    1
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/01-1-grid.jpg" style="width: 253px; height: 253px;"/>
  <pre><strong>Input:</strong> mat = [[0,0,0],[0,1,0],[0,0,0]]
<strong>Output:</strong> [[0,0,0],[0,1,0],[0,0,0]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/01-2-grid.jpg" style="width: 253px; height: 253px;"/>
  <pre><strong>Input:</strong> mat = [[0,0,0],[0,1,0],[1,1,1]]
<strong>Output:</strong> [[0,0,0],[0,1,0],[1,2,1]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == mat.length
    </code>
   </li>
   <li>
    <code>
     n == mat[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m, n &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m * n &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     mat[i][j]
    </code>
    is either
    <code>
     0
    </code>
    or
    <code>
     1
    </code>
    .
   </li>
   <li>
    There is at least one
    <code>
     0
    </code>
    in
    <code>
     mat
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 542 -->
<pre>/*
 * @lc app=leetcode id=542 lang=cpp
 *
 * [542] 01 Matrix
 */

// @lc code=start
class Solution {
public:

    vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        queue&lt;pair&lt;int,int&gt;&gt;q;
        vector&lt;vector&lt;int&gt;&gt;dis{{1,0},{-1,0},{0,1},{0,-1}};
        int m=grid.size(),n=grid[0].size();
        if(m*n==1) return grid;
        int maxx=-1;
        
        vector&lt;vector&lt;int&gt;&gt; ans(m,vector&lt;int&gt;(n,-1));
        for(int i=0; i&lt;m; i++){
            for(int j=0; j&lt;n; j++){
                if(grid[i][j]==0){
                    q.push({i,j});
                    ans[i][j]=0;
                }
            }
        }

        while(!q.empty()){
            pair&lt;int,int&gt;p=q.front();
            q.pop();
            int i=p.first;
            int j=p.second;
            for(auto x:dis){
                int row=i+x[0];
                int col=j+x[1];
                if(row&gt;=0 &amp;&amp; col&gt;=0 &amp;&amp; row&lt;m&amp;&amp; col&lt;n &amp;&amp; ans[row][col]==-1){
                        ans[row][col]=ans[i][j]+1;
                        q.push({row,col});
                    }
                }
        }

        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 543. Diameter of Binary Tree
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree, return
   <em>
    the length of the
    <strong>
     diameter
    </strong>
    of the tree
   </em>
   .
  </p>
  <p>
   The
   <strong>
    diameter
   </strong>
   of a binary tree is the
   <strong>
    length
   </strong>
   of the longest path between any two nodes in a tree. This path may or may not pass through the
   <code>
    root
   </code>
   .
  </p>
  <p>
   The
   <strong>
    length
   </strong>
   of a path between two nodes is represented by the number of edges between them.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/diamtree.jpg" style="width: 292px; height: 302px;"/>
  <pre><strong>Input:</strong> root = [1,2,3,4,5]
<strong>Output:</strong> 3
<strong>Explanation:</strong> 3 is the length of the path [4,2,1,3] or [5,2,1,3].
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1,2]
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [1, 10
     <sup>
      4
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     -100 &lt;= Node.val &lt;= 100
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 543 -->
<pre>/*
 * @lc app=leetcode id=543 lang=cpp
 *
 * [543] Diameter of Binary Tree
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int height(TreeNode * root){
        if(root==NULL) return 0;
        return 1+max(height(root-&gt;left),height(root-&gt;right));
    }
    int diameterOfBinaryTree(TreeNode* root){
        if(root==NULL) return 0;
        return max({height(root-&gt;right)+height(root-&gt;left),diameterOfBinaryTree(root-&gt;right),diameterOfBinaryTree(root-&gt;left)});
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 547. Number of Provinces
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   There are
   <code>
    n
   </code>
   cities. Some of them are connected, while some are not. If city
   <code>
    a
   </code>
   is connected directly with city
   <code>
    b
   </code>
   , and city
   <code>
    b
   </code>
   is connected directly with city
   <code>
    c
   </code>
   , then city
   <code>
    a
   </code>
   is connected indirectly with city
   <code>
    c
   </code>
   .
  </p>
  <p>
   A
   <strong>
    province
   </strong>
   is a group of directly or indirectly connected cities and no other cities outside of the group.
  </p>
  <p>
   You are given an
   <code>
    n x n
   </code>
   matrix
   <code>
    isConnected
   </code>
   where
   <code>
    isConnected[i][j] = 1
   </code>
   if the
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   city and the
   <code>
    j
    <sup>
     th
    </sup>
   </code>
   city are directly connected, and
   <code>
    isConnected[i][j] = 0
   </code>
   otherwise.
  </p>
  <p>
   Return
   <em>
    the total number of
    <strong>
     provinces
    </strong>
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/graph1.jpg" style="width: 222px; height: 142px;"/>
  <pre><strong>Input:</strong> isConnected = [[1,1,0],[1,1,0],[0,0,1]]
<strong>Output:</strong> 2
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/graph2.jpg" style="width: 222px; height: 142px;"/>
  <pre><strong>Input:</strong> isConnected = [[1,0,0],[0,1,0],[0,0,1]]
<strong>Output:</strong> 3
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 200
    </code>
   </li>
   <li>
    <code>
     n == isConnected.length
    </code>
   </li>
   <li>
    <code>
     n == isConnected[i].length
    </code>
   </li>
   <li>
    <code>
     isConnected[i][j]
    </code>
    is
    <code>
     1
    </code>
    or
    <code>
     0
    </code>
    .
   </li>
   <li>
    <code>
     isConnected[i][i] == 1
    </code>
   </li>
   <li>
    <code>
     isConnected[i][j] == isConnected[j][i]
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 547 -->
<pre>/*
 * @lc app=leetcode id=547 lang=cpp
 *
 * [547] Number of Provinces
 */

// @lc code=start
class Solution {
public:
    int findCircleNum(vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 560. Subarray Sum Equals K
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of integers
   <code>
    nums
   </code>
   and an integer
   <code>
    k
   </code>
   , return
   <em>
    the total number of continuous subarrays whose sum equals to
    <code>
     k
    </code>
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,1,1], k = 2
<strong>Output:</strong> 2
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3], k = 3
<strong>Output:</strong> 2
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 2 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -1000 &lt;= nums[i] &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      7
     </sup>
     &lt;= k &lt;= 10
     <sup>
      7
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 560 -->
<pre>/*
 * @lc app=leetcode id=560 lang=cpp
 *
 * [560] Subarray Sum Equals K
 */

// @lc code=start
class Solution {
public:
    int subarraySum(vector&lt;int&gt;&amp; nums, int k) {
        map&lt;int,int&gt;m;
        if(nums.size() ==1){
            if(nums[0]==k) return 1;
            return 0;
        }
        int sum=0,ans=0;
        m[0]=1;
        for(int x:nums){
            sum=sum+x;
            cout&lt;&lt;sum-k;
            if(m.find(sum-k) != m.end()){
                ans=ans+m[sum-k];
            }
            m[sum]++;
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 561. Array Partition I
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   of
   <code>
    2n
   </code>
   integers, group these integers into
   <code>
    n
   </code>
   pairs
   <code>
    (a
    <sub>
     1
    </sub>
    , b
    <sub>
     1
    </sub>
    ), (a
    <sub>
     2
    </sub>
    , b
    <sub>
     2
    </sub>
    ), ..., (a
    <sub>
     n
    </sub>
    , b
    <sub>
     n
    </sub>
    )
   </code>
   such that the sum of
   <code>
    min(a
    <sub>
     i
    </sub>
    , b
    <sub>
     i
    </sub>
    )
   </code>
   for all
   <code>
    i
   </code>
   is
   <strong>
    maximized
   </strong>
   . Return
   <em>
    the maximized sum
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,4,3,2]
<strong>Output:</strong> 4
<strong>Explanation:</strong> All possible pairings (ignoring the ordering of elements) are:
1. (1, 4), (2, 3) -&gt; min(1, 4) + min(2, 3) = 1 + 2 = 3
2. (1, 3), (2, 4) -&gt; min(1, 3) + min(2, 4) = 1 + 2 = 3
3. (1, 2), (3, 4) -&gt; min(1, 2) + min(3, 4) = 1 + 3 = 4
So the maximum possible sum is 4.</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [6,2,6,5,1,2]
<strong>Output:</strong> 9
<strong>Explanation:</strong> The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     nums.length == 2 * n
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= nums[i] &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 561 -->
<pre>/*
 * @lc app=leetcode id=561 lang=cpp
 *
 * [561] Array Partition
 */

// @lc code=start
class Solution {
public:
    int arrayPairSum(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());
        int ans=0;
        for(int i = 0; i &lt; nums.size()-1;i++) {
            ans=ans+min(nums[i], nums[i+1]);
            i++;
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 563. Binary Tree Tilt
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree, return
   <em>
    the sum of every tree node's
    <strong>
     tilt
    </strong>
    .
   </em>
  </p>
  <p>
   The
   <strong>
    tilt
   </strong>
   of a tree node is the
   <b>
    absolute difference
   </b>
   between the sum of all left subtree node
   <strong>
    values
   </strong>
   and all right subtree node
   <strong>
    values
   </strong>
   . If a node does not have a left child, then the sum of the left subtree node
   <strong>
    values
   </strong>
   is treated as
   <code>
    0
   </code>
   . The rule is similar if there the node does not have a right child.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/tilt1.jpg" style="width: 712px; height: 182px;"/>
  <pre><strong>Input:</strong> root = [1,2,3]
<strong>Output:</strong> 1
<strong>Explanation:</strong> 
Tilt of node 2 : |0-0| = 0 (no children)
Tilt of node 3 : |0-0| = 0 (no children)
Tilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3)
Sum of every tilt : 0 + 0 + 1 = 1
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/tilt2.jpg" style="width: 800px; height: 203px;"/>
  <pre><strong>Input:</strong> root = [4,2,9,3,5,null,7]
<strong>Output:</strong> 15
<strong>Explanation:</strong> 
Tilt of node 3 : |0-0| = 0 (no children)
Tilt of node 5 : |0-0| = 0 (no children)
Tilt of node 7 : |0-0| = 0 (no children)
Tilt of node 2 : |3-5| = 2 (left subtree is just left child, so sum is 3; right subtree is just right child, so sum is 5)
Tilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right subtree is just right child, so sum is 7)
Tilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3, 5, and 2, which sums to 10; right subtree values are 9 and 7, which sums to 16)
Sum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <img alt="" src="./output_files/tilt3.jpg" style="width: 800px; height: 293px;"/>
  <pre><strong>Input:</strong> root = [21,7,14,1,1,2,2,3,3]
<strong>Output:</strong> 9
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [0, 10
     <sup>
      4
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     -1000 &lt;= Node.val &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 563 -->
<pre>/*
 * @lc app=leetcode id=563 lang=cpp
 *
 * [563] Binary Tree Tilt
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int ans=0;
    int find(TreeNode *root){
        if(root==NULL) return 0;
        int left=find(root-&gt;left);
        int right=find(root-&gt;right);
        ans=ans+abs(left-right);
        return root-&gt;val+left+right;
    }
    int findTilt(TreeNode* root) {
        if(root) find(root);
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 566. Reshape the Matrix
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   In MATLAB, there is a handy function called
   <code>
    reshape
   </code>
   which can reshape an
   <code>
    m x n
   </code>
   matrix into a new one with a different size
   <code>
    r x c
   </code>
   keeping its original data.
  </p>
  <p>
   You are given an
   <code>
    m x n
   </code>
   matrix
   <code>
    mat
   </code>
   and two integers
   <code>
    r
   </code>
   and
   <code>
    c
   </code>
   representing the number of rows and the number of columns of the wanted reshaped matrix.
  </p>
  <p>
   The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.
  </p>
  <p>
   If the
   <code>
    reshape
   </code>
   operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/reshape1-grid.jpg" style="width: 613px; height: 173px;"/>
  <pre><strong>Input:</strong> mat = [[1,2],[3,4]], r = 1, c = 4
<strong>Output:</strong> [[1,2,3,4]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/reshape2-grid.jpg" style="width: 453px; height: 173px;"/>
  <pre><strong>Input:</strong> mat = [[1,2],[3,4]], r = 2, c = 4
<strong>Output:</strong> [[1,2],[3,4]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == mat.length
    </code>
   </li>
   <li>
    <code>
     n == mat[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m, n &lt;= 100
    </code>
   </li>
   <li>
    <code>
     -1000 &lt;= mat[i][j] &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     1 &lt;= r, c &lt;= 300
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 566 -->
<pre>/*
 * @lc app=leetcode id=566 lang=cpp
 *
 * [566] Reshape the Matrix
 */

// @lc code=start
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int r, int c) {
        vector&lt;vector&lt;int&gt;&gt;a(r,vector&lt;int&gt;(c,0));
        int m=0,n=0;
        if (mat.size()*mat[0].size() != r * c) {
            return mat;
        }
        for(int i = 0; i &lt; mat.size(); i++){
            for(int j = 0; j &lt; mat[i].size(); j++){
                a[m][n]=mat[i][j];
                n++;
                if(n&gt;c-1){
                    m++;
                    n=0;
                }
            }
        }
        return a;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 572. Subtree of Another Tree
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the roots of two binary trees
   <code>
    root
   </code>
   and
   <code>
    subRoot
   </code>
   , return
   <code>
    true
   </code>
   if there is a subtree of
   <code>
    root
   </code>
   with the same structure and node values of
   <code>
    subRoot
   </code>
   and
   <code>
    false
   </code>
   otherwise.
  </p>
  <p>
   A subtree of a binary tree
   <code>
    tree
   </code>
   is a tree that consists of a node in
   <code>
    tree
   </code>
   and all of this node's descendants. The tree
   <code>
    tree
   </code>
   could also be considered as a subtree of itself.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/subtree1-tree.jpg" style="width: 532px; height: 400px;"/>
  <pre><strong>Input:</strong> root = [3,4,5,1,2], subRoot = [4,1,2]
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/subtree2-tree.jpg" style="width: 502px; height: 458px;"/>
  <pre><strong>Input:</strong> root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the
    <code>
     root
    </code>
    tree is in the range
    <code>
     [1, 2000]
    </code>
    .
   </li>
   <li>
    The number of nodes in the
    <code>
     subRoot
    </code>
    tree is in the range
    <code>
     [1, 1000]
    </code>
    .
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= root.val &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= subRoot.val &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 572 -->
<pre>/*
 * @lc app=leetcode id=572 lang=cpp
 *
 * [572] Subtree of Another Tree
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
bool isSameTree(TreeNode* root, TreeNode* subRoot)
{
    if(root==NULL &amp;&amp; subRoot==NULL) return 1;
    if(root==NULL || subRoot==NULL) return 0;
    if(root-&gt;val!=subRoot-&gt;val) return 0;
    return isSameTree(root-&gt;left,subRoot-&gt;left) &amp;&amp; isSameTree(root-&gt;right,subRoot-&gt;right);
}
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        if(root==NULL) return 0;
        if(isSameTree(root,subRoot)) return 1;
        return isSubtree(root-&gt;left,subRoot) || isSubtree(root-&gt;right,subRoot);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 583. Delete Operation for Two Strings
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two strings
   <code>
    word1
   </code>
   and
   <code>
    word2
   </code>
   , return
   <em>
    the minimum number of
    <strong>
     steps
    </strong>
    required to make
   </em>
   <code>
    word1
   </code>
   <em>
    and
   </em>
   <code>
    word2
   </code>
   <em>
    the same
   </em>
   .
  </p>
  <p>
   In one
   <strong>
    step
   </strong>
   , you can delete exactly one character in either string.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> word1 = "sea", word2 = "eat"
<strong>Output:</strong> 2
<strong>Explanation:</strong> You need one step to make "sea" to "ea" and another step to make "eat" to "ea".
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> word1 = "leetcode", word2 = "etco"
<strong>Output:</strong> 4
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= word1.length, word2.length &lt;= 500
    </code>
   </li>
   <li>
    <code>
     word1
    </code>
    and
    <code>
     word2
    </code>
    consist of only lowercase English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 583 -->
<pre>T/*
 * @lc app=leetcode id=583 lang=cpp
 *
 * [583] Delete Operation for Two Strings
 */

// @lc code=start
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m=word1.length();
        int n=word2.length();
        vector&lt;vector&lt;int&gt;&gt;dp(m+1,vector&lt;int&gt;(n+1,0));
        for(int i=1;i&lt;=m;i++) dp[i][0] =i;
        for(int i=1;i&lt;=n;i++) dp[0][i] =i;

        for(int i=1;i&lt;=m;i++){
            for(int j=1;j&lt;=n;j++){
                if(word1[i-1]==word2[j-1]) dp[i][j] = dp[i-1][j-1];
                else dp[i][j] = min(dp[i-1][j],dp[i][j-1])+1;
            }
        }
        return dp[m][n];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 617. Merge Two Binary Trees
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given two binary trees
   <code>
    root1
   </code>
   and
   <code>
    root2
   </code>
   .
  </p>
  <p>
   Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.
  </p>
  <p>
   Return
   <em>
    the merged tree
   </em>
   .
  </p>
  <p>
   <strong>
    Note:
   </strong>
   The merging process must start from the root nodes of both trees.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/merge.jpg" style="width: 600px; height: 163px;"/>
  <pre><strong>Input:</strong> root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
<strong>Output:</strong> [3,4,5,5,4,null,7]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root1 = [1], root2 = [1,2]
<strong>Output:</strong> [2,2]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in both trees is in the range
    <code>
     [0, 2000]
    </code>
    .
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= Node.val &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 617 -->
<pre>/*
 * @lc app=leetcode id=617 lang=cpp
 *
 * [617] Merge Two Binary Trees
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(root2==NULL &amp;&amp; root1==NULL) return NULL;
        if(root1==NULL) return root2;
        if(root2==NULL) return root1;
        root1-&gt;val=root1-&gt;val+root2-&gt;val;
        root1-&gt;left=mergeTrees(root1-&gt;left,root2-&gt;left);
        root1-&gt;right=mergeTrees(root1-&gt;right,root2-&gt;right);
        return root1;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 630. Course Schedule III
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   There are
   <code>
    n
   </code>
   different online courses numbered from
   <code>
    1
   </code>
   to
   <code>
    n
   </code>
   . You are given an array
   <code>
    courses
   </code>
   where
   <code>
    courses[i] = [duration
    <sub>
     i
    </sub>
    , lastDay
    <sub>
     i
    </sub>
    ]
   </code>
   indicate that the
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   course should be taken
   <b>
    continuously
   </b>
   for
   <code>
    duration
    <sub>
     i
    </sub>
   </code>
   days and must be finished before or on
   <code>
    lastDay
    <sub>
     i
    </sub>
   </code>
   .
  </p>
  <p>
   You will start on the
   <code>
    1
    <sup>
     st
    </sup>
   </code>
   day and you cannot take two or more courses simultaneously.
  </p>
  <p>
   Return
   <em>
    the maximum number of courses that you can take
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> courses = [[100,200],[200,1300],[1000,1250],[2000,3200]]
<strong>Output:</strong> 3
Explanation: 
There are totally 4 courses, but you can take 3 courses at most:
First, take the 1<sup>st</sup> course, it costs 100 days so you will finish it on the 100<sup>th</sup> day, and ready to take the next course on the 101<sup>st</sup> day.
Second, take the 3<sup>rd</sup> course, it costs 1000 days so you will finish it on the 1100<sup>th</sup> day, and ready to take the next course on the 1101<sup>st</sup> day. 
Third, take the 2<sup>nd</sup> course, it costs 200 days so you will finish it on the 1300<sup>th</sup> day. 
The 4<sup>th</sup> course cannot be taken now, since you will finish it on the 3300<sup>th</sup> day, which exceeds the closed date.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> courses = [[1,2]]
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> courses = [[3,2],[4,3]]
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= courses.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     1 &lt;= duration
     <sub>
      i
     </sub>
     , lastDay
     <sub>
      i
     </sub>
     &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 630 -->
<pre>/*
 * @lc app=leetcode id=630 lang=cpp
 *
 * [630] Course Schedule III
 */

// @lc code=start
class Solution {
public:
    int scheduleCourse(vector&lt;vector&lt;int&gt;&gt;&amp; courses) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 633. Sum of Square Numbers
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a non-negative integer
   <code>
    c
   </code>
   , decide whether there're two integers
   <code>
    a
   </code>
   and
   <code>
    b
   </code>
   such that
   <code>
    a
    <sup>
     2
    </sup>
    + b
    <sup>
     2
    </sup>
    = c
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> c = 5
<strong>Output:</strong> true
<strong>Explanation:</strong> 1 * 1 + 2 * 2 = 5
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> c = 3
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> c = 4
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> c = 2
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> c = 1
<strong>Output:</strong> true
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= c &lt;= 2
     <sup>
      31
     </sup>
     - 1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 633 -->
<pre>/*
 * @lc app=leetcode id=633 lang=cpp
 *
 * [633] Sum of Square Numbers
 */

// @lc code=start
class Solution {
public:
    bool judgeSquareSum(int c) {
        long long start=0,end=sqrt(c);
        if(c==INT_MAX) return false;
        while(start&lt;=end){
            if(start*start+end*end==c) return true;
            else if(start*start+end*end &gt; c) end=end-1;
            else start=start+1;
        }
        return false;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 646. Maximum Length of Pair Chain
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an array of
   <code>
    n
   </code>
   pairs
   <code>
    pairs
   </code>
   where
   <code>
    pairs[i] = [left
    <sub>
     i
    </sub>
    , right
    <sub>
     i
    </sub>
    ]
   </code>
   and
   <code>
    left
    <sub>
     i
    </sub>
    &lt; right
    <sub>
     i
    </sub>
   </code>
   .
  </p>
  <p>
   A pair
   <code>
    p2 = [c, d]
   </code>
   <strong>
    follows
   </strong>
   a pair
   <code>
    p1 = [a, b]
   </code>
   if
   <code>
    b &lt; c
   </code>
   . A
   <strong>
    chain
   </strong>
   of pairs can be formed in this fashion.
  </p>
  <p>
   Return
   <em>
    the length longest chain which can be formed
   </em>
   .
  </p>
  <p>
   You do not need to use up all the given intervals. You can select pairs in any order.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> pairs = [[1,2],[2,3],[3,4]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The longest chain is [1,2] -&gt; [3,4].
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> pairs = [[1,2],[7,8],[4,5]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The longest chain is [1,2] -&gt; [4,5] -&gt; [7,8].
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == pairs.length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     -1000 &lt;= left
     <sub>
      i
     </sub>
     &lt; right
     <sub>
      i
     </sub>
     &lt; 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 646 -->
<pre>/*
 * @lc app=leetcode id=646 lang=cpp
 *
 * [646] Maximum Length of Pair Chain
 */

// @lc code=start
class Solution {
public:
    int findLongestChain(vector&lt;vector&lt;int&gt;&gt;&amp; pairs) {
        sort(pairs.begin(), pairs.end());
        vector&lt;int&gt;lis(pairs.size()+1,1);
        int ans=1;
        for(int i=0; i&lt;pairs.size(); i++){
            for(int j=0; j&lt;i; j++){
                if(pairs[i][0]&gt;pairs[j][1])lis[i] = max(lis[i],1+lis[j]);
            }
            ans=max(ans,lis[i]);
        }

        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 647. Palindromic Substrings
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    s
   </code>
   , return
   <em>
    the number of
    <strong>
     palindromic substrings
    </strong>
    in it
   </em>
   .
  </p>
  <p>
   A string is a
   <strong>
    palindrome
   </strong>
   when it reads the same backward as forward.
  </p>
  <p>
   A
   <strong>
    substring
   </strong>
   is a contiguous sequence of characters within the string.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "abc"
<strong>Output:</strong> 3
<strong>Explanation:</strong> Three palindromic strings: "a", "b", "c".
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "aaa"
<strong>Output:</strong> 6
<strong>Explanation:</strong> Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consists of lowercase English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 647 -->
<pre>/*
 * @lc app=leetcode id=647 lang=cpp
 *
 * [647] Palindromic Substrings
 */

// @lc code=start
class Solution {
public:
    int countSubstrings(string s) {
        int n=s.length();
        if(n&lt;2) return n;
        int count = 0;
        vector&lt;vector&lt;int&gt;&gt;dp(n+1,vector&lt;int&gt;(n+1,0));

        for(int i=1;i&lt;=n;i++) {
            count++;
            dp[i][i]=1;
        }


        for(int i=0;i&lt;n;i++){
            if(s[i]==s[i+1]) {
                count++;
                dp[i][i+1]=1;
            }
        }

        for(int len=1; len&lt;n; len++){
            for(int i=0;i+len&lt;n;i++){
                int j=i+len;
                if(s[i]==s[j] &amp;&amp; dp[i+1][j-1]){
                    count++;
                    dp[i][j]=1;
                }
            }
        }
        return count;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 650. 2 Keys Keyboard
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   There is only one character
   <code>
    'A'
   </code>
   on the screen of a notepad. You can perform two operations on this notepad for each step:
  </p>
  <ul>
   <li>
    Copy All: You can copy all the characters present on the screen (a partial copy is not allowed).
   </li>
   <li>
    Paste: You can paste the characters which are copied last time.
   </li>
  </ul>
  <p>
   Given an integer
   <code>
    n
   </code>
   , return
   <em>
    the minimum number of operations to get the character
   </em>
   <code>
    'A'
   </code>
   <em>
    exactly
   </em>
   <code>
    n
   </code>
   <em>
    times on the screen
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> Intitally, we have one character 'A'.
In step 1, we use Copy All operation.
In step 2, we use Paste operation to get 'AA'.
In step 3, we use Paste operation to get 'AAA'.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 650 -->
<pre> /*
 * @lc app=leetcode id=650 lang=cpp
 *
 * [650] 2 Keys Keyboard
 */

// @lc code=start
class Solution {
public:
    int minSteps(int n) {
        if(n==1) return 0;
        vector&lt;int&gt;dp(n+2);
        iota(dp.begin(), dp.end(), 0);
        dp[0]=0;
        dp[1]=0;
        dp[2]=2;
        for(int i=2;i&lt;=n;i++){
            for(int j=2;j&lt;=i;j++){
                if(i%j==0)
                dp[i]=min(dp[i],dp[j]+ i/j);
            }
        }
        return dp[n];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 655. Print Binary Tree
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree, construct a
   <strong>
    0-indexed
   </strong>
   <code>
    m x n
   </code>
   string matrix
   <code>
    res
   </code>
   that represents a
   <strong>
    formatted layout
   </strong>
   of the tree. The formatted layout matrix should be constructed using the following rules:
  </p>
  <ul>
   <li>
    The
    <strong>
     height
    </strong>
    of the tree is
    <code>
     height
    </code>
    and the number of rows
    <code>
     m
    </code>
    should be equal to
    <code>
     height + 1
    </code>
    .
   </li>
   <li>
    The number of columns
    <code>
     n
    </code>
    should be equal to
    <code>
     2
     <sup>
      height+1
     </sup>
     - 1
    </code>
    .
   </li>
   <li>
    Place the
    <strong>
     root node
    </strong>
    in the
    <strong>
     middle
    </strong>
    of the
    <strong>
     top row
    </strong>
    (more formally, at location
    <code>
     res[0][(n-1)/2]
    </code>
    ).
   </li>
   <li>
    For each node that has been placed in the matrix at position
    <code>
     res[r][c]
    </code>
    , place its
    <strong>
     left child
    </strong>
    at
    <code>
     res[r+1][c-2
     <sup>
      height-r-1
     </sup>
     ]
    </code>
    and its
    <strong>
     right child
    </strong>
    at
    <code>
     res[r+1][c+2
     <sup>
      height-r-1
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    Continue this process until all the nodes in the tree have been placed.
   </li>
   <li>
    Any empty cells should contain the empty string
    <code>
     ""
    </code>
    .
   </li>
  </ul>
  <p>
   Return
   <em>
    the constructed matrix
   </em>
   <code>
    res
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/print1-tree.jpg" style="width: 141px; height: 181px;"/>
  <pre><strong>Input:</strong> root = [1,2]
<strong>Output:</strong> 
[["","1",""],
 ["2","",""]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/print2-tree.jpg" style="width: 207px; height: 302px;"/>
  <pre><strong>Input:</strong> root = [1,2,3,null,4]
<strong>Output:</strong> 
[["","","","1","","",""],
 ["","2","","","","3",""],
 ["","","4","","","",""]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [1, 2
     <sup>
      10
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     -99 &lt;= Node.val &lt;= 99
    </code>
   </li>
   <li>
    The depth of the tree will be in the range
    <code>
     [1, 10]
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 655 -->
<pre>/*
 * @lc app=leetcode id=655 lang=cpp
 *
 * [655] Print Binary Tree
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int height(TreeNode* root)
    {
        if(!root) return 0;
        return 1+max(height(root-&gt;left), height(root-&gt;right));
    }
    vector&lt;vector&lt;string&gt;&gt; printTree(TreeNode* root) {
        if(!root) return {{}};
        int m=height(root);
        int h=pow(2,m)-1;
        vector&lt;vector&lt;string&gt;&gt;ans(m,vector&lt;string&gt;(h,&quot;&quot;));
        queue&lt;pair&lt;TreeNode*,pair&lt;int,int&gt;&gt;&gt;q;
        q.push({root,{0,0}});
        while(!q.empty()) {
            pair&lt;TreeNode*,pair&lt;int,int&gt;&gt; node = q.front();
            q.pop();
            int s=node.second.first,e=node.second.second;
            cout&lt;&lt;s;
            ans[s][h/2 + e]=to_string(node.first-&gt;val);
            if(node.first-&gt;left)q.push({node.first-&gt;left,{s+1,e-pow(2,m-2-s)}});
            if(node.first-&gt;right)q.push({node.first-&gt;right,{s+1,e+pow(2,m-2-s)}});
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 673. Number of Longest Increasing Subsequence
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   , return
   <em>
    the number of longest increasing subsequences.
   </em>
  </p>
  <p>
   <strong>
    Notice
   </strong>
   that the sequence has to be
   <strong>
    strictly
   </strong>
   increasing.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,3,5,4,7]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,2,2,2,2]
<strong>Output:</strong> 5
<strong>Explanation:</strong> The length of longest continuous increasing subsequence is 1, and there are 5 subsequences' length is 1, so output 5.

</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 2000
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      6
     </sup>
     &lt;= nums[i] &lt;= 10
     <sup>
      6
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 673 -->
<pre>/*
 * @lc app=leetcode id=673 lang=cpp
 *
 * [673] Number of Longest Increasing Subsequence
 */

// @lc code=start
class Solution {
public:
    int findNumberOfLIS(vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt;lis(nums.size(),1);
        vector&lt;int&gt;count(nums.size(),1);

        int maxlen=1;
        for(int i=0; i&lt;nums.size(); i++){
            for(int j=0; j&lt;i; j++){
                if(nums[i]&gt;nums[j]){
                    if(lis[i]&lt;1+lis[j]){
                        lis[i] = 1+lis[j];
                        count[i] = count[j];
                    }
                    else if(lis[i]==1+lis[j]){
                        count[i] += count[j];
                    }
                }
                maxlen=max(maxlen,lis[i]);
            }
        }
        int ans=0;
        for(int i=0; i&lt;lis.size(); i++){
            if(maxlen==lis[i]){
                ans+=count[i];
            }
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 684. Redundant Connection
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   In this problem, a tree is an
   <strong>
    undirected graph
   </strong>
   that is connected and has no cycles.
  </p>
  <p>
   You are given a graph that started as a tree with
   <code>
    n
   </code>
   nodes labeled from
   <code>
    1
   </code>
   to
   <code>
    n
   </code>
   , with one additional edge added. The added edge has two
   <strong>
    different
   </strong>
   vertices chosen from
   <code>
    1
   </code>
   to
   <code>
    n
   </code>
   , and was not an edge that already existed. The graph is represented as an array
   <code>
    edges
   </code>
   of length
   <code>
    n
   </code>
   where
   <code>
    edges[i] = [a
    <sub>
     i
    </sub>
    , b
    <sub>
     i
    </sub>
    ]
   </code>
   indicates that there is an edge between nodes
   <code>
    a
    <sub>
     i
    </sub>
   </code>
   and
   <code>
    b
    <sub>
     i
    </sub>
   </code>
   in the graph.
  </p>
  <p>
   Return
   <em>
    an edge that can be removed so that the resulting graph is a tree of
   </em>
   <code>
    n
   </code>
   <em>
    nodes
   </em>
   . If there are multiple answers, return the answer that occurs last in the input.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/reduntant1-1-graph.jpg" style="width: 222px; height: 222px;"/>
  <pre><strong>Input:</strong> edges = [[1,2],[1,3],[2,3]]
<strong>Output:</strong> [2,3]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/reduntant1-2-graph.jpg" style="width: 382px; height: 222px;"/>
  <pre><strong>Input:</strong> edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]
<strong>Output:</strong> [1,4]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == edges.length
    </code>
   </li>
   <li>
    <code>
     3 &lt;= n &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     edges[i].length == 2
    </code>
   </li>
   <li>
    <code>
     1 &lt;= a
     <sub>
      i
     </sub>
     &lt; b
     <sub>
      i
     </sub>
     &lt;= edges.length
    </code>
   </li>
   <li>
    <code>
     a
     <sub>
      i
     </sub>
     != b
     <sub>
      i
     </sub>
    </code>
   </li>
   <li>
    There are no repeated edges.
   </li>
   <li>
    The given graph is connected.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 684 -->
<pre>/*
 * @lc app=leetcode id=684 lang=cpp
 *
 * [684] Redundant Connection
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt;parent;
    int find(int x){
        return parent[x]==x?x:find(parent[x]);
    }
    vector&lt;int&gt; findRedundantConnection(vector&lt;vector&lt;int&gt;&gt;&amp; edges) {
        int n=edges.size();
        parent.resize(n+1,0);
        iota(parent.begin(), parent.end(),0);
        vector&lt;int&gt;ans(2,0);
        for(auto a:edges){
            int x=find(a[0]);
            int y=find(a[1]);

            if(x!=y) parent[y]=x;
            else{
                ans=a;
            }
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 688. Knight Probability in Chessboard
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   On an
   <code>
    n x n
   </code>
   chessboard, a knight starts at the cell
   <code>
    (row, column)
   </code>
   and attempts to make exactly
   <code>
    k
   </code>
   moves. The rows and columns are
   <strong>
    0-indexed
   </strong>
   , so the top-left cell is
   <code>
    (0, 0)
   </code>
   , and the bottom-right cell is
   <code>
    (n - 1, n - 1)
   </code>
   .
  </p>
  <p>
   A chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.
  </p>
  <img src="./output_files/knight.png" style="width: 300px; height: 300px;"/>
  <p>
   Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.
  </p>
  <p>
   The knight continues moving until it has made exactly
   <code>
    k
   </code>
   moves or has moved off the chessboard.
  </p>
  <p>
   Return
   <em>
    the probability that the knight remains on the board after it has stopped moving
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 3, k = 2, row = 0, column = 0
<strong>Output:</strong> 0.06250
<strong>Explanation:</strong> There are two moves (to (1,2), (2,1)) that will keep the knight on the board.
From each of those positions, there are also two moves that will keep the knight on the board.
The total probability the knight stays on the board is 0.0625.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1, k = 0, row = 0, column = 0
<strong>Output:</strong> 1.00000
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 25
    </code>
   </li>
   <li>
    <code>
     0 &lt;= k &lt;= 100
    </code>
   </li>
   <li>
    <code>
     0 &lt;= row, column &lt;= n
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 688 -->
<pre>/*
 * @lc app=leetcode id=688 lang=cpp
 *
 * [688] Knight Probability in Chessboard
 */

// @lc code=start
class Solution {
public:
double dp[26][26][101];
    double knight(int n,int k,int row,int column){
        if(row&lt;0 || column&lt;0 || row&gt;=n || column&gt;=n) return  0;
        if(k==0) return 1;
        if(dp[row][column][k]) return dp[row][column][k];
        return dp[row][column][k]=
            (knight(n, k-1, row-2, column -1) + knight(n, k-1, row-1, column -2) +
            knight(n, k-1, row+2, column +1) + knight(n, k-1, row+1, column +2)+
            knight(n, k-1, row-2, column +1)+ knight(n, k-1, row+2, column -1) +
            knight(n, k-1, row-1, column +2) + knight(n, k-1, row+1, column -2))/8;
    }
    double knightProbability(int n, int k, int row, int column) {
        return knight(n, k, row, column);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 695. Max Area of Island
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an
   <code>
    m x n
   </code>
   binary matrix
   <code>
    grid
   </code>
   . An island is a group of
   <code>
    1
   </code>
   's (representing land) connected
   <strong>
    4-directionally
   </strong>
   (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.
  </p>
  <p>
   The
   <strong>
    area
   </strong>
   of an island is the number of cells with a value
   <code>
    1
   </code>
   in the island.
  </p>
  <p>
   Return
   <em>
    the maximum
    <strong>
     area
    </strong>
    of an island in
   </em>
   <code>
    grid
   </code>
   . If there is no island, return
   <code>
    0
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/maxarea1-grid.jpg" style="width: 500px; height: 310px;"/>
  <pre><strong>Input:</strong> grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
<strong>Output:</strong> 6
<strong>Explanation:</strong> The answer is not 11, because the island must be connected 4-directionally.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> grid = [[0,0,0,0,0,0,0,0]]
<strong>Output:</strong> 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == grid.length
    </code>
   </li>
   <li>
    <code>
     n == grid[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m, n &lt;= 50
    </code>
   </li>
   <li>
    <code>
     grid[i][j]
    </code>
    is either
    <code>
     0
    </code>
    or
    <code>
     1
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 695 -->
<pre>/*
 * @lc app=leetcode id=695 lang=cpp
 *
 * [695] Max Area of Island
 */

// @lc code=start
class Solution {
public:
    int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid,int x,int y){
        if(x&lt;0 || y&lt;0 || x&gt;=grid.size() || y&gt;=grid[x].size() || grid[x][y]!=1){
            return 0;
        }
        grid[x][y] = 0;
        return 1 + dfs(grid,x-1,y) + dfs(grid,x+1,y) + dfs(grid,x,y+1) + dfs(grid,x,y-1);
    }
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int maxx=0;
        for(int i = 0; i &lt; grid.size();i++){
            for(int j = 0; j &lt; grid[i].size();j++){
                if(grid[i][j]==1){
                    maxx=max(maxx,dfs(grid,i,j));
                }
            }
        }
        return maxx;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 697. Degree of an Array
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a non-empty array of non-negative integers
   <code>
    nums
   </code>
   , the
   <b>
    degree
   </b>
   of this array is defined as the maximum frequency of any one of its elements.
  </p>
  <p>
   Your task is to find the smallest possible length of a (contiguous) subarray of
   <code>
    nums
   </code>
   , that has the same degree as
   <code>
    nums
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,2,3,1]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
The input array has a degree of 2 because both elements 1 and 2 appear twice.
Of the subarrays that have the same degree:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
The shortest length is 2. So return 2.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,2,3,1,4,2]
<strong>Output:</strong> 6
<strong>Explanation:</strong> 
The degree is 3 because the element 2 is repeated 3 times.
So [2,2,3,1,4,2] is the shortest subarray, therefore returning 6.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     nums.length
    </code>
    will be between 1 and 50,000.
   </li>
   <li>
    <code>
     nums[i]
    </code>
    will be an integer between 0 and 49,999.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 697 -->
<pre>/*
 * @lc app=leetcode id=697 lang=cpp
 *
 * [697] Degree of an Array
 */

// @lc code=start
class Solution {
public:
    int findShortestSubArray(vector&lt;int&gt;&amp; nums) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 698. Partition to K Equal Sum Subsets
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   and an integer
   <code>
    k
   </code>
   , return
   <code>
    true
   </code>
   if it is possible to divide this array into
   <code>
    k
   </code>
   non-empty subsets whose sums are all equal.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [4,3,2,3,5,2,1], k = 4
<strong>Output:</strong> true
<strong>Explanation:</strong> It's possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3,4], k = 3
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= k &lt;= nums.length &lt;= 16
    </code>
   </li>
   <li>
    <code>
     1 &lt;= nums[i] &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    The frequency of each element is in the range
    <code>
     [1, 4]
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 698 -->
<pre>/*
 * @lc app=leetcode id=698 lang=cpp
 *
 * [698] Partition to K Equal Sum Subsets
 */

// @lc code=start
class Solution {
public:
    bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k) {
        int n=nums.size();
        vector&lt;int&gt;dp(1&lt;&lt;n,-1);
        dp[0]=0;
        int sum=0;
        for(int i=0; i&lt;n; i++) sum+=nums[i];
        if(sum%k) return false;
        int target=sum/k;
        for(int mask=0; mask&lt; (1&lt;&lt;n); mask++){
            if(dp[mask]==-1) continue;
            for(int i=0; i&lt;n; i++){
                if(!(mask&amp;(1&lt;&lt;i)) &amp;&amp; (nums[i]+dp[mask]&lt;=target)){
                    dp[mask|(1&lt;&lt;i)]=(nums[i]+dp[mask])%target;
                }
            }
        }
        //for(int x:dp) cout&lt;&lt;x&lt;&lt;&#x27; &#x27;;
        return dp[(1&lt;&lt;n)-1]==0;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 709. To Lower Case
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    s
   </code>
   , return
   <em>
    the string after replacing every uppercase letter with the same lowercase letter
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "Hello"
<strong>Output:</strong> "hello"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "here"
<strong>Output:</strong> "here"
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "LOVELY"
<strong>Output:</strong> "lovely"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consists of printable ASCII characters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 709 -->
<pre>/*
 * @lc app=leetcode id=709 lang=cpp
 *
 * [709] To Lower Case
 */

// @lc code=start
class Solution {
public:
    string toLowerCase(string s) {
        if(s==&quot;&quot;) return &quot;&quot;;
        string ans=(char)(tolower(s[0]))+toLowerCase(s.substr(1));
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 712. Minimum ASCII Delete Sum for Two Strings
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two strings
   <code>
    s1
   </code>
   and
   <code>
    s2
   </code>
   , return
   <em>
    the lowest
    <strong>
     ASCII
    </strong>
    sum of deleted characters to make two strings equal
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s1 = "sea", s2 = "eat"
<strong>Output:</strong> 231
<strong>Explanation:</strong> Deleting "s" from "sea" adds the ASCII value of "s" (115) to the sum.
Deleting "t" from "eat" adds 116 to the sum.
At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s1 = "delete", s2 = "leet"
<strong>Output:</strong> 403
<strong>Explanation:</strong> Deleting "dee" from "delete" to turn the string into "let",
adds 100[d] + 101[e] + 101[e] to the sum.
Deleting "e" from "leet" adds 101[e] to the sum.
At the end, both strings are equal to "let", and the answer is 100+101+101+101 = 403.
If instead we turned both strings into "lee" or "eet", we would get answers of 433 or 417, which are higher.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s1.length, s2.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     s1
    </code>
    and
    <code>
     s2
    </code>
    consist of lowercase English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 712 -->
<pre>/*
 * @lc app=leetcode id=712 lang=cpp
 *
 * [712] Minimum ASCII Delete Sum for Two Strings
 */

// @lc code=start
class Solution {
public:
    int minimumDeleteSum(string s1, string s2) {
        int m=s1.length();
        int n=s2.length();
        vector&lt;vector&lt;int&gt;&gt;dp(m+1,vector&lt;int&gt;(n+1,0));
        for(int i=1;i&lt;=m;i++) dp[i][0] =dp[i-1][0]+s1[i-1];
        for(int i=1;i&lt;=n;i++) dp[0][i] =dp[0][i-1]+s2[i-1];

        for(int i=1;i&lt;=m;i++){
            for(int j=1;j&lt;=n;j++){
                if(s1[i-1]==s2[j-1]) dp[i][j] = dp[i-1][j-1];
                else dp[i][j] = min((int)s1[i-1]+ dp[i-1][j],(int)s2[j-1] + dp[i][j-1]);
            }
        }
        return dp[m][n];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 714. Best Time to Buy and Sell Stock with Transaction Fee
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an array
   <code>
    prices
   </code>
   where
   <code>
    prices[i]
   </code>
   is the price of a given stock on the
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   day, and an integer
   <code>
    fee
   </code>
   representing a transaction fee.
  </p>
  <p>
   Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.
  </p>
  <p>
   <strong>
    Note:
   </strong>
   You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> prices = [1,3,2,8,4,9], fee = 2
<strong>Output:</strong> 8
<strong>Explanation:</strong> The maximum profit can be achieved by:
- Buying at prices[0] = 1
- Selling at prices[3] = 8
- Buying at prices[4] = 4
- Selling at prices[5] = 9
The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> prices = [1,3,7,5,10,3], fee = 3
<strong>Output:</strong> 6
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= prices.length &lt;= 5 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     1 &lt;= prices[i] &lt; 5 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= fee &lt; 5 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 714 -->
<pre>/*
 * @lc app=leetcode id=714 lang=cpp
 *
 * [714] Best Time to Buy and Sell Stock with Transaction Fee
 */

// @lc code=start
class Solution {
public:

    int find(int i,int state,vector&lt;int&gt;&amp;prices,vector&lt;vector&lt;int&gt;&gt;&amp;dp,int fees)
    {
        if(i&gt;=prices.size()) return 0;
        if(dp[i][state]!=-1) return dp[i][state];
        if(state) return dp[i][state]=max(-prices[i]+find(i+1,0,prices,dp,fees),find(i+1,1,prices,dp,fees));
        return dp[i][state]=max(prices[i]+find(i+1,1,prices,dp,fees)-fees,find(i+1,0,prices,dp,fees));
    }

    int maxProfit(vector&lt;int&gt;&amp; prices, int fee) {
        vector&lt;vector&lt;int&gt;&gt;dp(prices.size(),vector&lt;int&gt;(2,-1));
        return find(0,1,prices,dp,fee);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 721. Accounts Merge
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a list of
   <code>
    accounts
   </code>
   where each element
   <code>
    accounts[i]
   </code>
   is a list of strings, where the first element
   <code>
    accounts[i][0]
   </code>
   is a name, and the rest of the elements are
   <strong>
    emails
   </strong>
   representing emails of the account.
  </p>
  <p>
   Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.
  </p>
  <p>
   After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails
   <strong>
    in sorted order
   </strong>
   . The accounts themselves can be returned in
   <strong>
    any order
   </strong>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> accounts = [["John","johnsmith@mail.com","john_newyork@mail.com"],["John","johnsmith@mail.com","john00@mail.com"],["Mary","mary@mail.com"],["John","johnnybravo@mail.com"]]
<strong>Output:</strong> [["John","john00@mail.com","john_newyork@mail.com","johnsmith@mail.com"],["Mary","mary@mail.com"],["John","johnnybravo@mail.com"]]
<strong>Explanation:</strong>
The first and third John's are the same person as they have the common email "johnsmith@mail.com".
The second John and Mary are different people as none of their email addresses are used by other accounts.
We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], 
['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> accounts = [["Gabe","Gabe0@m.co","Gabe3@m.co","Gabe1@m.co"],["Kevin","Kevin3@m.co","Kevin5@m.co","Kevin0@m.co"],["Ethan","Ethan5@m.co","Ethan4@m.co","Ethan0@m.co"],["Hanzo","Hanzo3@m.co","Hanzo1@m.co","Hanzo0@m.co"],["Fern","Fern5@m.co","Fern1@m.co","Fern0@m.co"]]
<strong>Output:</strong> [["Ethan","Ethan0@m.co","Ethan4@m.co","Ethan5@m.co"],["Gabe","Gabe0@m.co","Gabe1@m.co","Gabe3@m.co"],["Hanzo","Hanzo0@m.co","Hanzo1@m.co","Hanzo3@m.co"],["Kevin","Kevin0@m.co","Kevin3@m.co","Kevin5@m.co"],["Fern","Fern0@m.co","Fern1@m.co","Fern5@m.co"]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= accounts.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     2 &lt;= accounts[i].length &lt;= 10
    </code>
   </li>
   <li>
    <code>
     1 &lt;= accounts[i][j] &lt;= 30
    </code>
   </li>
   <li>
    <code>
     accounts[i][0]
    </code>
    consists of English letters.
   </li>
   <li>
    <code>
     accounts[i][j] (for j &gt; 0)
    </code>
    is a valid email.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 721 -->
<pre>/*
 * @lc app=leetcode id=721 lang=cpp
 *
 * [721] Accounts Merge
 */

// @lc code=start
class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; accountsMerge(vector&lt;vector&lt;string&gt;&gt;&amp; accounts) {
        map&lt;string,vector&lt;string&gt;&gt;m;
        map&lt;string,string&gt;s;
        for(auto x:accounts){
            if(m.find(x[0])==m.end()){
                for(int i=1;i&lt;=x.size();i++){
                    m[x[0]].push_back(x[i]);
                    s[x[i]]=x[0];
                }
            }
            else{
                for(int i=1;i&lt;=x.size();i++){
                    if(s[x[i]]==x[0]){
                        for(int i=1;i&lt;=x.size();i++){
                            m[x[0]].push_back(x[i]);
                            s[x[i]]=x[0];
                        }
                        continue;
                    }
                    else{
                        string n=x[0]+&#x27;*&#x27;;
                        while(m[n]!=&quot;&quot;){
                            n=n+&#x27;*&#x27;;
                        }
                        for(int i=1;i&lt;=x.size();i++){
                            m[x[0]].push_back(x[i]);
                            s[x[i]]=x[0];
                        }
                    }
                }
            }
        }
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 724. Find Pivot Index
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of integers
   <code>
    nums
   </code>
   , calculate the
   <strong>
    pivot index
   </strong>
   of this array.
  </p>
  <p>
   The
   <strong>
    pivot index
   </strong>
   is the index where the sum of all the numbers
   <strong>
    strictly
   </strong>
   to the left of the index is equal to the sum of all the numbers
   <strong>
    strictly
   </strong>
   to the index's right.
  </p>
  <p>
   If the index is on the left edge of the array, then the left sum is
   <code>
    0
   </code>
   because there are no elements to the left. This also applies to the right edge of the array.
  </p>
  <p>
   Return
   <em>
    the
    <strong>
     leftmost pivot index
    </strong>
   </em>
   . If no such index exists, return -1.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,7,3,6,5,6]
<strong>Output:</strong> 3
<strong>Explanation:</strong>
The pivot index is 3.
Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11
Right sum = nums[4] + nums[5] = 5 + 6 = 11
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3]
<strong>Output:</strong> -1
<strong>Explanation:</strong>
There is no index that satisfies the conditions in the problem statement.</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,1,-1]
<strong>Output:</strong> 0
<strong>Explanation:</strong>
The pivot index is 0.
Left sum = 0 (no elements to the left of index 0)
Right sum = nums[1] + nums[2] = 1 + -1 = 0
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -1000 &lt;= nums[i] &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 724 -->
<pre>/*
 * @lc app=leetcode id=724 lang=cpp
 *
 * [724] Find Pivot Index
 */

// @lc code=start
class Solution {
public:
    int pivotIndex(vector&lt;int&gt;&amp; nums) {
        int sum=0;
        for(int i=0; i&lt;nums.size();i++){
            sum=sum+nums[i];
        }
        int target=0;
        for(int i=0; i&lt;nums.size();i++){
            if(target==sum-target-nums[i]) return i;
            else target=target+nums[i];
        }
        return -1;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 730. Count Different Palindromic Subsequences
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string s, return
   <em>
    the number of different non-empty palindromic subsequences in
   </em>
   <code>
    s
   </code>
   . Since the answer may be very large, return it
   <strong>
    modulo
   </strong>
   <code>
    10
    <sup>
     9
    </sup>
    + 7
   </code>
   .
  </p>
  <p>
   A subsequence of a string is obtained by deleting zero or more characters from the string.
  </p>
  <p>
   A sequence is palindromic if it is equal to the sequence reversed.
  </p>
  <p>
   Two sequences
   <code>
    a
    <sub>
     1
    </sub>
    , a
    <sub>
     2
    </sub>
    , ...
   </code>
   and
   <code>
    b
    <sub>
     1
    </sub>
    , b
    <sub>
     2
    </sub>
    , ...
   </code>
   are different if there is some
   <code>
    i
   </code>
   for which
   <code>
    a
    <sub>
     i
    </sub>
    != b
    <sub>
     i
    </sub>
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "bccb"
<strong>Output:</strong> 6
<strong>Explanation:</strong> The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'.
Note that 'bcb' is counted only once, even though it occurs twice.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba"
<strong>Output:</strong> 104860361
<strong>Explanation:</strong> There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 10<sup>9</sup> + 7.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     s[i]
    </code>
    is either
    <code>
     'a'
    </code>
    ,
    <code>
     'b'
    </code>
    ,
    <code>
     'c'
    </code>
    , or
    <code>
     'd'
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 730 -->
<pre>/*
 * @lc app=leetcode id=730 lang=cpp
 *
 * [730] Count Different Palindromic Subsequences
 */

// @lc code=start
class Solution {
public:
    int countPalindromicSubsequences(string s) {
        int n=s.length();
        if(n&lt;2) return n;
        int count = 0;
        vector&lt;vector&lt;int&gt;&gt;dp(n+1,vector&lt;int&gt;(n+1,0));
        set&lt;string&gt;ans;

        for(int i=1;i&lt;=n;i++) {
            count++;
            dp[i][i]=1;
            }


        for(int i=0;i&lt;n;i++){
            if(s[i]==s[i+1]) {
                count++;
                dp[i][i+1]=1;
            }
        }

        for(int len=1; len&lt;n; len++){
            for(int i=0;i+len&lt;n;i++){
                int j=i+len;
                if(s[i]==s[j] &amp;&amp; dp[i+1][j-1]){
                    count++;
                    cout&lt;&lt;s.substr(i,j-i+1);
                    dp[i][j]=1;
                }
            }
        }
        return count;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 733. Flood Fill
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   An image is represented by an
   <code>
    m x n
   </code>
   integer grid
   <code>
    image
   </code>
   where
   <code>
    image[i][j]
   </code>
   represents the pixel value of the image.
  </p>
  <p>
   You are also given three integers
   <code>
    sr
   </code>
   ,
   <code>
    sc
   </code>
   , and
   <code>
    newColor
   </code>
   . You should perform a
   <strong>
    flood fill
   </strong>
   on the image starting from the pixel
   <code>
    image[sr][sc]
   </code>
   .
  </p>
  <p>
   To perform a
   <strong>
    flood fill
   </strong>
   , consider the starting pixel, plus any pixels connected
   <strong>
    4-directionally
   </strong>
   to the starting pixel of the same color as the starting pixel, plus any pixels connected
   <strong>
    4-directionally
   </strong>
   to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with
   <code>
    newColor
   </code>
   .
  </p>
  <p>
   Return
   <em>
    the modified image after performing the flood fill
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/flood1-grid.jpg" style="width: 613px; height: 253px;"/>
  <pre><strong>Input:</strong> image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2
<strong>Output:</strong> [[2,2,2],[2,2,0],[2,0,1]]
<strong>Explanation:</strong> From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.
Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 2
<strong>Output:</strong> [[2,2,2],[2,2,2]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == image.length
    </code>
   </li>
   <li>
    <code>
     n == image[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m, n &lt;= 50
    </code>
   </li>
   <li>
    <code>
     0 &lt;= image[i][j], newColor &lt; 2
     <sup>
      16
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= sr &lt; m
    </code>
   </li>
   <li>
    <code>
     0 &lt;= sc &lt; n
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 733 -->
<pre>/*
 * @lc app=leetcode id=733 lang=cpp
 *
 * [733] Flood Fill
 */

// @lc code=start
class Solution {
public:
    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; image,int x,int y,int color,int chose){
        if(x&lt;0 || y&lt;0 || x&gt;=image.size()|| y&gt;=image[x].size()){
            return;
        }
        if(image[x][y]== !chose){
            return;
        }
        if(image[x][y]==chose){
        image[x][y] = color;
        dfs(image,x-1,y,color,chose);
        dfs(image,x+1,y,color,chose);
        dfs(image,x,y-1,color,chose);
        dfs(image,x,y+1,color,chose);
        }
    }
    vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int color) {
        if(image[sr][sc]!=color)
        dfs(image,sr,sc,color,image[sr][sc]);
        return image;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 740. Delete and Earn
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an integer array
   <code>
    nums
   </code>
   . You want to maximize the number of points you get by performing the following operation any number of times:
  </p>
  <ul>
   <li>
    Pick any
    <code>
     nums[i]
    </code>
    and delete it to earn
    <code>
     nums[i]
    </code>
    points. Afterwards, you must delete
    <b>
     every
    </b>
    element equal to
    <code>
     nums[i] - 1
    </code>
    and
    <strong>
     every
    </strong>
    element equal to
    <code>
     nums[i] + 1
    </code>
    .
   </li>
  </ul>
  <p>
   Return
   <em>
    the
    <strong>
     maximum number of points
    </strong>
    you can earn by applying the above operation some number of times
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,4,2]
<strong>Output:</strong> 6
<strong>Explanation:</strong> You can perform the following operations:
- Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2].
- Delete 2 to earn 2 points. nums = [].
You earn a total of 6 points.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,2,3,3,3,4]
<strong>Output:</strong> 9
<strong>Explanation:</strong> You can perform the following operations:
- Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = [3,3].
- Delete a 3 again to earn 3 points. nums = [3].
- Delete a 3 once more to earn 3 points. nums = [].
You earn a total of 9 points.</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 2 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     1 &lt;= nums[i] &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 740 -->
<pre>po/*
 * @lc app=leetcode id=740 lang=cpp
 *
 * [740] Delete and Earn
 */

// @lc code=start
class Solution {
public:
    int deleteAndEarn(vector&lt;int&gt;&amp; nums) {
        map&lt;int,int&gt;m;
        for(int x:nums){
            m[x]+=x;
        }
        int take=0,skip=0;
        for(int i=0; i&lt;10001; i++){
            int take1=skip+m[i];
            int skip1 = max(take,skip);
            take=take1;
            skip=skip1;
        }
        return max(take,skip);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 743. Network Delay Time
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given a network of
   <code>
    n
   </code>
   nodes, labeled from
   <code>
    1
   </code>
   to
   <code>
    n
   </code>
   . You are also given
   <code>
    times
   </code>
   , a list of travel times as directed edges
   <code>
    times[i] = (u
    <sub>
     i
    </sub>
    , v
    <sub>
     i
    </sub>
    , w
    <sub>
     i
    </sub>
    )
   </code>
   , where
   <code>
    u
    <sub>
     i
    </sub>
   </code>
   is the source node,
   <code>
    v
    <sub>
     i
    </sub>
   </code>
   is the target node, and
   <code>
    w
    <sub>
     i
    </sub>
   </code>
   is the time it takes for a signal to travel from source to target.
  </p>
  <p>
   We will send a signal from a given node
   <code>
    k
   </code>
   . Return the time it takes for all the
   <code>
    n
   </code>
   nodes to receive the signal. If it is impossible for all the
   <code>
    n
   </code>
   nodes to receive the signal, return
   <code>
    -1
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/931_example_1.png" style="width: 217px; height: 239px;"/>
  <pre><strong>Input:</strong> times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
<strong>Output:</strong> 2
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> times = [[1,2,1]], n = 2, k = 1
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> times = [[1,2,1]], n = 2, k = 2
<strong>Output:</strong> -1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= k &lt;= n &lt;= 100
    </code>
   </li>
   <li>
    <code>
     1 &lt;= times.length &lt;= 6000
    </code>
   </li>
   <li>
    <code>
     times[i].length == 3
    </code>
   </li>
   <li>
    <code>
     1 &lt;= u
     <sub>
      i
     </sub>
     , v
     <sub>
      i
     </sub>
     &lt;= n
    </code>
   </li>
   <li>
    <code>
     u
     <sub>
      i
     </sub>
     != v
     <sub>
      i
     </sub>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= w
     <sub>
      i
     </sub>
     &lt;= 100
    </code>
   </li>
   <li>
    All the pairs
    <code>
     (u
     <sub>
      i
     </sub>
     , v
     <sub>
      i
     </sub>
     )
    </code>
    are
    <strong>
     unique
    </strong>
    . (i.e., no multiple edges.)
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 743 -->
<pre>/*
 * @lc app=leetcode id=743 lang=cpp
 *
 * [743] Network Delay Time
 */

// @lc code=start
class Solution {
public:
    int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int n, int k) {
        vector&lt;int&gt;dist(n+1,100000);
        dist[k]=0;
        for(int i=1; i&lt;=n; i++){
            vector&lt;int&gt; new_dist=dist;
            for(auto x:times){
                new_dist[x[1]]=min(dist[x[0]]+x[2],new_dist[x[1]]);
            }
            dist=new_dist;
        }
        int maxx=0;
        for(int i=1; i&lt;=n; i++){
            maxx=max(maxx,dist[i]);
        }
        return maxx==100000?-1:maxx;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 744. Find Smallest Letter Greater Than Target
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a characters array
   <code>
    letters
   </code>
   that is sorted in
   <strong>
    non-decreasing
   </strong>
   order and a character
   <code>
    target
   </code>
   , return
   <em>
    the smallest character in the array that is larger than
   </em>
   <code>
    target
   </code>
   .
  </p>
  <p>
   <strong>
    Note
   </strong>
   that the letters wrap around.
  </p>
  <ul>
   <li>
    For example, if
    <code>
     target == 'z'
    </code>
    and
    <code>
     letters == ['a', 'b']
    </code>
    , the answer is
    <code>
     'a'
    </code>
    .
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> letters = ["c","f","j"], target = "a"
<strong>Output:</strong> "c"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> letters = ["c","f","j"], target = "c"
<strong>Output:</strong> "f"
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> letters = ["c","f","j"], target = "d"
<strong>Output:</strong> "f"
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> letters = ["c","f","j"], target = "g"
<strong>Output:</strong> "j"
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> letters = ["c","f","j"], target = "j"
<strong>Output:</strong> "c"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     2 &lt;= letters.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     letters[i]
    </code>
    is a lowercase English letter.
   </li>
   <li>
    <code>
     letters
    </code>
    is sorted in
    <strong>
     non-decreasing
    </strong>
    order.
   </li>
   <li>
    <code>
     letters
    </code>
    contains at least two different characters.
   </li>
   <li>
    <code>
     target
    </code>
    is a lowercase English letter.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 744 -->
<pre>/*
 * @lc app=leetcode id=744 lang=cpp
 *
 * [744] Find Smallest Letter Greater Than Target
 */

// @lc code=start
class Solution {
public:
    char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) {
        for(char x:letters){
            if(x-&#x27;0&#x27;&gt;target-&#x27;0&#x27;){
                return x;
            }
        }
        return letters[0];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 746. Min Cost Climbing Stairs
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an integer array
   <code>
    cost
   </code>
   where
   <code>
    cost[i]
   </code>
   is the cost of
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   step on a staircase. Once you pay the cost, you can either climb one or two steps.
  </p>
  <p>
   You can either start from the step with index
   <code>
    0
   </code>
   , or the step with index
   <code>
    1
   </code>
   .
  </p>
  <p>
   Return
   <em>
    the minimum cost to reach the top of the floor
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> cost = [10,15,20]
<strong>Output:</strong> 15
<strong>Explanation:</strong> Cheapest is: start on cost[1], pay that cost, and go to the top.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> cost = [1,100,1,1,1,100,1,1,100,1]
<strong>Output:</strong> 6
<strong>Explanation:</strong> Cheapest is: start on cost[0], and only step on 1s, skipping cost[3].
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     2 &lt;= cost.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     0 &lt;= cost[i] &lt;= 999
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 746 -->
<pre>/*
 * @lc app=leetcode id=746 lang=cpp
 *
 * [746] Min Cost Climbing Stairs
 */

// @lc code=start
class Solution {
public:
    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) {
        int n=cost.size();
        vector&lt;int&gt;dp(n+1,0);
        dp[0]=cost[0];
        dp[1]=cost[1];
        for(int i=2; i&lt;=n; i++){
            if(i==n){
                dp[i]=min(dp[i-1],dp[i-2]);
            }
            else{
                dp[i]=min(dp[i-1],dp[i-2])+cost[i];
            }
        }
        return dp[n];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 785. Is Graph Bipartite?
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   There is an
   <strong>
    undirected
   </strong>
   graph with
   <code>
    n
   </code>
   nodes, where each node is numbered between
   <code>
    0
   </code>
   and
   <code>
    n - 1
   </code>
   . You are given a 2D array
   <code>
    graph
   </code>
   , where
   <code>
    graph[u]
   </code>
   is an array of nodes that node
   <code>
    u
   </code>
   is adjacent to. More formally, for each
   <code>
    v
   </code>
   in
   <code>
    graph[u]
   </code>
   , there is an undirected edge between node
   <code>
    u
   </code>
   and node
   <code>
    v
   </code>
   . The graph has the following properties:
  </p>
  <ul>
   <li>
    There are no self-edges (
    <code>
     graph[u]
    </code>
    does not contain
    <code>
     u
    </code>
    ).
   </li>
   <li>
    There are no parallel edges (
    <code>
     graph[u]
    </code>
    does not contain duplicate values).
   </li>
   <li>
    If
    <code>
     v
    </code>
    is in
    <code>
     graph[u]
    </code>
    , then
    <code>
     u
    </code>
    is in
    <code>
     graph[v]
    </code>
    (the graph is undirected).
   </li>
   <li>
    The graph may not be connected, meaning there may be two nodes
    <code>
     u
    </code>
    and
    <code>
     v
    </code>
    such that there is no path between them.
   </li>
  </ul>
  <p>
   A graph is
   <strong>
    bipartite
   </strong>
   if the nodes can be partitioned into two independent sets
   <code>
    A
   </code>
   and
   <code>
    B
   </code>
   such that
   <strong>
    every
   </strong>
   edge in the graph connects a node in set
   <code>
    A
   </code>
   and a node in set
   <code>
    B
   </code>
   .
  </p>
  <p>
   Return
   <code>
    true
   </code>
   <em>
    if and only if it is
    <strong>
     bipartite
    </strong>
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/bi2.jpg" style="width: 222px; height: 222px;"/>
  <pre><strong>Input:</strong> graph = [[1,2,3],[0,2],[0,1,3],[0,2]]
<strong>Output:</strong> false
<strong>Explanation:</strong> There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/bi1.jpg" style="width: 222px; height: 222px;"/>
  <pre><strong>Input:</strong> graph = [[1,3],[0,2],[1,3],[0,2]]
<strong>Output:</strong> true
<strong>Explanation:</strong> We can partition the nodes into two sets: {0, 2} and {1, 3}.</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     graph.length == n
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 100
    </code>
   </li>
   <li>
    <code>
     0 &lt;= graph[u].length &lt; n
    </code>
   </li>
   <li>
    <code>
     0 &lt;= graph[u][i] &lt;= n - 1
    </code>
   </li>
   <li>
    <code>
     graph[u]
    </code>
    does not contain
    <code>
     u
    </code>
    .
   </li>
   <li>
    All the values of
    <code>
     graph[u]
    </code>
    are
    <strong>
     unique
    </strong>
    .
   </li>
   <li>
    If
    <code>
     graph[u]
    </code>
    contains
    <code>
     v
    </code>
    , then
    <code>
     graph[v]
    </code>
    contains
    <code>
     u
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 785 -->
<pre>/*
 * @lc app=leetcode id=785 lang=cpp
 *
 * [785] Is Graph Bipartite?
 */

// @lc code=start
class Solution {
public:
    bool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) {
        int n=graph.size();
        vector&lt;int&gt;color(n,-1);

        queue&lt;int&gt;q;

        for(int i=0; i&lt;n; i++){

            if(color[i]!=-1) continue;
            q.push(i);

            while(!q.empty()){
                int t=q.front();
                q.pop();
                for(int j=0; j&lt;graph[t].size(); j++){
                    if(color[graph[t][j]]==-1){
                        color[graph[t][j]]=1-color[t];
                        q.push(graph[t][j]);
                    }
                    else if(color[graph[t][j]]==color[t]) return false;
                }
            }
        }
        return true;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 787. Cheapest Flights Within K Stops
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   There are
   <code>
    n
   </code>
   cities connected by some number of flights. You are given an array
   <code>
    flights
   </code>
   where
   <code>
    flights[i] = [from
    <sub>
     i
    </sub>
    , to
    <sub>
     i
    </sub>
    , price
    <sub>
     i
    </sub>
    ]
   </code>
   indicates that there is a flight from city
   <code>
    from
    <sub>
     i
    </sub>
   </code>
   to city
   <code>
    to
    <sub>
     i
    </sub>
   </code>
   with cost
   <code>
    price
    <sub>
     i
    </sub>
   </code>
   .
  </p>
  <p>
   You are also given three integers
   <code>
    src
   </code>
   ,
   <code>
    dst
   </code>
   , and
   <code>
    k
   </code>
   , return
   <em>
    <strong>
     the cheapest price
    </strong>
    from
   </em>
   <code>
    src
   </code>
   <em>
    to
   </em>
   <code>
    dst
   </code>
   <em>
    with at most
   </em>
   <code>
    k
   </code>
   <em>
    stops.
   </em>
   If there is no such route, return
   <em>
   </em>
   <code>
    -1
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/995.png" style="height: 360px; width: 492px;"/>
  <pre><strong>Input:</strong> n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1
<strong>Output:</strong> 200
<strong>Explanation:</strong> The graph is shown.
The cheapest price from city <code>0</code> to city <code>2</code> with at most 1 stop costs 200, as marked red in the picture.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/995.png" style="height: 360px; width: 492px;"/>
  <pre><strong>Input:</strong> n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0
<strong>Output:</strong> 500
<strong>Explanation:</strong> The graph is shown.
The cheapest price from city <code>0</code> to city <code>2</code> with at most 0 stop costs 500, as marked blue in the picture.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 100
    </code>
   </li>
   <li>
    <code>
     0 &lt;= flights.length &lt;= (n * (n - 1) / 2)
    </code>
   </li>
   <li>
    <code>
     flights[i].length == 3
    </code>
   </li>
   <li>
    <code>
     0 &lt;= from
     <sub>
      i
     </sub>
     , to
     <sub>
      i
     </sub>
     &lt; n
    </code>
   </li>
   <li>
    <code>
     from
     <sub>
      i
     </sub>
     != to
     <sub>
      i
     </sub>
    </code>
   </li>
   <li>
    <code>
     1 &lt;= price
     <sub>
      i
     </sub>
     &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    There will not be any multiple flights between two cities.
   </li>
   <li>
    <code>
     0 &lt;= src, dst, k &lt; n
    </code>
   </li>
   <li>
    <code>
     src != dst
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 787 -->
<pre>/*
 * @lc app=leetcode id=787 lang=cpp
 *
 * [787] Cheapest Flights Within K Stops
 */

// @lc code=start
class Solution {
public:
    int findCheapestPrice(int n, vector&lt;vector&lt;int&gt;&gt;&amp; flights, int src, int dst, int k) {
        vector&lt;int&gt;dist(n,100000);
        dist[src]=0;
        for(int i=0; i&lt;=k; i++){
            vector&lt;int&gt; new_dist=dist;
            for(auto x:flights){
                new_dist[x[1]]=min(dist[x[0]]+x[2],new_dist[x[1]]);
            }
            dist=new_dist;
        }

        return dist[dst]==100000?-1:dist[dst];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 788. Rotated Digits
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   An integer
   <code>
    x
   </code>
   is a
   <strong>
    good
   </strong>
   if after rotating each digit individually by 180 degrees, we get a valid number that is different from
   <code>
    x
   </code>
   . Each digit must be rotated - we cannot choose to leave it alone.
  </p>
  <p>
   A number is valid if each digit remains a digit after rotation. For example:
  </p>
  <ul>
   <li>
    <code>
     0
    </code>
    ,
    <code>
     1
    </code>
    , and
    <code>
     8
    </code>
    rotate to themselves,
   </li>
   <li>
    <code>
     2
    </code>
    and
    <code>
     5
    </code>
    rotate to each other (in this case they are rotated in a different direction, in other words,
    <code>
     2
    </code>
    or
    <code>
     5
    </code>
    gets mirrored),
   </li>
   <li>
    <code>
     6
    </code>
    and
    <code>
     9
    </code>
    rotate to each other, and
   </li>
   <li>
    the rest of the numbers do not rotate to any other number and become invalid.
   </li>
  </ul>
  <p>
   Given an integer
   <code>
    n
   </code>
   , return
   <em>
    the number of
    <strong>
     good
    </strong>
    integers in the range
   </em>
   <code>
    [1, n]
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 10
<strong>Output:</strong> 4
<strong>Explanation:</strong> There are four good numbers in the range [1, 10] : 2, 5, 6, 9.
Note that 1 and 10 are not good numbers, since they remain unchanged after rotating.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1
<strong>Output:</strong> 0
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 2
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 788 -->
<pre>/*
 * @lc app=leetcode id=788 lang=cpp
 *
 * [788] Rotated Digits
 */

// @lc code=start
class Solution {
public:
    int rotatedDigits(int n) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 790. Domino and Tromino Tiling
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You have two types of tiles: a
   <code>
    2 x 1
   </code>
   domino shape and a tromino shape. You may rotate these shapes.
  </p>
  <img alt="" src="./output_files/lc-domino.jpg" style="width: 362px; height: 195px;"/>
  <p>
   Given an integer n, return
   <em>
    the number of ways to tile an
   </em>
   <code>
    2 x n
   </code>
   <em>
    board
   </em>
   . Since the answer may be very large, return it
   <strong>
    modulo
   </strong>
   <code>
    10
    <sup>
     9
    </sup>
    + 7
   </code>
   .
  </p>
  <p>
   In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/lc-domino1.jpg" style="width: 500px; height: 226px;"/>
  <pre><strong>Input:</strong> n = 3
<strong>Output:</strong> 5
<strong>Explanation:</strong> The five different ways are show above.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 790 -->
<pre>/*
 * @lc app=leetcode id=790 lang=cpp
 *
 * [790] Domino and Tromino Tiling
 */

// @lc code=start
class Solution {
public:
    int numTilings(int n) {
        int a=0,b=1,c=1,mod = 1e9+7;
        n--;
        while(n--){
            int d=((c*2)%mod + a%mod)%mod;
            a=b;
            b=c;
            c=d;
        }
        return c;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 796. Rotate String
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two strings
   <code>
    s
   </code>
   and
   <code>
    goal
   </code>
   , return
   <code>
    true
   </code>
   <em>
    if and only if
   </em>
   <code>
    s
   </code>
   <em>
    can become
   </em>
   <code>
    goal
   </code>
   <em>
    after some number of
    <strong>
     shifts
    </strong>
    on
   </em>
   <code>
    s
   </code>
   .
  </p>
  <p>
   A
   <strong>
    shift
   </strong>
   on
   <code>
    s
   </code>
   consists of moving the leftmost character of
   <code>
    s
   </code>
   to the rightmost position.
  </p>
  <ul>
   <li>
    For example, if
    <code>
     s = "abcde"
    </code>
    , then it will be
    <code>
     "bcdea"
    </code>
    after one shift.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "abcde", goal = "cdeab"
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "abcde", goal = "abced"
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length, goal.length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    and
    <code>
     goal
    </code>
    consist of lowercase English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 796 -->
<pre>/*
 * @lc app=leetcode id=796 lang=cpp
 *
 * [796] Rotate String
 */

// @lc code=start
class Solution {
public:
    bool rotateString(string s, string goal) {
        if(s==goal) return true;
        for(int i=1; i&lt;s.length(); i++)
        {
            reverse(s.begin(), s.end());
            reverse(s.begin()+1, s.end());
            if(s==goal) return true;
        }
        return false;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 801. Minimum Swaps To Make Sequences Increasing
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given two integer arrays of the same length
   <code>
    nums1
   </code>
   and
   <code>
    nums2
   </code>
   . In one operation, you are allowed to swap
   <code>
    nums1[i]
   </code>
   with
   <code>
    nums2[i]
   </code>
   .
  </p>
  <ul>
   <li>
    For example, if
    <code>
     nums1 = [1,2,3,
     <u>
      8
     </u>
     ]
    </code>
    , and
    <code>
     nums2 = [5,6,7,
     <u>
      4
     </u>
     ]
    </code>
    , you can swap the element at
    <code>
     i = 3
    </code>
    to obtain
    <code>
     nums1 = [1,2,3,4]
    </code>
    and
    <code>
     nums2 = [5,6,7,8]
    </code>
    .
   </li>
  </ul>
  <p>
   Return
   <em>
    the minimum number of needed operations to make
   </em>
   <code>
    nums1
   </code>
   <em>
    and
   </em>
   <code>
    nums2
   </code>
   <em>
    <strong>
     strictly increasing
    </strong>
   </em>
   . The test cases are generated so that the given input always makes it possible.
  </p>
  <p>
   An array
   <code>
    arr
   </code>
   is
   <strong>
    strictly increasing
   </strong>
   if and only if
   <code>
    arr[0] &lt; arr[1] &lt; arr[2] &lt; ... &lt; arr[arr.length - 1]
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums1 = [1,3,5,4], nums2 = [1,2,3,7]
<strong>Output:</strong> 1
<strong>Explanation:</strong> 
Swap nums1[3] and nums2[3]. Then the sequences are:
nums1 = [1, 3, 5, 7] and nums2 = [1, 2, 3, 4]
which are both strictly increasing.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums1 = [0,3,5,8,9], nums2 = [2,1,4,6,9]
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     2 &lt;= nums1.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     nums2.length == nums1.length
    </code>
   </li>
   <li>
    <code>
     0 &lt;= nums1[i], nums2[i] &lt;= 2 * 10
     <sup>
      5
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 801 -->
<pre>/*
 * @lc app=leetcode id=801 lang=cpp
 *
 * [801] Minimum Swaps To Make Sequences Increasing
 */

// @lc code=start
class Solution {
public:
    int minSwap(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 802. Find Eventual Safe States
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   We start at some node in a directed graph, and every turn, we walk along a directed edge of the graph. If we reach a terminal node (that is, it has no outgoing directed edges), we stop.
  </p>
  <p>
   We define a starting node to be
   <strong>
    safe
   </strong>
   if we must eventually walk to a terminal node. More specifically, there is a natural number
   <code>
    k
   </code>
   , so that we must have stopped at a terminal node in less than
   <code>
    k
   </code>
   steps for
   <strong>
    any choice of where to walk
   </strong>
   .
  </p>
  <p>
   Return
   <em>
    an array containing all the safe nodes of the graph
   </em>
   . The answer should be sorted in
   <strong>
    ascending
   </strong>
   order.
  </p>
  <p>
   The directed graph has
   <code>
    n
   </code>
   nodes with labels from
   <code>
    0
   </code>
   to
   <code>
    n - 1
   </code>
   , where
   <code>
    n
   </code>
   is the length of
   <code>
    graph
   </code>
   . The graph is given in the following form:
   <code>
    graph[i]
   </code>
   is a list of labels
   <code>
    j
   </code>
   such that
   <code>
    (i, j)
   </code>
   is a directed edge of the graph, going from node
   <code>
    i
   </code>
   to node
   <code>
    j
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="Illustration of graph" src="./output_files/picture1.png" style="height: 171px; width: 600px;"/>
  <pre><strong>Input:</strong> graph = [[1,2],[2,3],[5],[0],[5],[],[]]
<strong>Output:</strong> [2,4,5,6]
<strong>Explanation:</strong> The given graph is shown above.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]
<strong>Output:</strong> [4]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == graph.length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= graph[i].length &lt;= n
    </code>
   </li>
   <li>
    <code>
     graph[i]
    </code>
    is sorted in a strictly increasing order.
   </li>
   <li>
    The graph may contain self-loops.
   </li>
   <li>
    The number of edges in the graph will be in the range
    <code>
     [1, 4 * 10
     <sup>
      4
     </sup>
     ]
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 802 -->
<pre>/*
 * @lc app=leetcode id=802 lang=cpp
 *
 * [802] Find Eventual Safe States
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; eventualSafeNodes(vector&lt;vector&lt;int&gt;&gt;&amp; graph) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 808. Soup Servings
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   There are two types of soup:
   <strong>
    type A
   </strong>
   and
   <strong>
    type B
   </strong>
   . Initially, we have
   <code>
    n
   </code>
   ml of each type of soup. There are four kinds of operations:
  </p>
  <ol>
   <li>
    Serve
    <code>
     100
    </code>
    ml of
    <strong>
     soup A
    </strong>
    and
    <code>
     0
    </code>
    ml of
    <strong>
     soup B
    </strong>
    ,
   </li>
   <li>
    Serve
    <code>
     75
    </code>
    ml of
    <strong>
     soup A
    </strong>
    and
    <code>
     25
    </code>
    ml of
    <strong>
     soup B
    </strong>
    ,
   </li>
   <li>
    Serve
    <code>
     50
    </code>
    ml of
    <strong>
     soup A
    </strong>
    and
    <code>
     50
    </code>
    ml of
    <strong>
     soup B
    </strong>
    , and
   </li>
   <li>
    Serve
    <code>
     25
    </code>
    ml of
    <strong>
     soup A
    </strong>
    and
    <code>
     75
    </code>
    ml of
    <strong>
     soup B
    </strong>
    .
   </li>
  </ol>
  <p>
   When we serve some soup, we give it to someone, and we no longer have it. Each turn, we will choose from the four operations with an equal probability
   <code>
    0.25
   </code>
   . If the remaining volume of soup is not enough to complete the operation, we will serve as much as possible. We stop once we no longer have some quantity of both types of soup.
  </p>
  <p>
   <strong>
    Note
   </strong>
   that we do not have an operation where all
   <code>
    100
   </code>
   ml's of
   <strong>
    soup B
   </strong>
   are used first.
  </p>
  <p>
   Return
   <em>
    the probability that
    <strong>
     soup A
    </strong>
    will be empty first, plus half the probability that
    <strong>
     A
    </strong>
    and
    <strong>
     B
    </strong>
    become empty at the same time
   </em>
   . Answers within
   <code>
    10
    <sup>
     -5
    </sup>
   </code>
   of the actual answer will be accepted.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 50
<strong>Output:</strong> 0.62500
<strong>Explanation:</strong> If we choose the first two operations, A will become empty first.
For the third operation, A and B will become empty at the same time.
For the fourth operation, B will become empty first.
So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 100
<strong>Output:</strong> 0.71875
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= n &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 808 -->
<pre>/*
 * @lc app=leetcode id=808 lang=cpp
 *
 * [808] Soup Servings
 */

// @lc code=start
class Solution {
public:
    double soupServings(int n) {
        if(n&gt;4800) return 1;
        vector&lt;vector&lt;double&gt;&gt;dp(n+1,vector&lt;double&gt;(n+1,0));
        dp[0][0]=0.5;
        for(int i=1;i&lt;=n;i++){
            dp[0][i]=1;
        }
        for(int i=1;i&lt;=n;i++){
            for(int j=1;j&lt;=n;j++){
                dp[i][j]=
                (dp[max(0,i-100)][j]+
                dp[max(0,i-75)][max(0,j-25)]+
                dp[max(0,i-50)][max(0,j-50)]+
                dp[max(0,i-25)][max(0,j-75)])/4;
            }
        }
        return dp[n][n];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 832. Flipping an Image
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an
   <code>
    n x n
   </code>
   binary matrix
   <code>
    image
   </code>
   , flip the image
   <strong>
    horizontally
   </strong>
   , then invert it, and return
   <em>
    the resulting image
   </em>
   .
  </p>
  <p>
   To flip an image horizontally means that each row of the image is reversed.
  </p>
  <ul>
   <li>
    For example, flipping
    <code>
     [1,1,0]
    </code>
    horizontally results in
    <code>
     [0,1,1]
    </code>
    .
   </li>
  </ul>
  <p>
   To invert an image means that each
   <code>
    0
   </code>
   is replaced by
   <code>
    1
   </code>
   , and each
   <code>
    1
   </code>
   is replaced by
   <code>
    0
   </code>
   .
  </p>
  <ul>
   <li>
    For example, inverting
    <code>
     [0,1,1]
    </code>
    results in
    <code>
     [1,0,0]
    </code>
    .
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> image = [[1,1,0],[1,0,1],[0,0,0]]
<strong>Output:</strong> [[1,0,0],[0,1,0],[1,1,1]]
<strong>Explanation:</strong> First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].
Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
<strong>Output:</strong> [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
<strong>Explanation:</strong> First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].
Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == image.length
    </code>
   </li>
   <li>
    <code>
     n == image[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 20
    </code>
   </li>
   <li>
    <code>
     images[i][j]
    </code>
    is either
    <code>
     0
    </code>
    or
    <code>
     1
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 832 -->
<pre>/*
 * @lc app=leetcode id=832 lang=cpp
 *
 * [832] Flipping an Image
 */

// @lc code=start
class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt;&amp; image) {
        for(int i = 0; i &lt; image.size();i++){
            int start=0,end=image[i].size()-1;
            while(start &lt;= end){
                swap(image[i][start],image[i][end]);
                if(start &lt; end){
                image[i][start]=!image[i][start];
                image[i][end]=!image[i][end];}
                else{
                    image[i][start]=!image[i][start];
                }
                start++; end--;
            }
        }
        return image;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 841. Keys and Rooms
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   There are
   <code>
    n
   </code>
   rooms labeled from
   <code>
    0
   </code>
   to
   <code>
    n - 1
   </code>
   and all the rooms are locked except for room
   <code>
    0
   </code>
   . Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.
  </p>
  <p>
   When you visit a room, you may find a set of
   <strong>
    distinct keys
   </strong>
   in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.
  </p>
  <p>
   Given an array
   <code>
    rooms
   </code>
   where
   <code>
    rooms[i]
   </code>
   is the set of keys that you can obtain if you visited room
   <code>
    i
   </code>
   , return
   <code>
    true
   </code>
   <em>
    if you can visit
    <strong>
     all
    </strong>
    the rooms, or
   </em>
   <code>
    false
   </code>
   <em>
    otherwise
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> rooms = [[1],[2],[3],[]]
<strong>Output:</strong> true
<strong>Explanation:</strong> 
We visit room 0 and pick up key 1.
We then visit room 1 and pick up key 2.
We then visit room 2 and pick up key 3.
We then visit room 3.
Since we were able to visit every room, we return true.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> rooms = [[1,3],[3,0,1],[2],[0]]
<strong>Output:</strong> false
<strong>Explanation:</strong> We can not enter room number 2 since the only key that unlocks it is in that room.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == rooms.length
    </code>
   </li>
   <li>
    <code>
     2 &lt;= n &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     0 &lt;= rooms[i].length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     1 &lt;= sum(rooms[i].length) &lt;= 3000
    </code>
   </li>
   <li>
    <code>
     0 &lt;= rooms[i][j] &lt; n
    </code>
   </li>
   <li>
    All the values of
    <code>
     rooms[i]
    </code>
    are
    <strong>
     unique
    </strong>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 841 -->
<pre>/*
 * @lc app=leetcode id=841 lang=cpp
 *
 * [841] Keys and Rooms
 */

// @lc code=start
class Solution {
public:
    bool canVisitAllRooms(vector&lt;vector&lt;int&gt;&gt;&amp; rooms) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 871. Minimum Number of Refueling Stops
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   A car travels from a starting position to a destination which is
   <code>
    target
   </code>
   miles east of the starting position.
  </p>
  <p>
   There are gas stations along the way. The gas stations are represented as an array
   <code>
    stations
   </code>
   where
   <code>
    stations[i] = [position
    <sub>
     i
    </sub>
    , fuel
    <sub>
     i
    </sub>
    ]
   </code>
   indicates that the
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   gas station is
   <code>
    position
    <sub>
     i
    </sub>
   </code>
   miles east of the starting position and has
   <code>
    fuel
    <sub>
     i
    </sub>
   </code>
   liters of gas.
  </p>
  <p>
   The car starts with an infinite tank of gas, which initially has
   <code>
    startFuel
   </code>
   liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.
  </p>
  <p>
   Return
   <em>
    the minimum number of refueling stops the car must make in order to reach its destination
   </em>
   . If it cannot reach the destination, return
   <code>
    -1
   </code>
   .
  </p>
  <p>
   Note that if the car reaches a gas station with
   <code>
    0
   </code>
   fuel left, the car can still refuel there. If the car reaches the destination with
   <code>
    0
   </code>
   fuel left, it is still considered to have arrived.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> target = 1, startFuel = 1, stations = []
<strong>Output:</strong> 0
<strong>Explanation:</strong> We can reach the target without refueling.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> target = 100, startFuel = 1, stations = [[10,100]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> We can not reach the target (or even the first gas station).
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> We start with 10 liters of fuel.
We drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.
Then, we drive from position 10 to position 60 (expending 50 liters of fuel),
and refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.
We made 2 refueling stops along the way, so we return 2.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= target, startFuel &lt;= 10
     <sup>
      9
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= stations.length &lt;= 500
    </code>
   </li>
   <li>
    <code>
     0 &lt;= position
     <sub>
      i
     </sub>
     &lt;= position
     <sub>
      i+1
     </sub>
     &lt; target
    </code>
   </li>
   <li>
    <code>
     1 &lt;= fuel
     <sub>
      i
     </sub>
     &lt; 10
     <sup>
      9
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 871 -->
<pre>/*
 * @lc app=leetcode id=871 lang=cpp
 *
 * [871] Minimum Number of Refueling Stops
 */

// @lc code=start
class Solution {
public:
    int minRefuelStops(int target, int startFuel, vector&lt;vector&lt;int&gt;&gt;&amp; stations) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 872. Leaf-Similar Trees
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a
   <strong>
    leaf value sequence
   </strong>
   <em>
    .
   </em>
  </p>
  <p>
   <img alt="" src="./output_files/tree.png" style="width: 400px; height: 336px;"/>
  </p>
  <p>
   For example, in the given tree above, the leaf value sequence is
   <code>
    (6, 7, 4, 9, 8)
   </code>
   .
  </p>
  <p>
   Two binary trees are considered
   <em>
    leaf-similar
   </em>
   if their leaf value sequence is the same.
  </p>
  <p>
   Return
   <code>
    true
   </code>
   if and only if the two given trees with head nodes
   <code>
    root1
   </code>
   and
   <code>
    root2
   </code>
   are leaf-similar.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/leaf-similar-1.jpg" style="width: 750px; height: 297px;"/>
  <pre><strong>Input:</strong> root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root1 = [1], root2 = [1]
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root1 = [1], root2 = [2]
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> root1 = [1,2], root2 = [2,2]
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <img alt="" src="./output_files/leaf-similar-2.jpg" style="width: 450px; height: 165px;"/>
  <pre><strong>Input:</strong> root1 = [1,2,3], root2 = [1,3,2]
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in each tree will be in the range
    <code>
     [1, 200]
    </code>
    .
   </li>
   <li>
    Both of the given trees will have values in the range
    <code>
     [0, 200]
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 872 -->
<pre>/*
 * @lc app=leetcode id=872 lang=cpp
 *
 * [872] Leaf-Similar Trees
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void inorder(TreeNode *root,vector&lt;int&gt;&amp;a){
        if(root){
            inorder(root-&gt;left,a);
            if(root-&gt;right==NULL &amp;&amp; root-&gt;left==NULL)
            a.push_back(root-&gt;val);
            inorder(root-&gt;right,a);
        }
    }
    bool leafSimilar(TreeNode* root1, TreeNode* root2) {
        vector&lt;int&gt;a;
        inorder(root1,a);
        vector&lt;int&gt;b;
        inorder(root2,b);
        for(int x:a)
        {
            cout&lt;&lt;x;
        }
        cout&lt;&lt;&#x27;\n&#x27;;
        for(int x:b)
        {
            cout&lt;&lt;x;
        }
        if(a.size()!=b.size())return false;
        for(int i=0;i&lt;a.size();i++){
            if(a[i]!=b[i]) return false;
        }
        return true;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 881. Boats to Save People
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an array
   <code>
    people
   </code>
   where
   <code>
    people[i]
   </code>
   is the weight of the
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   person, and an
   <strong>
    infinite number of boats
   </strong>
   where each boat can carry a maximum weight of
   <code>
    limit
   </code>
   . Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most
   <code>
    limit
   </code>
   .
  </p>
  <p>
   Return
   <em>
    the minimum number of boats to carry every given person
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> people = [1,2], limit = 3
<strong>Output:</strong> 1
<strong>Explanation:</strong> 1 boat (1, 2)
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> people = [3,2,2,1], limit = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> 3 boats (1, 2), (2) and (3)
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> people = [3,5,3,4], limit = 5
<strong>Output:</strong> 4
<strong>Explanation:</strong> 4 boats (3), (3), (4), (5)
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= people.length &lt;= 5 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     1 &lt;= people[i] &lt;= limit &lt;= 3 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 881 -->
<pre>/*
 * @lc app=leetcode id=881 lang=cpp
 *
 * [881] Boats to Save People
 */

// @lc code=start
class Solution {
public:
    int numRescueBoats(vector&lt;int&gt;&amp; people, int limit) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 886. Possible Bipartition
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   We want to split a group of
   <code>
    n
   </code>
   people (labeled from
   <code>
    1
   </code>
   to
   <code>
    n
   </code>
   ) into two groups of
   <strong>
    any size
   </strong>
   . Each person may dislike some other people, and they should not go into the same group.
  </p>
  <p>
   Given the integer
   <code>
    n
   </code>
   and the array
   <code>
    dislikes
   </code>
   where
   <code>
    dislikes[i] = [a
    <sub>
     i
    </sub>
    , b
    <sub>
     i
    </sub>
    ]
   </code>
   indicates that the person labeled
   <code>
    a
    <sub>
     i
    </sub>
   </code>
   does not like the person labeled
   <code>
    b
    <sub>
     i
    </sub>
   </code>
   , return
   <code>
    true
   </code>
   <em>
    if it is possible to split everyone into two groups in this way
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 4, dislikes = [[1,2],[1,3],[2,4]]
<strong>Output:</strong> true
<strong>Explanation:</strong> group1 [1,4] and group2 [2,3].
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 3, dislikes = [[1,2],[1,3],[2,3]]
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 2000
    </code>
   </li>
   <li>
    <code>
     0 &lt;= dislikes.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     dislikes[i].length == 2
    </code>
   </li>
   <li>
    <code>
     1 &lt;= dislikes[i][j] &lt;= n
    </code>
   </li>
   <li>
    <code>
     a
     <sub>
      i
     </sub>
     &lt; b
     <sub>
      i
     </sub>
    </code>
   </li>
   <li>
    All the pairs of
    <code>
     dislikes
    </code>
    are
    <strong>
     unique
    </strong>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 886 -->
<pre>/*
 * @lc app=leetcode id=886 lang=cpp
 *
 * [886] Possible Bipartition
 */

// @lc code=start
class Solution {
public:
    bool possibleBipartition(int n, vector&lt;vector&lt;int&gt;&gt;&amp; dislikes) {

        map&lt;int,vector&lt;int&gt;&gt;m;
        for(auto x:dislikes) {
            m[x[0]-1].push_back(x[1]-1);
            m[x[1]-1].push_back(x[0]-1);
        }

        for(int x:m[0]){
            cout&lt;&lt;x;
        }
        vector&lt;int&gt;color(n,-1);

        queue&lt;int&gt;q;

        for(int i=0; i&lt;n; i++){

            if(color[i]!=-1) continue;
            q.push(i);

            while(!q.empty()){
                int t=q.front();
                q.pop();
                for(int j=0; j&lt;m[t].size(); j++){
                    if(color[m[t][j]]==-1){
                        color[m[t][j]]=1-color[t];
                        q.push(m[t][j]);
                    }
                    else if(color[m[t][j]]==color[t]) return false;
                }
            }
        }
        return true;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 897. Increasing Order Search Tree
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary search tree, rearrange the tree in
   <strong>
    in-order
   </strong>
   so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/ex1(3).jpg" style="width: 600px; height: 350px;"/>
  <pre><strong>Input:</strong> root = [5,3,6,2,4,null,8,1,null,null,null,7,9]
<strong>Output:</strong> [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/ex2(2).jpg" style="width: 300px; height: 114px;"/>
  <pre><strong>Input:</strong> root = [5,1,7]
<strong>Output:</strong> [1,null,5,null,7]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the given tree will be in the range
    <code>
     [1, 100]
    </code>
    .
   </li>
   <li>
    <code>
     0 &lt;= Node.val &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 897 -->
<pre>/*
 * @lc app=leetcode id=897 lang=cpp
 *
 * [897] Increasing Order Search Tree
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void inorder(TreeNode *root,vector&lt;TreeNode *&gt;&amp;a){
        if(root){
            inorder(root-&gt;left,a);
            a.push_back(root);
            inorder(root-&gt;right,a);
        }
    }
    TreeNode* increasingBST(TreeNode* root) {
        if(!root)return nullptr;
        vector&lt;TreeNode *&gt;a;
        inorder(root,a);
        TreeNode* head=new TreeNode(0);
        TreeNode* temp=head;
        for(int i=0;i&lt;a.size();i++)
        {
            temp-&gt;right=new TreeNode(a[i]-&gt;val);
            temp=temp-&gt;right;
        }
        return head-&gt;right;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 905. Sort Array By Parity
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   , move all the even integers at the beginning of the array followed by all the odd integers.
  </p>
  <p>
   Return
   <em>
    <strong>
     any array
    </strong>
    that satisfies this condition
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,1,2,4]
<strong>Output:</strong> [2,4,3,1]
<strong>Explanation:</strong> The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [0]
<strong>Output:</strong> [0]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 5000
    </code>
   </li>
   <li>
    <code>
     0 &lt;= nums[i] &lt;= 5000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 905 -->
<pre>/*
 * @lc app=leetcode id=905 lang=cpp
 *
 * [905] Sort Array By Parity
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; sortArrayByParity(vector&lt;int&gt;&amp; nums) {
        int j=0;
        for(int i=0; i&lt;nums.size();i++){
            if(nums[i]%2==0){
                swap(nums[i],nums[j]);
                j++;
            }
        }
        return nums;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 922. Sort Array By Parity II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of integers
   <code>
    nums
   </code>
   , half of the integers in
   <code>
    nums
   </code>
   are
   <strong>
    odd
   </strong>
   , and the other half are
   <strong>
    even
   </strong>
   .
  </p>
  <p>
   Sort the array so that whenever
   <code>
    nums[i]
   </code>
   is odd,
   <code>
    i
   </code>
   is
   <strong>
    odd
   </strong>
   , and whenever
   <code>
    nums[i]
   </code>
   is even,
   <code>
    i
   </code>
   is
   <strong>
    even
   </strong>
   .
  </p>
  <p>
   Return
   <em>
    any answer array that satisfies this condition
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [4,2,5,7]
<strong>Output:</strong> [4,5,2,7]
<strong>Explanation:</strong> [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,3]
<strong>Output:</strong> [2,3]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     2 &lt;= nums.length &lt;= 2 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     nums.length
    </code>
    is even.
   </li>
   <li>
    Half of the integers in
    <code>
     nums
    </code>
    are even.
   </li>
   <li>
    <code>
     0 &lt;= nums[i] &lt;= 1000
    </code>
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Follow Up:
   </strong>
   Could you solve it in-place?
  </p>
 </div>
</div>
</body></html>
<!-- Solution for Question 922 -->
<pre>/*
 * @lc app=leetcode id=922 lang=cpp
 *
 * [922] Sort Array By Parity II
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; sortArrayByParityII(vector&lt;int&gt;&amp; nums) {
        int i=0,j=1;
        while(i&lt;nums.size() &amp;&amp; j&lt;nums.size()) {
            if(nums[i]%2==0) i=i+2;
            else if(nums[j]%2==1) j=j+2;
            else swap(nums[i],nums[j]);
        }
        return nums;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 923. 3Sum With Multiplicity
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    arr
   </code>
   , and an integer
   <code>
    target
   </code>
   , return the number of tuples
   <code>
    i, j, k
   </code>
   such that
   <code>
    i &lt; j &lt; k
   </code>
   and
   <code>
    arr[i] + arr[j] + arr[k] == target
   </code>
   .
  </p>
  <p>
   As the answer can be very large, return it
   <strong>
    modulo
   </strong>
   <code>
    10
    <sup>
     9
    </sup>
    + 7
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> arr = [1,1,2,2,3,3,4,4,5,5], target = 8
<strong>Output:</strong> 20
<strong>Explanation: </strong>
Enumerating by the values (arr[i], arr[j], arr[k]):
(1, 2, 5) occurs 8 times;
(1, 3, 4) occurs 8 times;
(2, 2, 4) occurs 2 times;
(2, 3, 3) occurs 2 times.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> arr = [1,1,2,2,2,2], target = 5
<strong>Output:</strong> 12
<strong>Explanation: </strong>
arr[i] = 1, arr[j] = arr[k] = 2 occurs 12 times:
We choose one 1 from [1,1] in 2 ways,
and two 2s from [2,2,2,2] in 6 ways.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     3 &lt;= arr.length &lt;= 3000
    </code>
   </li>
   <li>
    <code>
     0 &lt;= arr[i] &lt;= 100
    </code>
   </li>
   <li>
    <code>
     0 &lt;= target &lt;= 300
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 923 -->
<pre>/*
 * @lc app=leetcode id=923 lang=cpp
 *
 * [923] 3Sum With Multiplicity
 */

// @lc code=start
class Solution {
public:
    int threeSumMulti(vector&lt;int&gt;&amp; a, int target) {
        map&lt;int,int&gt;m;
        int n=a.size(),mod=1e9+7,ans=0;
        for(int i=0;i&lt;n;i++){
            ans=(ans+m[target-a[i]])%mod;
            for(int j=0;j&lt;i;j++){
                m[a[i]+a[j]]++;
            }
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 925. Long Pressed Name
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Your friend is typing his
   <code>
    name
   </code>
   into a keyboard. Sometimes, when typing a character
   <code>
    c
   </code>
   , the key might get
   <em>
    long pressed
   </em>
   , and the character will be typed 1 or more times.
  </p>
  <p>
   You examine the
   <code>
    typed
   </code>
   characters of the keyboard. Return
   <code>
    True
   </code>
   if it is possible that it was your friends name, with some characters (possibly none) being long pressed.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> name = "alex", typed = "aaleex"
<strong>Output:</strong> true
<strong>Explanation: </strong>'a' and 'e' in 'alex' were long pressed.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> name = "saeed", typed = "ssaaedd"
<strong>Output:</strong> false
<strong>Explanation: </strong>'e' must have been pressed twice, but it wasn't in the typed output.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> name = "leelee", typed = "lleeelee"
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> name = "laiden", typed = "laiden"
<strong>Output:</strong> true
<strong>Explanation: </strong>It's not necessary to long press any character.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= name.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     1 &lt;= typed.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     name
    </code>
    and
    <code>
     typed
    </code>
    contain only lowercase English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 925 -->
<pre>/*
 * @lc app=leetcode id=925 lang=cpp
 *
 * [925] Long Pressed Name
 */

// @lc code=start
class Solution {
public:
    bool isLongPressedName(string name, string typed) {
        int i=0,j=0;
        if(name.length()&gt;typed.length()) return false;
        while(i&lt;name.length() &amp;&amp; j&lt;typed.length()) {
            if(name[i]==typed[j]){
                if(name[i]==name[i+1]){
                    i++;
                    j++;
                    continue;
                }
                while(name[i]==typed[j]){
                    j++;
                }
                i++;
            }
            else{
                return false;
            }
        }
        if(i==name.length() &amp;&amp; j==typed.length()) return true;
        return false;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 931. Minimum Falling Path Sum
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an
   <code>
    n x n
   </code>
   array of integers
   <code>
    matrix
   </code>
   , return
   <em>
    the
    <strong>
     minimum sum
    </strong>
    of any
    <strong>
     falling path
    </strong>
    through
   </em>
   <code>
    matrix
   </code>
   .
  </p>
  <p>
   A
   <strong>
    falling path
   </strong>
   starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position
   <code>
    (row, col)
   </code>
   will be
   <code>
    (row + 1, col - 1)
   </code>
   ,
   <code>
    (row + 1, col)
   </code>
   , or
   <code>
    (row + 1, col + 1)
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> matrix = [[2,1,3],[6,5,4],[7,8,9]]
<strong>Output:</strong> 13
<strong>Explanation:</strong> There are two falling paths with a minimum sum underlined below:
[[2,<u>1</u>,3],      [[2,<u>1</u>,3],
 [6,<u>5</u>,4],       [6,5,<u>4</u>],
 [<u>7</u>,8,9]]       [7,<u>8</u>,9]]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> matrix = [[-19,57],[-40,-5]]
<strong>Output:</strong> -59
<strong>Explanation:</strong> The falling path with a minimum sum is underlined below:
[[<u>-19</u>,57],
 [<u>-40</u>,-5]]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> matrix = [[-48]]
<strong>Output:</strong> -48
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == matrix.length
    </code>
   </li>
   <li>
    <code>
     n == matrix[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 100
    </code>
   </li>
   <li>
    <code>
     -100 &lt;= matrix[i][j] &lt;= 100
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 931 -->
<pre>/*
 * @lc app=leetcode id=931 lang=cpp
 *
 * [931] Minimum Falling Path Sum
 */

// @lc code=start
class Solution {
public:
    int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; a) {
        int n=a.size();
        for(int i=1; i&lt;n; i++){
            for(int j=0; j&lt;n; j++){
                if(j==0) a[i][j] =a[i][j] +min(a[i-1][j],a[i-1][j+1]);
                else if(j==n-1) a[i][j] =a[i][j] +min(a[i-1][j],a[i-1][j-1]);
                else a[i][j] =a[i][j] +min({a[i-1][j],a[i-1][j+1],a[i-1][j-1]});
            }
        }
        int sum=INT_MAX;
        for(int i=0; i&lt;n;i++)
        {
            sum=min(sum,a[n-1][i]);
        }
        return sum;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 932. Beautiful Array
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   An array
   <code>
    nums
   </code>
   of length
   <code>
    n
   </code>
   is
   <strong>
    beautiful
   </strong>
   if:
  </p>
  <ul>
   <li>
    <code>
     nums
    </code>
    is a permutation of the integers in the range
    <code>
     [1, n]
    </code>
    .
   </li>
   <li>
    For every
    <code>
     0 &lt;= i &lt; j &lt; n
    </code>
    , there is no index
    <code>
     k
    </code>
    with
    <code>
     i &lt; k &lt; j
    </code>
    where
    <code>
     2 * nums[k] == nums[i] + nums[j]
    </code>
    .
   </li>
  </ul>
  <p>
   Given the integer
   <code>
    n
   </code>
   , return
   <em>
    any
    <strong>
     beautiful
    </strong>
    array
   </em>
   <code>
    nums
   </code>
   <em>
    of length
   </em>
   <code>
    n
   </code>
   . There will be at least one valid answer for the given
   <code>
    n
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 4
<strong>Output:</strong> [2,1,4,3]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 5
<strong>Output:</strong> [3,1,2,5,4]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 932 -->
<pre>/*
 * @lc app=leetcode id=932 lang=cpp
 *
 * [932] Beautiful Array
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; beautifulArray(int n) {
        return a;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 935. Knight Dialer
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   The chess knight has a
   <strong>
    unique movement
   </strong>
   , it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an
   <strong>
    L
   </strong>
   ). The possible movements of chess knight are shown in this diagaram:
  </p>
  <p>
   A chess knight can move as indicated in the chess diagram below:
  </p>
  <img alt="" src="./output_files/chess.jpg" style="width: 402px; height: 402px;"/>
  <p>
   We have a chess knight and a phone pad as shown below, the knight
   <strong>
    can only stand on a numeric cell
   </strong>
   (i.e. blue cell).
  </p>
  <img alt="" src="./output_files/phone.jpg" style="width: 242px; height: 322px;"/>
  <p>
   Given an integer
   <code>
    n
   </code>
   , return how many distinct phone numbers of length
   <code>
    n
   </code>
   we can dial.
  </p>
  <p>
   You are allowed to place the knight
   <strong>
    on any numeric cell
   </strong>
   initially and then you should perform
   <code>
    n - 1
   </code>
   jumps to dial a number of length
   <code>
    n
   </code>
   . All jumps should be
   <strong>
    valid
   </strong>
   knight jumps.
  </p>
  <p>
   As the answer may be very large,
   <strong>
    return the answer modulo
   </strong>
   <code>
    10
    <sup>
     9
    </sup>
    + 7
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1
<strong>Output:</strong> 10
<strong>Explanation:</strong> We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 2
<strong>Output:</strong> 20
<strong>Explanation:</strong> All the valid number we can dial are [04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 3
<strong>Output:</strong> 46
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 4
<strong>Output:</strong> 104
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 3131
<strong>Output:</strong> 136006598
<strong>Explanation:</strong> Please take care of the mod.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 5000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 935 -->
<pre>/*
 * @lc app=leetcode id=935 lang=cpp
 *
 * [935] Knight Dialer
 */

// @lc code=start
class Solution {
public:
/*
    long func(int i, int j, int hops, vector&lt;vector&lt;vector&lt;long&gt;&gt;&gt; &amp;dp){
        if(i&lt;0 || i&gt;=4 || j&lt;0 || j&gt;=3 || (i==3 &amp;&amp; j!=1))  return 0;
        if(hops == 1)   return 1;

        if(dp[i][j][hops] != -1)
            return dp[i][j][hops];

        dp[i][j][hops] = func(i-2, j-1, hops-1, dp)%mod+func(i-2, j+1, hops-1, dp)%mod+
                       func(i-1, j-2, hops-1, dp)%mod+func(i+1, j-2, hops-1, dp)%mod+
                       func(i-1, j+2, hops-1, dp)%mod+func(i+1, j+2, hops-1, dp)%mod+
                       func(i+2, j-1, hops-1, dp)%mod+func(i+2, j+1, hops-1, dp)%mod;

        return dp[i][j][hops];
    }

    int mod = 1e9+7;
    */
    int knightDialer(int n) {
        /*
        vector&lt;vector&lt;vector&lt;long&gt;&gt;&gt; dp (4, vector&lt;vector&lt;long&gt;&gt; (3, vector&lt;long&gt; (n+1, -1)));
        long ans=0;
        for(int i=0; i&lt;4; i++)
            for(int j=0; j&lt;3; j++)
                ans = (ans+func(i, j, n, dp))%mod;

        return (int)ans;
        */
       vector&lt;int&gt;dp(10,1);
       map&lt;int,vector&lt;int&gt;&gt;m;
       m[0]={4,6};
       m[1]={6,8};
       m[2]={7,9};
       m[3]={4,8};
       m[4]={0,3,9};
       m[5]={};
       m[6]={0,1,7};
       m[7]={2,6};
       m[8]={1,3};
       m[9]={2,4};
       int mod=1e9+7;
       for(int i=0;i&lt;n-1;i++){
        vector&lt;int&gt;dp1(10,0);
        for(int j=0;j&lt;10;j++){
            for(int x:m[j]){
                dp1[j]+=dp[x];
                dp1[j]%=mod;
            }
        }
        dp=dp1;
       }
       int sum=0;
       for(int i=0;i&lt;10;i++){
        sum=sum+(dp[i]%mod);
        sum=sum%mod;
       }
       return sum;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 938. Range Sum of BST
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   node of a binary search tree and two integers
   <code>
    low
   </code>
   and
   <code>
    high
   </code>
   , return
   <em>
    the sum of values of all nodes with a value in the
    <strong>
     inclusive
    </strong>
    range
   </em>
   <code>
    [low, high]
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/bst1(1).jpg" style="width: 400px; height: 222px;"/>
  <pre><strong>Input:</strong> root = [10,5,15,3,7,null,18], low = 7, high = 15
<strong>Output:</strong> 32
<strong>Explanation:</strong> Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/bst2(1).jpg" style="width: 400px; height: 335px;"/>
  <pre><strong>Input:</strong> root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10
<strong>Output:</strong> 23
<strong>Explanation:</strong> Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [1, 2 * 10
     <sup>
      4
     </sup>
     ]
    </code>
    .
   </li>
   <li>
    <code>
     1 &lt;= Node.val &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     1 &lt;= low &lt;= high &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    All
    <code>
     Node.val
    </code>
    are
    <strong>
     unique
    </strong>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 938 -->
<pre>/*
 * @lc app=leetcode id=938 lang=cpp
 *
 * [938] Range Sum of BST
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        if(root==NULL) return 0;
        if(root-&gt;val &lt; low) return rangeSumBST(root-&gt;right, low, high);
        else if(root-&gt;val &gt; high) return rangeSumBST(root-&gt;left, low, high);
        return root-&gt;val+ rangeSumBST(root-&gt;right, low, high)+rangeSumBST(root-&gt;left, low, high);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 947. Most Stones Removed with Same Row or Column
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   On a 2D plane, we place
   <code>
    n
   </code>
   stones at some integer coordinate points. Each coordinate point may have at most one stone.
  </p>
  <p>
   A stone can be removed if it shares either
   <strong>
    the same row or the same column
   </strong>
   as another stone that has not been removed.
  </p>
  <p>
   Given an array
   <code>
    stones
   </code>
   of length
   <code>
    n
   </code>
   where
   <code>
    stones[i] = [x
    <sub>
     i
    </sub>
    , y
    <sub>
     i
    </sub>
    ]
   </code>
   represents the location of the
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   stone, return
   <em>
    the largest possible number of stones that can be removed
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]
<strong>Output:</strong> 5
<strong>Explanation:</strong> One way to remove 5 stones is as follows:
1. Remove stone [2,2] because it shares the same row as [2,1].
2. Remove stone [2,1] because it shares the same column as [0,1].
3. Remove stone [1,2] because it shares the same row as [1,0].
4. Remove stone [1,0] because it shares the same column as [0,0].
5. Remove stone [0,1] because it shares the same row as [0,0].
Stone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> One way to make 3 moves is as follows:
1. Remove stone [2,2] because it shares the same row as [2,0].
2. Remove stone [2,0] because it shares the same column as [0,0].
3. Remove stone [0,2] because it shares the same row as [0,0].
Stones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> stones = [[0,0]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> [0,0] is the only stone on the plane, so you cannot remove it.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= stones.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     0 &lt;= x
     <sub>
      i
     </sub>
     , y
     <sub>
      i
     </sub>
     &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    No two stones are at the same coordinate point.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 947 -->
<pre>/*
 * @lc app=leetcode id=947 lang=cpp
 *
 * [947] Most Stones Removed with Same Row or Column
 */

// @lc code=start
class Solution {
public:
vector&lt;int&gt;parent;
    int removeStones(vector&lt;vector&lt;int&gt;&gt;&amp; stones) {
        int n = stones.size();
        vector&lt;vector&lt;int&gt;&gt;graph;
        for(auto x:)
        parent.resize(n);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 948. Bag of Tokens
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You have an initial
   <strong>
    power
   </strong>
   of
   <code>
    power
   </code>
   , an initial
   <strong>
    score
   </strong>
   of
   <code>
    0
   </code>
   , and a bag of
   <code>
    tokens
   </code>
   where
   <code>
    tokens[i]
   </code>
   is the value of the
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   token (0-indexed).
  </p>
  <p>
   Your goal is to maximize your total
   <strong>
    score
   </strong>
   by potentially playing each token in one of two ways:
  </p>
  <ul>
   <li>
    If your current
    <strong>
     power
    </strong>
    is at least
    <code>
     tokens[i]
    </code>
    , you may play the
    <code>
     i
     <sup>
      th
     </sup>
    </code>
    token face up, losing
    <code>
     tokens[i]
    </code>
    <strong>
     power
    </strong>
    and gaining
    <code>
     1
    </code>
    <strong>
     score
    </strong>
    .
   </li>
   <li>
    If your current
    <strong>
     score
    </strong>
    is at least
    <code>
     1
    </code>
    , you may play the
    <code>
     i
     <sup>
      th
     </sup>
    </code>
    token face down, gaining
    <code>
     tokens[i]
    </code>
    <strong>
     power
    </strong>
    and losing
    <code>
     1
    </code>
    <strong>
     score
    </strong>
    .
   </li>
  </ul>
  <p>
   Each token may be played
   <strong>
    at most
   </strong>
   once and
   <strong>
    in any order
   </strong>
   . You do
   <strong>
    not
   </strong>
   have to play all the tokens.
  </p>
  <p>
   Return
   <em>
    the largest possible
    <strong>
     score
    </strong>
    you can achieve after playing any number of tokens
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> tokens = [100], power = 50
<strong>Output:</strong> 0
<strong>Explanation</strong><strong>:</strong> Playing the only token in the bag is impossible because you either have too little power or too little score.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> tokens = [100,200], power = 150
<strong>Output:</strong> 1
<strong>Explanation:</strong> Play the 0<sup>th</sup> token (100) face up, your power becomes 50 and score becomes 1.
There is no need to play the 1<sup>st</sup> token since you cannot play it face up to add to your score.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> tokens = [100,200,300,400], power = 200
<strong>Output:</strong> 2
<strong>Explanation:</strong> Play the tokens in this order to get a score of 2:
1. Play the 0<sup>th</sup> token (100) face up, your power becomes 100 and score becomes 1.
2. Play the 3<sup>rd</sup> token (400) face down, your power becomes 500 and score becomes 0.
3. Play the 1<sup>st</sup> token (200) face up, your power becomes 300 and score becomes 1.
4. Play the 2<sup>nd </sup>token (300) face up, your power becomes 0 and score becomes 2.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     0 &lt;= tokens.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     0 &lt;= tokens[i], power &lt; 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 948 -->
<pre>/*
 * @lc app=leetcode id=948 lang=cpp
 *
 * [948] Bag of Tokens
 */

// @lc code=start
class Solution {
public:
    int bagOfTokensScore(vector&lt;int&gt;&amp; tokens, int power) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 953. Verifying an Alien Dictionary
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different
   <code>
    order
   </code>
   . The
   <code>
    order
   </code>
   of the alphabet is some permutation of lowercase letters.
  </p>
  <p>
   Given a sequence of
   <code>
    words
   </code>
   written in the alien language, and the
   <code>
    order
   </code>
   of the alphabet, return
   <code>
    true
   </code>
   if and only if the given
   <code>
    words
   </code>
   are sorted lexicographically in this alien language.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"
<strong>Output:</strong> true
<strong>Explanation: </strong>As 'h' comes before 'l' in this language, then the sequence is sorted.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"
<strong>Output:</strong> false
<strong>Explanation: </strong>As 'd' comes after 'l' in this language, then words[0] &gt; words[1], hence the sequence is unsorted.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"
<strong>Output:</strong> false
<strong>Explanation: </strong>The first three characters "app" match, and the second string is shorter (in size.) According to lexicographical rules "apple" &gt; "app", because 'l' &gt; '∅', where '∅' is defined as the blank character which is less than any other character (<a href="https://en.wikipedia.org/wiki/Lexicographical_order" target="_blank">More info</a>).
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= words.length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     1 &lt;= words[i].length &lt;= 20
    </code>
   </li>
   <li>
    <code>
     order.length == 26
    </code>
   </li>
   <li>
    All characters in
    <code>
     words[i]
    </code>
    and
    <code>
     order
    </code>
    are English lowercase letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 953 -->
<pre>/*
 * @lc app=leetcode id=953 lang=cpp
 *
 * [953] Verifying an Alien Dictionary
 */

// @lc code=start
class Solution {
public:
    bool isAlienSorted(vector&lt;string&gt;&amp; words, string order) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 960. Delete Columns to Make Sorted III
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an array of
   <code>
    n
   </code>
   strings
   <code>
    strs
   </code>
   , all of the same length.
  </p>
  <p>
   We may choose any deletion indices, and we delete all the characters in those indices for each string.
  </p>
  <p>
   For example, if we have
   <code>
    strs = ["abcdef","uvwxyz"]
   </code>
   and deletion indices
   <code>
    {0, 2, 3}
   </code>
   , then the final array after deletions is
   <code>
    ["bef", "vyz"]
   </code>
   .
  </p>
  <p>
   Suppose we chose a set of deletion indices
   <code>
    answer
   </code>
   such that after deletions, the final array has
   <strong>
    every string (row) in lexicographic
   </strong>
   order. (i.e.,
   <code>
    (strs[0][0] &lt;= strs[0][1] &lt;= ... &lt;= strs[0][strs[0].length - 1])
   </code>
   , and
   <code>
    (strs[1][0] &lt;= strs[1][1] &lt;= ... &lt;= strs[1][strs[1].length - 1])
   </code>
   , and so on). Return
   <em>
    the minimum possible value of
   </em>
   <code>
    answer.length
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> strs = ["babca","bbazb"]
<strong>Output:</strong> 3
<strong>Explanation:</strong> After deleting columns 0, 1, and 4, the final array is strs = ["bc", "az"].
Both these rows are individually in lexicographic order (ie. strs[0][0] &lt;= strs[0][1] and strs[1][0] &lt;= strs[1][1]).
Note that strs[0] &gt; strs[1] - the array strs is not necessarily in lexicographic order.</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> strs = ["edcba"]
<strong>Output:</strong> 4
<strong>Explanation:</strong> If we delete less than 4 columns, the only row will not be lexicographically sorted.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> strs = ["ghi","def","abc"]
<strong>Output:</strong> 0
<strong>Explanation:</strong> All rows are already lexicographically sorted.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == strs.length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 100
    </code>
   </li>
   <li>
    <code>
     1 &lt;= strs[i].length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     strs[i]
    </code>
    consists of lowercase English letters.
   </li>
  </ul>
  <ul>
   <li>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 960 -->
<pre>/*
 * @lc app=leetcode id=960 lang=cpp
 *
 * [960] Delete Columns to Make Sorted III
 */

// @lc code=start
class Solution {
public:
    bool check(vector&lt;string&gt;&amp; strs,int i,int j){
        for(int k=0;k&lt;strs.size();k++){
            if(strs[k][i]&lt;strs[k][j]) return 0;
        }
        return 1;
    }
    int minDeletionSize(vector&lt;string&gt;&amp; strs) {
        vector&lt;int&gt;lis(strs[0].length(),1);
        int ans=1;
        for(int i=0; i&lt;strs[0].length(); i++){
            for(int j=0; j&lt;i; j++){
                if(check(strs,i,j))
                lis[i]=max(lis[i],1+lis[j]);
            }
            ans=max(ans,lis[i]);
        }

        return strs[0].length()-ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 965. Univalued Binary Tree
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   A binary tree is
   <strong>
    uni-valued
   </strong>
   if every node in the tree has the same value.
  </p>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree, return
   <code>
    true
   </code>
   <em>
    if the given tree is
    <strong>
     uni-valued
    </strong>
    , or
   </em>
   <code>
    false
   </code>
   <em>
    otherwise.
   </em>
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/unival_bst_1.png" style="width: 265px; height: 172px;"/>
  <pre><strong>Input:</strong> root = [1,1,1,1,1,null,1]
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/unival_bst_2.png" style="width: 198px; height: 169px;"/>
  <pre><strong>Input:</strong> root = [2,2,2,5,2]
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [1, 100]
    </code>
    .
   </li>
   <li>
    <code>
     0 &lt;= Node.val &lt; 100
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 965 -->
<pre>/*
 * @lc app=leetcode id=965 lang=cpp
 *
 * [965] Univalued Binary Tree
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool inorder(TreeNode *root,int x){
        if(root){
            if(x==root-&gt;val)
            return inorder(root-&gt;left,x) &amp;&amp; inorder(root-&gt;right,x) ;
            return false;
         }
         else return true;
    }
    bool isUnivalTree(TreeNode* root) {
        return inorder(root,root-&gt;val);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 969. Pancake Sorting
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of integers
   <code>
    arr
   </code>
   , sort the array by performing a series of
   <strong>
    pancake flips
   </strong>
   .
  </p>
  <p>
   In one pancake flip we do the following steps:
  </p>
  <ul>
   <li>
    Choose an integer
    <code>
     k
    </code>
    where
    <code>
     1 &lt;= k &lt;= arr.length
    </code>
    .
   </li>
   <li>
    Reverse the sub-array
    <code>
     arr[0...k-1]
    </code>
    (
    <strong>
     0-indexed
    </strong>
    ).
   </li>
  </ul>
  <p>
   For example, if
   <code>
    arr = [3,2,1,4]
   </code>
   and we performed a pancake flip choosing
   <code>
    k = 3
   </code>
   , we reverse the sub-array
   <code>
    [3,2,1]
   </code>
   , so
   <code>
    arr = [
    <u>
     1
    </u>
    ,
    <u>
     2
    </u>
    ,
    <u>
     3
    </u>
    ,4]
   </code>
   after the pancake flip at
   <code>
    k = 3
   </code>
   .
  </p>
  <p>
   Return
   <em>
    an array of the
   </em>
   <code>
    k
   </code>
   <em>
    -values corresponding to a sequence of pancake flips that sort
   </em>
   <code>
    arr
   </code>
   . Any valid answer that sorts the array within
   <code>
    10 * arr.length
   </code>
   flips will be judged as correct.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> arr = [3,2,4,1]
<strong>Output:</strong> [4,2,4,3]
<strong>Explanation: </strong>
We perform 4 pancake flips, with k values 4, 2, 4, and 3.
Starting state: arr = [3, 2, 4, 1]
After 1st flip (k = 4): arr = [<u>1</u>, <u>4</u>, <u>2</u>, <u>3</u>]
After 2nd flip (k = 2): arr = [<u>4</u>, <u>1</u>, 2, 3]
After 3rd flip (k = 4): arr = [<u>3</u>, <u>2</u>, <u>1</u>, <u>4</u>]
After 4th flip (k = 3): arr = [<u>1</u>, <u>2</u>, <u>3</u>, 4], which is sorted.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> arr = [1,2,3]
<strong>Output:</strong> []
<strong>Explanation: </strong>The input is already sorted, so there is no need to flip anything.
Note that other answers, such as [3, 3], would also be accepted.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= arr.length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     1 &lt;= arr[i] &lt;= arr.length
    </code>
   </li>
   <li>
    All integers in
    <code>
     arr
    </code>
    are unique (i.e.
    <code>
     arr
    </code>
    is a permutation of the integers from
    <code>
     1
    </code>
    to
    <code>
     arr.length
    </code>
    ).
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 969 -->
<pre>/*
 * @lc app=leetcode id=969 lang=cpp
 *
 * [969] Pancake Sorting
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; pancakeSort(vector&lt;int&gt;&amp; arr) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 976. Largest Perimeter Triangle
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    nums
   </code>
   , return
   <em>
    the largest perimeter of a triangle with a non-zero area, formed from three of these lengths
   </em>
   . If it is impossible to form any triangle of a non-zero area, return
   <code>
    0
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,1,2]
<strong>Output:</strong> 5
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,1]
<strong>Output:</strong> 0
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,2,3,4]
<strong>Output:</strong> 10
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,6,2,3]
<strong>Output:</strong> 8
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     3 &lt;= nums.length &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     1 &lt;= nums[i] &lt;= 10
     <sup>
      6
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 976 -->
<pre>/*
 * @lc app=leetcode id=976 lang=cpp
 *
 * [976] Largest Perimeter Triangle
 */

// @lc code=start
class Solution {
public:
    int largestPerimeter(vector&lt;int&gt;&amp; a) {
        sort(a.begin(), a.end(),greater&lt;int&gt;());
        for(int i = 0; i &lt; a.size()-2;i++){
            if(a[i]&lt;a[i+1]+a[i+2])
            {
                return a[i]+a[i+1]+a[i+2];
            }
        }
        return 0;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 983. Minimum Cost For Tickets
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array
   <code>
    days
   </code>
   . Each day is an integer from
   <code>
    1
   </code>
   to
   <code>
    365
   </code>
   .
  </p>
  <p>
   Train tickets are sold in
   <strong>
    three different ways
   </strong>
   :
  </p>
  <ul>
   <li>
    a
    <strong>
     1-day
    </strong>
    pass is sold for
    <code>
     costs[0]
    </code>
    dollars,
   </li>
   <li>
    a
    <strong>
     7-day
    </strong>
    pass is sold for
    <code>
     costs[1]
    </code>
    dollars, and
   </li>
   <li>
    a
    <strong>
     30-day
    </strong>
    pass is sold for
    <code>
     costs[2]
    </code>
    dollars.
   </li>
  </ul>
  <p>
   The passes allow that many days of consecutive travel.
  </p>
  <ul>
   <li>
    For example, if we get a
    <strong>
     7-day
    </strong>
    pass on day
    <code>
     2
    </code>
    , then we can travel for
    <code>
     7
    </code>
    days:
    <code>
     2
    </code>
    ,
    <code>
     3
    </code>
    ,
    <code>
     4
    </code>
    ,
    <code>
     5
    </code>
    ,
    <code>
     6
    </code>
    ,
    <code>
     7
    </code>
    , and
    <code>
     8
    </code>
    .
   </li>
  </ul>
  <p>
   Return
   <em>
    the minimum number of dollars you need to travel every day in the given list of days
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> days = [1,4,6,7,8,20], costs = [2,7,15]
<strong>Output:</strong> 11
<strong>Explanation:</strong> For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.
On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.
On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.
In total, you spent $11 and covered all the days of your travel.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]
<strong>Output:</strong> 17
<strong>Explanation:</strong> For example, here is one way to buy passes that lets you travel your travel plan:
On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.
On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.
In total, you spent $17 and covered all the days of your travel.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= days.length &lt;= 365
    </code>
   </li>
   <li>
    <code>
     1 &lt;= days[i] &lt;= 365
    </code>
   </li>
   <li>
    <code>
     days
    </code>
    is in strictly increasing order.
   </li>
   <li>
    <code>
     costs.length == 3
    </code>
   </li>
   <li>
    <code>
     1 &lt;= costs[i] &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 983 -->
<pre>/*
 * @lc app=leetcode id=983 lang=cpp
 *
 * [983] Minimum Cost For Tickets
 */

// @lc code=start
class Solution {
public:
    int mincostTickets(vector&lt;int&gt;&amp; days, vector&lt;int&gt;&amp; costs) {
        unordered_map&lt;int, int &gt; tickets;
        tickets[1] = costs[0];
        tickets[7] = costs[1];
        tickets[30] = costs[2];

        vector&lt;int&gt;dp(366,INT_MAX);

        dp[0]=0;

        for(int i=1; i&lt;366;i++){
            if(find(days.begin(), days.end(),i)==days.end()){
                dp[i]=dp[i-1];
                continue;
            }
            for( auto ticket : tickets){
                dp[i]=min(dp[i],dp[max(0,i-ticket.first)]+ticket.second);
            }
        }
        return dp[365];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 990. Satisfiability of Equality Equations
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an array of strings
   <code>
    equations
   </code>
   that represent relationships between variables where each string
   <code>
    equations[i]
   </code>
   is of length
   <code>
    4
   </code>
   and takes one of two different forms:
   <code>
    "x
    <sub>
     i
    </sub>
    ==y
    <sub>
     i
    </sub>
    "
   </code>
   or
   <code>
    "x
    <sub>
     i
    </sub>
    !=y
    <sub>
     i
    </sub>
    "
   </code>
   .Here,
   <code>
    x
    <sub>
     i
    </sub>
   </code>
   and
   <code>
    y
    <sub>
     i
    </sub>
   </code>
   are lowercase letters (not necessarily different) that represent one-letter variable names.
  </p>
  <p>
   Return
   <code>
    true
   </code>
   <em>
    if it is possible to assign integers to variable names so as to satisfy all the given equations, or
   </em>
   <code>
    false
   </code>
   <em>
    otherwise
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> equations = ["a==b","b!=a"]
<strong>Output:</strong> false
<strong>Explanation:</strong> If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.
There is no way to assign the variables to satisfy both equations.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> equations = ["b==a","a==b"]
<strong>Output:</strong> true
<strong>Explanation:</strong> We could assign a = 1 and b = 1 to satisfy both equations.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> equations = ["a==b","b==c","a==c"]
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> equations = ["a==b","b!=c","c==a"]
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> equations = ["c==c","b==d","x!=z"]
<strong>Output:</strong> true
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= equations.length &lt;= 500
    </code>
   </li>
   <li>
    <code>
     equations[i].length == 4
    </code>
   </li>
   <li>
    <code>
     equations[i][0]
    </code>
    is a lowercase letter.
   </li>
   <li>
    <code>
     equations[i][1]
    </code>
    is either
    <code>
     '='
    </code>
    or
    <code>
     '!'
    </code>
    .
   </li>
   <li>
    <code>
     equations[i][2]
    </code>
    is
    <code>
     '='
    </code>
    .
   </li>
   <li>
    <code>
     equations[i][3]
    </code>
    is a lowercase letter.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 990 -->
<pre>/*
 * @lc app=leetcode id=990 lang=cpp
 *
 * [990] Satisfiability of Equality Equations
 */

// @lc code=start
class Solution {
public:
    bool equationsPossible(vector&lt;string&gt;&amp; equations) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 993. Cousins in Binary Tree
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a binary tree with unique values and the values of two different nodes of the tree
   <code>
    x
   </code>
   and
   <code>
    y
   </code>
   , return
   <code>
    true
   </code>
   <em>
    if the nodes corresponding to the values
   </em>
   <code>
    x
   </code>
   <em>
    and
   </em>
   <code>
    y
   </code>
   <em>
    in the tree are
    <strong>
     cousins
    </strong>
    , or
   </em>
   <code>
    false
   </code>
   <em>
    otherwise.
   </em>
  </p>
  <p>
   Two nodes of a binary tree are
   <strong>
    cousins
   </strong>
   if they have the same depth with different parents.
  </p>
  <p>
   Note that in a binary tree, the root node is at the depth
   <code>
    0
   </code>
   , and children of each depth
   <code>
    k
   </code>
   node are at the depth
   <code>
    k + 1
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/q1248-01.png" style="width: 304px; height: 270px;"/>
  <pre><strong>Input:</strong> root = [1,2,3,4], x = 4, y = 3
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/q1248-02.png" style="width: 334px; height: 266px;"/>
  <pre><strong>Input:</strong> root = [1,2,3,null,4,null,5], x = 5, y = 4
<strong>Output:</strong> true
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <img alt="" src="./output_files/q1248-03.png" style="width: 267px; height: 258px;"/>
  <pre><strong>Input:</strong> root = [1,2,3,null,4], x = 2, y = 3
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [2, 100]
    </code>
    .
   </li>
   <li>
    <code>
     1 &lt;= Node.val &lt;= 100
    </code>
   </li>
   <li>
    Each node has a
    <strong>
     unique
    </strong>
    value.
   </li>
   <li>
    <code>
     x != y
    </code>
   </li>
   <li>
    <code>
     x
    </code>
    and
    <code>
     y
    </code>
    are exist in the tree.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 993 -->
<pre>/*
 * @lc app=leetcode id=993 lang=cpp
 *
 * [993] Cousins in Binary Tree
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void inorder(TreeNode *root,TreeNode *rootbef,int depth,vector&lt;pair&lt;TreeNode*,int&gt;&gt;&amp;ans,int x,int y){
        if(root){
            if(root-&gt;val==x || root-&gt;val==y)
            ans.push_back({rootbef,depth});
            inorder(root-&gt;left,root,depth+1,ans,x,y);
            inorder(root-&gt;right,root,depth+1,ans,x,y);
        }
    }
    bool isCousins(TreeNode* root, int x, int y) {
        vector&lt;pair&lt;TreeNode*,int&gt;&gt;ans;
        int depth=0;
        inorder(root,NULL,depth,ans,x,y);
        if(ans[0].first!=ans[1].first &amp;&amp; ans[0].second==ans[1].second)
        {
            return true;
        }
        return false;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 994. Rotting Oranges
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an
   <code>
    m x n
   </code>
   <code>
    grid
   </code>
   where each cell can have one of three values:
  </p>
  <ul>
   <li>
    <code>
     0
    </code>
    representing an empty cell,
   </li>
   <li>
    <code>
     1
    </code>
    representing a fresh orange, or
   </li>
   <li>
    <code>
     2
    </code>
    representing a rotten orange.
   </li>
  </ul>
  <p>
   Every minute, any fresh orange that is
   <strong>
    4-directionally adjacent
   </strong>
   to a rotten orange becomes rotten.
  </p>
  <p>
   Return
   <em>
    the minimum number of minutes that must elapse until no cell has a fresh orange
   </em>
   . If
   <em>
    this is impossible, return
   </em>
   <code>
    -1
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/oranges.png" style="width: 650px; height: 137px;"/>
  <pre><strong>Input:</strong> grid = [[2,1,1],[1,1,0],[0,1,1]]
<strong>Output:</strong> 4
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> grid = [[2,1,1],[0,1,1],[1,0,1]]
<strong>Output:</strong> -1
<strong>Explanation:</strong> The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> grid = [[0,2]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> Since there are already no fresh oranges at minute 0, the answer is just 0.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == grid.length
    </code>
   </li>
   <li>
    <code>
     n == grid[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m, n &lt;= 10
    </code>
   </li>
   <li>
    <code>
     grid[i][j]
    </code>
    is
    <code>
     0
    </code>
    ,
    <code>
     1
    </code>
    , or
    <code>
     2
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 994 -->
<pre>/*
 * @lc app=leetcode id=994 lang=cpp
 *
 * [994] Rotting Oranges
 */

// @lc code=start
class Solution {
public:
    int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int rows=grid.size();
        int cols=grid[0].size();
        queue&lt;pair&lt;int,int&gt;&gt;q;
        int count=0;
        for(int i=0; i&lt;rows; i++){
            for(int j=0; j&lt;cols; j++){
                if(grid[i][j]==2) {
                    q.push({i-1,j});
                    q.push({i+1,j});
                    q.push({i,j-1});
                    q.push({i,j+1});
                }
                else if(grid[i][j]==1) count++;
            }
        }
        
        if(count==0) return 0;
        int steps=0;
        while(!q.empty()){
            steps++;
            int t=q.size();
            for(int i=0; i&lt;t; i++){
                auto x = q.front();
                q.pop();
                int row = x.first;
                int col = x.second;
                if(row&gt;=0 &amp;&amp; col&gt;=0 &amp;&amp; row&lt;rows &amp;&amp; col&lt;cols &amp;&amp; grid[row][col]==1)
                {
                    grid[row][col]=2;
                    q.push({row-1,col});
                    q.push({row+1,col});
                    q.push({row,col-1});
                    q.push({row,col+1});
                }
            }
        }

        for(int i=0; i&lt;rows; i++){
            for(int j=0; j&lt;cols; j++){
                if(grid[i][j]==1)
                return -1;
            }
        }
        return steps-1;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1003. Check If Word Is Valid After Substitutions
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    s
   </code>
   , determine if it is
   <strong>
    valid
   </strong>
   .
  </p>
  <p>
   A string
   <code>
    s
   </code>
   is
   <strong>
    valid
   </strong>
   if, starting with an empty string
   <code>
    t = ""
   </code>
   , you can
   <strong>
    transform
   </strong>
   <code>
    t
   </code>
   <strong>
    into
   </strong>
   <code>
    s
   </code>
   after performing the following operation
   <strong>
    any number of times
   </strong>
   :
  </p>
  <ul>
   <li>
    Insert string
    <code>
     "abc"
    </code>
    into any position in
    <code>
     t
    </code>
    . More formally,
    <code>
     t
    </code>
    becomes
    <code>
     t
     <sub>
      left
     </sub>
     + "abc" + t
     <sub>
      right
     </sub>
    </code>
    , where
    <code>
     t == t
     <sub>
      left
     </sub>
     + t
     <sub>
      right
     </sub>
    </code>
    . Note that
    <code>
     t
     <sub>
      left
     </sub>
    </code>
    and
    <code>
     t
     <sub>
      right
     </sub>
    </code>
    may be
    <strong>
     empty
    </strong>
    .
   </li>
  </ul>
  <p>
   Return
   <code>
    true
   </code>
   <em>
    if
   </em>
   <code>
    s
   </code>
   <em>
    is a
    <strong>
     valid
    </strong>
    string, otherwise, return
   </em>
   <code>
    false
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "aabcbc"
<strong>Output:</strong> true
<strong>Explanation:</strong>
"" -&gt; "<u>abc</u>" -&gt; "a<u>abc</u>bc"
Thus, "aabcbc" is valid.</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "abcabcababcc"
<strong>Output:</strong> true
<strong>Explanation:</strong>
"" -&gt; "<u>abc</u>" -&gt; "abc<u>abc</u>" -&gt; "abcabc<u>abc</u>" -&gt; "abcabcab<u>abc</u>c"
Thus, "abcabcababcc" is valid.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "abccba"
<strong>Output:</strong> false
<strong>Explanation:</strong> It is impossible to get "abccba" using the operation.
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "cababc"
<strong>Output:</strong> false
<strong>Explanation:</strong> It is impossible to get "cababc" using the operation.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 2 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    consists of letters
    <code>
     'a'
    </code>
    ,
    <code>
     'b'
    </code>
    , and
    <code>
     'c'
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1003 -->
<pre>/*
 * @lc app=leetcode id=1003 lang=cpp
 *
 * [1003] Check If Word Is Valid After Substitutions
 */

// @lc code=start
class Solution {
public:
    bool isValid(string s) {
        stack&lt;char&gt;st;
        for(char c:s){
            if(c==&#x27;c&#x27;){
                if(st.size() &lt; 2 || st.top()!=&#x27;b&#x27;) return false;
                st.pop();
                if(st.top()!=&#x27;a&#x27;) return false;
                st.pop();
            }
            else st.push(c);
        }
        return st.empty();
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1013. Partition Array Into Three Parts With Equal Sum
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of integers
   <code>
    arr
   </code>
   , return
   <code>
    true
   </code>
   if we can partition the array into three
   <strong>
    non-empty
   </strong>
   parts with equal sums.
  </p>
  <p>
   Formally, we can partition the array if we can find indexes
   <code>
    i + 1 &lt; j
   </code>
   with
   <code>
    (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])
   </code>
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> arr = [0,2,1,-6,6,-7,9,1,2,0,1]
<strong>Output:</strong> true
<strong>Explanation: </strong>0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> arr = [0,2,1,-6,6,7,9,-1,2,0,1]
<strong>Output:</strong> false
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> arr = [3,3,6,5,-2,2,5,1,-9,4]
<strong>Output:</strong> true
<strong>Explanation: </strong>3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     3 &lt;= arr.length &lt;= 5 * 10
     <sup>
      4
     </sup>
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= arr[i] &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1013 -->
<pre>/*
 * @lc app=leetcode id=1013 lang=cpp
 *
 * [1013] Partition Array Into Three Parts With Equal Sum
 */

// @lc code=start
class Solution {
public:
    bool canThreePartsEqualSum(vector&lt;int&gt;&amp; arr) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1020. Number of Enclaves
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an
   <code>
    m x n
   </code>
   binary matrix
   <code>
    grid
   </code>
   , where
   <code>
    0
   </code>
   represents a sea cell and
   <code>
    1
   </code>
   represents a land cell.
  </p>
  <p>
   A
   <strong>
    move
   </strong>
   consists of walking from one land cell to another adjacent (
   <strong>
    4-directionally
   </strong>
   ) land cell or walking off the boundary of the
   <code>
    grid
   </code>
   .
  </p>
  <p>
   Return
   <em>
    the number of land cells in
   </em>
   <code>
    grid
   </code>
   <em>
    for which we cannot walk off the boundary of the grid in any number of
    <strong>
     moves
    </strong>
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/enclaves1.jpg" style="width: 333px; height: 333px;"/>
  <pre><strong>Input:</strong> grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
<strong>Output:</strong> 3
<strong>Explanation:</strong> There are three 1s that are enclosed by 0s, and one 1 that is not enclosed because its on the boundary.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/enclaves2.jpg" style="width: 333px; height: 333px;"/>
  <pre><strong>Input:</strong> grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
<strong>Output:</strong> 0
<strong>Explanation:</strong> All 1s are either on the boundary or can reach the boundary.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     m == grid.length
    </code>
   </li>
   <li>
    <code>
     n == grid[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= m, n &lt;= 500
    </code>
   </li>
   <li>
    <code>
     grid[i][j]
    </code>
    is either
    <code>
     0
    </code>
    or
    <code>
     1
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1020 -->
<pre>/*
 * @lc app=leetcode id=1020 lang=cpp
 *
 * [1020] Number of Enclaves
 */

// @lc code=start
class Solution {
public:
    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; board,int x,int y){
        if(x&lt;0 || y&lt;0 || x&gt;=board.size()|| y&gt;=board[x].size()){
            return;
        }
        if(board[x][y]==0){
            return;
        }
        board[x][y] = 0;
        dfs(board,x-1,y);
        dfs(board,x+1,y);
        dfs(board,x,y-1);
        dfs(board,x,y+1);
    }
    int numEnclaves(vector&lt;vector&lt;int&gt;&gt;&amp; board) {
        for(int i = 0; i &lt; board.size();i++){
            for(int j = 0; j &lt; board[i].size();j++){
                if((i==0 || j==0|| i==board.size()-1 || j==board[i].size()-1) &amp;&amp; board[i][j]==1){
                    dfs(board,i,j);
                }
            }
        }
        int ans=0;
        for(int i = 0; i &lt; board.size();i++){
            for(int j = 0; j &lt; board[i].size();j++){
                if(board[i][j]==1) ans++;
            }
        }
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1022. Sum of Root To Leaf Binary Numbers
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given the
   <code>
    root
   </code>
   of a binary tree where each node has a value
   <code>
    0
   </code>
   or
   <code>
    1
   </code>
   .  Each root-to-leaf path represents a binary number starting with the most significant bit.  For example, if the path is
   <code>
    0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1
   </code>
   , then this could represent
   <code>
    01101
   </code>
   in binary, which is
   <code>
    13
   </code>
   .
  </p>
  <p>
   For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.
  </p>
  <p>
   Return
   <em>
    the sum of these numbers
   </em>
   . The answer is
   <strong>
    guaranteed
   </strong>
   to fit in a
   <strong>
    32-bits
   </strong>
   integer.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/sum-of-root-to-leaf-binary-numbers.png" style="width: 450px; height: 296px;"/>
  <pre><strong>Input:</strong> root = [1,0,1,0,1,0,1]
<strong>Output:</strong> 22
<strong>Explanation: </strong>(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [0]
<strong>Output:</strong> 0
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1]
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1,1]
<strong>Output:</strong> 3
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [1, 1000]
    </code>
    .
   </li>
   <li>
    <code>
     Node.val
    </code>
    is
    <code>
     0
    </code>
    or
    <code>
     1
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1022 -->
<pre>/*
 * @lc app=leetcode id=1022 lang=cpp
 *
 * [1022] Sum of Root To Leaf Binary Numbers
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int ans=0;
    void backtrack(TreeNode *root,string s){
        if(root==NULL) return;
        if(root-&gt;left==NULL &amp;&amp; root-&gt;right==NULL){
            s=s+to_string(root-&gt;val);
            cout&lt;&lt;stoi(s,0,2);
            ans=ans+stoi(s,0,2);
            return;
        }
        s=s+to_string(root-&gt;val);
        backtrack(root-&gt;left,s);
        backtrack(root-&gt;right,s);
    }
    int sumRootToLeaf(TreeNode* root) {
        backtrack(root,&quot;&quot;);
        return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1025. Divisor Game
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Alice and Bob take turns playing a game, with Alice starting first.
  </p>
  <p>
   Initially, there is a number
   <code>
    n
   </code>
   on the chalkboard. On each player's turn, that player makes a move consisting of:
  </p>
  <ul>
   <li>
    Choosing any
    <code>
     x
    </code>
    with
    <code>
     0 &lt; x &lt; n
    </code>
    and
    <code>
     n % x == 0
    </code>
    .
   </li>
   <li>
    Replacing the number
    <code>
     n
    </code>
    on the chalkboard with
    <code>
     n - x
    </code>
    .
   </li>
  </ul>
  <p>
   Also, if a player cannot make a move, they lose the game.
  </p>
  <p>
   Return
   <code>
    true
   </code>
   <em>
    if and only if Alice wins the game, assuming both players play optimally
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 2
<strong>Output:</strong> true
<strong>Explanation:</strong> Alice chooses 1, and Bob has no more moves.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 3
<strong>Output:</strong> false
<strong>Explanation:</strong> Alice chooses 1, Bob chooses 1, and Alice has no more moves.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1025 -->
<pre>/*
 * @lc app=leetcode id=1025 lang=cpp
 *
 * [1025] Divisor Game
 */

// @lc code=start
class Solution {
public:
    bool divisorGame(int n) {
        return !(n%2);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1038. Binary Search Tree to Greater Sum Tree
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the
   <code>
    root
   </code>
   of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.
  </p>
  <p>
   As a reminder, a
   <em>
    binary search tree
   </em>
   is a tree that satisfies these constraints:
  </p>
  <ul>
   <li>
    The left subtree of a node contains only nodes with keys
    <strong>
     less than
    </strong>
    the node's key.
   </li>
   <li>
    The right subtree of a node contains only nodes with keys
    <strong>
     greater than
    </strong>
    the node's key.
   </li>
   <li>
    Both the left and right subtrees must also be binary search trees.
   </li>
  </ul>
  <p>
   <strong>
    Note:
   </strong>
   This question is the same as 538:
   <a href="https://leetcode.com/problems/convert-bst-to-greater-tree/">
    https://leetcode.com/problems/convert-bst-to-greater-tree/
   </a>
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/tree(2).png" style="width: 550px; height: 375px;"/>
  <pre><strong>Input:</strong> root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
<strong>Output:</strong> [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [0,null,1]
<strong>Output:</strong> [1,null,1]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1,0,2]
<strong>Output:</strong> [3,3,2]
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [3,2,4,1]
<strong>Output:</strong> [7,9,4,10]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the tree is in the range
    <code>
     [1, 100]
    </code>
    .
   </li>
   <li>
    <code>
     0 &lt;= Node.val &lt;= 100
    </code>
   </li>
   <li>
    All the values in the tree are
    <strong>
     unique
    </strong>
    .
   </li>
   <li>
    <code>
     root
    </code>
    is guaranteed to be a valid binary search tree.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1038 -->
<pre>/*
 * @lc app=leetcode id=1038 lang=cpp
 *
 * [1038] Binary Search Tree to Greater Sum Tree
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int i=0;
    void inorder(TreeNode *root,vector&lt;int&gt;&amp; a){
        if(root!=NULL){
            inorder(root-&gt;left,a);
            a.push_back(root-&gt;val);
            inorder(root-&gt;right,a);
        }
    }
    void inorder2(TreeNode *root,vector&lt;int&gt; a){
        if(root!=NULL){
            inorder2(root-&gt;left,a);
            root-&gt;val=a[i++];
            inorder2(root-&gt;right,a);
        }
    }
    TreeNode* bstToGst(TreeNode* root) {
        if(root==NULL){return NULL;}
        vector&lt;int&gt;a;
        inorder(root,a);
        for(int i=a.size()-2;i&gt;=0;i--){
            a[i]=a[i]+a[i+1];
        }
        int i=0;
        inorder2(root,a);
        return root;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1046. Last Stone Weight
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an array of integers
   <code>
    stones
   </code>
   where
   <code>
    stones[i]
   </code>
   is the weight of the
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   stone.
  </p>
  <p>
   We are playing a game with the stones. On each turn, we choose the
   <strong>
    heaviest two stones
   </strong>
   and smash them together. Suppose the heaviest two stones have weights
   <code>
    x
   </code>
   and
   <code>
    y
   </code>
   with
   <code>
    x &lt;= y
   </code>
   . The result of this smash is:
  </p>
  <ul>
   <li>
    If
    <code>
     x == y
    </code>
    , both stones are destroyed, and
   </li>
   <li>
    If
    <code>
     x != y
    </code>
    , the stone of weight
    <code>
     x
    </code>
    is destroyed, and the stone of weight
    <code>
     y
    </code>
    has new weight
    <code>
     y - x
    </code>
    .
   </li>
  </ul>
  <p>
   At the end of the game, there is
   <strong>
    at most one
   </strong>
   stone left.
  </p>
  <p>
   Return
   <em>
    the smallest possible weight of the left stone
   </em>
   . If there are no stones left, return
   <code>
    0
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> stones = [2,7,4,1,8,1]
<strong>Output:</strong> 1
<strong>Explanation:</strong> 
We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,
we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,
we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,
we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> stones = [1]
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= stones.length &lt;= 30
    </code>
   </li>
   <li>
    <code>
     1 &lt;= stones[i] &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1046 -->
<pre>/*
 * @lc app=leetcode id=1046 lang=cpp
 *
 * [1046] Last Stone Weight
 */

// @lc code=start
class Solution {
public:
    int lastStoneWeight(vector&lt;int&gt;&amp; stones) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1048. Longest String Chain
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an array of
   <code>
    words
   </code>
   where each word consists of lowercase English letters.
  </p>
  <p>
   <code>
    word
    <sub>
     A
    </sub>
   </code>
   is a
   <strong>
    predecessor
   </strong>
   of
   <code>
    word
    <sub>
     B
    </sub>
   </code>
   if and only if we can insert
   <strong>
    exactly one
   </strong>
   letter anywhere in
   <code>
    word
    <sub>
     A
    </sub>
   </code>
   <strong>
    without changing the order of the other characters
   </strong>
   to make it equal to
   <code>
    word
    <sub>
     B
    </sub>
   </code>
   .
  </p>
  <ul>
   <li>
    For example,
    <code>
     "abc"
    </code>
    is a
    <strong>
     predecessor
    </strong>
    of
    <code>
     "ab
     <u>
      a
     </u>
     c"
    </code>
    , while
    <code>
     "cba"
    </code>
    is not a
    <strong>
     predecessor
    </strong>
    of
    <code>
     "bcad"
    </code>
    .
   </li>
  </ul>
  <p>
   A
   <strong>
    word chain
   </strong>
   <em>
   </em>
   is a sequence of words
   <code>
    [word
    <sub>
     1
    </sub>
    , word
    <sub>
     2
    </sub>
    , ..., word
    <sub>
     k
    </sub>
    ]
   </code>
   with
   <code>
    k &gt;= 1
   </code>
   , where
   <code>
    word
    <sub>
     1
    </sub>
   </code>
   is a
   <strong>
    predecessor
   </strong>
   of
   <code>
    word
    <sub>
     2
    </sub>
   </code>
   ,
   <code>
    word
    <sub>
     2
    </sub>
   </code>
   is a
   <strong>
    predecessor
   </strong>
   of
   <code>
    word
    <sub>
     3
    </sub>
   </code>
   , and so on. A single word is trivially a
   <strong>
    word chain
   </strong>
   with
   <code>
    k == 1
   </code>
   .
  </p>
  <p>
   Return
   <em>
    the
    <strong>
     length
    </strong>
    of the
    <strong>
     longest possible word chain
    </strong>
    with words chosen from the given list of
   </em>
   <code>
    words
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> words = ["a","b","ba","bca","bda","bdca"]
<strong>Output:</strong> 4
<strong>Explanation</strong>: One of the longest word chains is ["a","<u>b</u>a","b<u>d</u>a","bd<u>c</u>a"].
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> words = ["xbc","pcxbcf","xb","cxbc","pcxbc"]
<strong>Output:</strong> 5
<strong>Explanation:</strong> All the words can be put in a word chain ["xb", "xb<u>c</u>", "<u>c</u>xbc", "<u>p</u>cxbc", "pcxbc<u>f</u>"].
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> words = ["abcd","dbqca"]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The trivial word chain ["abcd"] is one of the longest word chains.
["abcd","dbqca"] is not a valid word chain because the ordering of the letters is changed.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= words.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     1 &lt;= words[i].length &lt;= 16
    </code>
   </li>
   <li>
    <code>
     words[i]
    </code>
    only consists of lowercase English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1048 -->
<pre>/*
 * @lc app=leetcode id=1048 lang=cpp
 *
 * [1048] Longest String Chain
 */

// @lc code=start
class Solution {
public:
    int longestStrChain(vector&lt;string&gt;&amp; words) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1049. Last Stone Weight II
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an array of integers
   <code>
    stones
   </code>
   where
   <code>
    stones[i]
   </code>
   is the weight of the
   <code>
    i
    <sup>
     th
    </sup>
   </code>
   stone.
  </p>
  <p>
   We are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights
   <code>
    x
   </code>
   and
   <code>
    y
   </code>
   with
   <code>
    x &lt;= y
   </code>
   . The result of this smash is:
  </p>
  <ul>
   <li>
    If
    <code>
     x == y
    </code>
    , both stones are destroyed, and
   </li>
   <li>
    If
    <code>
     x != y
    </code>
    , the stone of weight
    <code>
     x
    </code>
    is destroyed, and the stone of weight
    <code>
     y
    </code>
    has new weight
    <code>
     y - x
    </code>
    .
   </li>
  </ul>
  <p>
   At the end of the game, there is
   <strong>
    at most one
   </strong>
   stone left.
  </p>
  <p>
   Return
   <em>
    the smallest possible weight of the left stone
   </em>
   . If there are no stones left, return
   <code>
    0
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> stones = [2,7,4,1,8,1]
<strong>Output:</strong> 1
<strong>Explanation:</strong>
We can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,
we can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,
we can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,
we can combine 1 and 1 to get 0, so the array converts to [1], then that's the optimal value.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> stones = [31,26,33,21,40]
<strong>Output:</strong> 5
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> stones = [1,2]
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= stones.length &lt;= 30
    </code>
   </li>
   <li>
    <code>
     1 &lt;= stones[i] &lt;= 100
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1049 -->
<pre>/*
 * @lc app=leetcode id=1049 lang=cpp
 *
 * [1049] Last Stone Weight II
 */

// @lc code=start
class Solution {
public:
    int lastStoneWeightII(vector&lt;int&gt;&amp; stones) {
        int n = stones.size();
        vector&lt;int&gt;dp(n,INT_MAX);
        return 0;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1092. Shortest Common Supersequence
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two strings
   <code>
    str1
   </code>
   and
   <code>
    str2
   </code>
   , return
   <em>
    the shortest string that has both
   </em>
   <code>
    str1
   </code>
   <em>
    and
   </em>
   <code>
    str2
   </code>
   <em>
    as
    <strong>
     subsequences
    </strong>
   </em>
   . If there are multiple valid strings, return
   <strong>
    any
   </strong>
   of them.
  </p>
  <p>
   A string
   <code>
    s
   </code>
   is a
   <strong>
    subsequence
   </strong>
   of string
   <code>
    t
   </code>
   if deleting some number of characters from
   <code>
    t
   </code>
   (possibly
   <code>
    0
   </code>
   ) results in the string
   <code>
    s
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> str1 = "abac", str2 = "cab"
<strong>Output:</strong> "cabac"
<strong>Explanation:</strong> 
str1 = "abac" is a subsequence of "cabac" because we can delete the first "c".
str2 = "cab" is a subsequence of "cabac" because we can delete the last "ac".
The answer provided is the shortest such string that satisfies these properties.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> str1 = "aaaaaaaa", str2 = "aaaaaaaa"
<strong>Output:</strong> "aaaaaaaa"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= str1.length, str2.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     str1
    </code>
    and
    <code>
     str2
    </code>
    consist of lowercase English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1092 -->
<pre>/*
 * @lc app=leetcode id=1092 lang=cpp
 *
 * [1092] Shortest Common Supersequence
 */

// @lc code=start
class Solution {
public:
    string shortestCommonSupersequence(string str1, string str2) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
1813. Sentence Similarity III<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   A sentence is a list of words that are separated by a single space with no leading or trailing spaces. For example,
   <code>
    "Hello World"
   </code>
   ,
   <code>
    "HELLO"
   </code>
   ,
   <code>
    "hello world hello world"
   </code>
   are all sentences. Words consist of
   <strong>
    only
   </strong>
   uppercase and lowercase English letters.
  </p>
  <p>
   Two sentences
   <code>
    sentence1
   </code>
   and
   <code>
    sentence2
   </code>
   are
   <strong>
    similar
   </strong>
   if it is possible to insert an arbitrary sentence
   <strong>
    (possibly empty)
   </strong>
   inside one of these sentences such that the two sentences become equal. For example,
   <code>
    sentence1 = "Hello my name is Jane"
   </code>
   and
   <code>
    sentence2 = "Hello Jane"
   </code>
   can be made equal by inserting
   <code>
    "my name is"
   </code>
   between
   <code>
    "Hello"
   </code>
   and
   <code>
    "Jane"
   </code>
   in
   <code>
    sentence2
   </code>
   .
  </p>
  <p>
   Given two sentences
   <code>
    sentence1
   </code>
   and
   <code>
    sentence2
   </code>
   , return
   <code>
    true
   </code>
   <em>
    if
   </em>
   <code>
    sentence1
   </code>
   <em>
    and
   </em>
   <code>
    sentence2
   </code>
   <em>
    are similar.
   </em>
   Otherwise, return
   <code>
    false
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> sentence1 = "My name is Haley", sentence2 = "My Haley"
<strong>Output:</strong> true
<strong>Explanation:</strong> sentence2 can be turned to sentence1 by inserting "name is" between "My" and "Haley".
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> sentence1 = "of", sentence2 = "A lot of words"
<strong>Output:</strong> false
<strong>Explanation: </strong>No single sentence can be inserted inside one of the sentences to make it equal to the other.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> sentence1 = "Eating right now", sentence2 = "Eating"
<strong>Output:</strong> true
<strong>Explanation:</strong> sentence2 can be turned to sentence1 by inserting "right now" at the end of the sentence.
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> sentence1 = "Luky", sentence2 = "Lucccky"
<strong>Output:</strong> false
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= sentence1.length, sentence2.length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     sentence1
    </code>
    and
    <code>
     sentence2
    </code>
    consist of lowercase and uppercase English letters and spaces.
   </li>
   <li>
    The words in
    <code>
     sentence1
    </code>
    and
    <code>
     sentence2
    </code>
    are separated by a single space.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1114 -->
<pre>/*
 * @lc app=leetcode id=1114 lang=cpp
 *
 * [1114] Print in Order
 */

// @lc code=start
class Foo {
public:
    Foo() {
        
    }

    void first(function&lt;void()&gt; printFirst) {
        
        // printFirst() outputs &quot;first&quot;. Do not change or remove this line.
        printFirst();
    }

    void second(function&lt;void()&gt; printSecond) {
        
        // printSecond() outputs &quot;second&quot;. Do not change or remove this line.
        printSecond();
    }

    void third(function&lt;void()&gt; printThird) {
        
        // printThird() outputs &quot;third&quot;. Do not change or remove this line.
        printThird();
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1143. Longest Common Subsequence
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given two strings
   <code>
    text1
   </code>
   and
   <code>
    text2
   </code>
   , return
   <em>
    the length of their longest
    <strong>
     common subsequence
    </strong>
    .
   </em>
   If there is no
   <strong>
    common subsequence
   </strong>
   , return
   <code>
    0
   </code>
   .
  </p>
  <p>
   A
   <strong>
    subsequence
   </strong>
   of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.
  </p>
  <ul>
   <li>
    For example,
    <code>
     "ace"
    </code>
    is a subsequence of
    <code>
     "abcde"
    </code>
    .
   </li>
  </ul>
  <p>
   A
   <strong>
    common subsequence
   </strong>
   of two strings is a subsequence that is common to both strings.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> text1 = "abcde", text2 = "ace" 
<strong>Output:</strong> 3  
<strong>Explanation:</strong> The longest common subsequence is "ace" and its length is 3.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> text1 = "abc", text2 = "abc"
<strong>Output:</strong> 3
<strong>Explanation:</strong> The longest common subsequence is "abc" and its length is 3.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> text1 = "abc", text2 = "def"
<strong>Output:</strong> 0
<strong>Explanation:</strong> There is no such common subsequence, so the result is 0.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= text1.length, text2.length &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     text1
    </code>
    and
    <code>
     text2
    </code>
    consist of only lowercase English characters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1143 -->
<pre>/*
 * @lc app=leetcode id=1143 lang=cpp
 *
 * [1143] Longest Common Subsequence
 */

// @lc code=start
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m=text1.length();
        int n=text2.length();

        vector&lt;vector&lt;int&gt;&gt;dp(m+1,vector&lt;int&gt;(n+1,0));

        for(int i=1;i&lt;=m;i++) dp[i][0]=0;
        for(int i=1;i&lt;=n;i++) dp[0][i]=0;


        for(int i=1;i&lt;=m;i++){
            for(int j=1;j&lt;=n;j++){
                if(text1[i-1]==text2[j-1]) dp[i][j]=1+dp[i-1][j-1];
                else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            }
        }

        for(auto x:dp){
            for(int y:x){
                cout&lt;&lt;y;
            }
            cout&lt;&lt;&#x27;\n&#x27;;
        }
        return dp[m][n];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1155. Number of Dice Rolls With Target Sum
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You have
   <code>
    d
   </code>
   dice and each die has
   <code>
    f
   </code>
   faces numbered
   <code>
    1, 2, ..., f
   </code>
   .
  </p>
  <p>
   Return the number of possible ways (out of
   <code>
    f
    <sup>
     d
    </sup>
   </code>
   total ways)
   <strong>
    modulo
   </strong>
   10
   <sup>
    9
   </sup>
   + 7 to roll the dice so the sum of the face-up numbers equals
   <code>
    target
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> d = 1, f = 6, target = 3
<strong>Output:</strong> 1
<strong>Explanation: </strong>
You throw one die with 6 faces.  There is only one way to get a sum of 3.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> d = 2, f = 6, target = 7
<strong>Output:</strong> 6
<strong>Explanation: </strong>
You throw two dice, each with 6 faces.  There are 6 ways to get a sum of 7:
1+6, 2+5, 3+4, 4+3, 5+2, 6+1.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> d = 2, f = 5, target = 10
<strong>Output:</strong> 1
<strong>Explanation: </strong>
You throw two dice, each with 5 faces.  There is only one way to get a sum of 10: 5+5.
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> d = 1, f = 2, target = 3
<strong>Output:</strong> 0
<strong>Explanation: </strong>
You throw one die with 2 faces.  There is no way to get a sum of 3.
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> d = 30, f = 30, target = 500
<strong>Output:</strong> 222616187
<strong>Explanation: </strong>
The answer must be returned modulo 10^9 + 7.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= d, f &lt;= 30
    </code>
   </li>
   <li>
    <code>
     1 &lt;= target &lt;= 1000
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1155 -->
<pre>/*
 * @lc app=leetcode id=1155 lang=cpp
 *
 * [1155] Number of Dice Rolls With Target Sum
 */

// @lc code=start
class Solution {
public:
    int numRollsToTarget(int n, int f, int target) {
        int m=1000000007;
        vector&lt;vector&lt;int&gt;&gt;dp(n+1,vector&lt;int&gt;(target+1,0));
        dp[0][0]=1;
        for(int i=1; i&lt;=n; i++){
            for(int j=1; j&lt;=target; j++){
                for(int k=1; k&lt;=f;k++){
                    if(k&lt;=j)
                    dp[i][j]+=dp[i-1][j-k];
                    dp[i][j]=dp[i][j]%m;
                }
            }
        }
        return dp[n][target];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1162. As Far from Land as Possible
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an
   <code>
    n x n
   </code>
   <code>
    grid
   </code>
   containing only values
   <code>
    0
   </code>
   and
   <code>
    1
   </code>
   , where
   <code>
    0
   </code>
   represents water and
   <code>
    1
   </code>
   represents land, find a water cell such that its distance to the nearest land cell is maximized, and return the distance. If no land or water exists in the grid, return
   <code>
    -1
   </code>
   .
  </p>
  <p>
   The distance used in this problem is the Manhattan distance: the distance between two cells
   <code>
    (x0, y0)
   </code>
   and
   <code>
    (x1, y1)
   </code>
   is
   <code>
    |x0 - x1| + |y0 - y1|
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/1336_ex1.JPG" style="width: 185px; height: 87px;"/>
  <pre><strong>Input:</strong> grid = [[1,0,1],[0,0,0],[1,0,1]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> The cell (1, 1) is as far as possible from all the land with distance 2.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/1336_ex2.JPG" style="width: 184px; height: 87px;"/>
  <pre><strong>Input:</strong> grid = [[1,0,0],[0,0,0],[0,0,0]]
<strong>Output:</strong> 4
<strong>Explanation:</strong> The cell (2, 2) is as far as possible from all the land with distance 4.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == grid.length
    </code>
   </li>
   <li>
    <code>
     n == grid[i].length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 100
    </code>
   </li>
   <li>
    <code>
     grid[i][j]
    </code>
    is
    <code>
     0
    </code>
    or
    <code>
     1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1162 -->
<pre>/*
 * @lc app=leetcode id=1162 lang=cpp
 *
 * [1162] As Far from Land as Possible
 */

// @lc code=start
class Solution {
public:
    int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        queue&lt;pair&lt;int,int&gt;&gt;q;
        vector&lt;vector&lt;int&gt;&gt;dis{{1,0},{-1,0},{0,1},{0,-1}};
        int n=grid.size();
        int maxx=-1;
        for(int i=0; i&lt;n; i++){
            for(int j=0; j&lt;n; j++){
                if(grid[i][j]==1){
                    for(auto x:dis){
                        int row=i+x[0];
                        int col=j+x[1];
                        if(row&gt;=0 &amp;&amp; col&gt;=0 &amp;&amp; row&lt;n&amp;&amp; col&lt;n &amp;&amp; grid[row][col]==0){
                            grid[row][col]=1+grid[i][j];
                            q.push({row,col});
                            maxx=max(maxx,grid[row][col]-1);
                        }
                    }
                }
            }
        }

        while(!q.empty()){
            int t=q.size();
            for(int k=0;k&lt;t;k++){
                pair&lt;int,int&gt;p=q.front();
                q.pop();
                int i=p.first;
                int j=p.second;
                for(auto x:dis){
                    int row=i+x[0];
                    int col=j+x[1];
                    if(row&gt;=0 &amp;&amp; col&gt;=0 &amp;&amp; row&lt;n&amp;&amp; col&lt;n &amp;&amp; grid[row][col]==0){
                        grid[row][col]=1+grid[i][j];
                        q.push({row,col});
                        maxx=max(maxx,grid[row][col]-1);
                    }
                }

            }
        }

        for(auto x:grid){
            for(int y:x)cout&lt;&lt;y;
            cout&lt;&lt;&#x27;\n&#x27;;
        }

        return maxx;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1218. Longest Arithmetic Subsequence of Given Difference
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an integer array
   <code>
    arr
   </code>
   and an integer
   <code>
    difference
   </code>
   , return the length of the longest subsequence in
   <code>
    arr
   </code>
   which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals
   <code>
    difference
   </code>
   .
  </p>
  <p>
   A
   <strong>
    subsequence
   </strong>
   is a sequence that can be derived from
   <code>
    arr
   </code>
   by deleting some or no elements without changing the order of the remaining elements.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> arr = [1,2,3,4], difference = 1
<strong>Output:</strong> 4
<strong>Explanation: </strong>The longest arithmetic subsequence is [1,2,3,4].</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> arr = [1,3,5,7], difference = 1
<strong>Output:</strong> 1
<strong>Explanation: </strong>The longest arithmetic subsequence is any single element.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> arr = [1,5,7,8,5,3,4,2,1], difference = -2
<strong>Output:</strong> 4
<strong>Explanation: </strong>The longest arithmetic subsequence is [7,5,3,1].
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= arr.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= arr[i], difference &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1218 -->
<pre>/*
 * @lc app=leetcode id=1218 lang=cpp
 *
 * [1218] Longest Arithmetic Subsequence of Given Difference
 */

// @lc code=start
class Solution {
public:
    int longestSubsequence(vector&lt;int&gt;&amp; a, int difference) {
        int n = a.size();
        vector&lt;int&gt;lis(n+1,1);
        int maxi=1;
        map&lt;int,vector&lt;int&gt;&gt;m;
        for(int i=0; i&lt;n; i++){
            for(int j:m[a[i]-difference]){
                lis[i] = max(lis[i],1+lis[j]);
            }
            m[a[i]].push_back(i);
            maxi=max(maxi,lis[i]);
        }
        return maxi;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1238. Circular Permutation in Binary Representation
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given 2 integers
   <code>
    n
   </code>
   and
   <code>
    start
   </code>
   . Your task is return
   <strong>
    any
   </strong>
   permutation
   <code>
    p
   </code>
   of
   <code>
    (0,1,2.....,2^n -1)
   </code>
   such that :
  </p>
  <ul>
   <li>
    <code>
     p[0] = start
    </code>
   </li>
   <li>
    <code>
     p[i]
    </code>
    and
    <code>
     p[i+1]
    </code>
    differ by only one bit in their binary representation.
   </li>
   <li>
    <code>
     p[0]
    </code>
    and
    <code>
     p[2^n -1]
    </code>
    must also differ by only one bit in their binary representation.
   </li>
  </ul>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 2, start = 3
<strong>Output:</strong> [3,2,0,1]
<strong>Explanation:</strong> The binary representation of the permutation is (11,10,00,01). 
All the adjacent element differ by one bit. Another valid permutation is [3,1,0,2]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 3, start = 2
<strong>Output:</strong> [2,6,7,5,4,0,1,3]
<strong>Explanation:</strong> The binary representation of the permutation is (010,110,111,101,100,000,001,011).
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 16
    </code>
   </li>
   <li>
    <code>
     0 &lt;= start &lt; 2 ^ n
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1238 -->
<pre>/*
 * @lc app=leetcode id=1238 lang=cpp
 *
 * [1238] Circular Permutation in Binary Representation
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt;ans;
    vector&lt;int&gt; circularPermutation(int n, int start) {
        int x=0;
        for(int i=0; i&lt;(1&lt;&lt;n); i++){
            int t=i^(i&gt;&gt;1);
            if(t==start) {
                x=i;
                break;
            }
            ans.push_back(t);
        }
    for(int i=(1&lt;&lt;n)-1; i&gt;=x; i--){
        ans.insert(ans.begin(), i^(i&gt;&gt;1));
    }
    return ans;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1240. Tiling a Rectangle with the Fewest Squares
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a rectangle of size
   <code>
    n
   </code>
   x
   <code>
    m
   </code>
   , return
   <em>
    the minimum number of integer-sided squares that tile the rectangle
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <p>
   <img alt="" src="./output_files/sample_11_1592.png" style="width: 154px; height: 106px;"/>
  </p>
  <pre><strong>Input:</strong> n = 2, m = 3
<strong>Output:</strong> 3
<strong>Explanation:</strong> <code>3</code> squares are necessary to cover the rectangle.
<code>2</code> (squares of <code>1x1</code>)
<code>1</code> (square of <code>2x2</code>)</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <p>
   <img alt="" src="./output_files/sample_22_1592.png" style="width: 224px; height: 126px;"/>
  </p>
  <pre><strong>Input:</strong> n = 5, m = 8
<strong>Output:</strong> 5
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <p>
   <img alt="" src="./output_files/sample_33_1592.png" style="width: 224px; height: 189px;"/>
  </p>
  <pre><strong>Input:</strong> n = 11, m = 13
<strong>Output:</strong> 6
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n, m &lt;= 13
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1240 -->
<pre>/*
 * @lc app=leetcode id=1240 lang=cpp
 *
 * [1240] Tiling a Rectangle with the Fewest Squares
 */

// @lc code=start
class Solution {
public:
    int tilingRectangle(int n, int m) {
        if (max(n, m) == 13 &amp;&amp; min(n, m) == 11) return 6;
        vector&lt;vector&lt;long long &gt;&gt;dp(n+1,vector&lt;long long&gt;(m+1,INT_MAX));
        for(int i = 1; i &lt;=n;i++){
            for(int j = 1; j &lt;=m;j++){
                cout&lt;&lt;i&lt;&lt;j&lt;&lt;endl;
                if(i==j){
                    dp[i][j]=1;
                    continue;
                }
                for(int k=1;k&lt;=i;k++){
                    dp[i][j]=min(dp[i][j],dp[i-k][j]+dp[k][j]);
                }
                for(int k=1;k&lt;=j;k++){
                    dp[i][j]=min(dp[i][j],dp[i][j-k]+dp[i][k]);
                }
            }
        }
        return dp[n][m];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1254. Number of Closed Islands
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a 2D
   <code>
    grid
   </code>
   consists of
   <code>
    0s
   </code>
   (land) and
   <code>
    1s
   </code>
   (water).  An
   <em>
    island
   </em>
   is a maximal 4-directionally connected group of
   <code>
    <font face="monospace">
     0
    </font>
    s
   </code>
   and a
   <em>
    closed island
   </em>
   is an island
   <strong>
    totally
   </strong>
   (all left, top, right, bottom) surrounded by
   <code>
    1s.
   </code>
  </p>
  <p>
   Return the number of
   <em>
    closed islands
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <p>
   <img alt="" src="./output_files/sample_3_1610.png" style="width: 240px; height: 120px;"/>
  </p>
  <pre><strong>Input:</strong> grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]
<strong>Output:</strong> 2
<strong>Explanation:</strong> 
Islands in gray are closed because they are completely surrounded by water (group of 1s).</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <p>
   <img alt="" src="./output_files/sample_4_1610.png" style="width: 160px; height: 80px;"/>
  </p>
  <pre><strong>Input:</strong> grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]
<strong>Output:</strong> 1
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> grid = [[1,1,1,1,1,1,1],
               [1,0,0,0,0,0,1],
               [1,0,1,1,1,0,1],
               [1,0,1,0,1,0,1],
               [1,0,1,1,1,0,1],
               [1,0,0,0,0,0,1],
               [1,1,1,1,1,1,1]]
<strong>Output:</strong> 2
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= grid.length, grid[0].length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     0 &lt;= grid[i][j] &lt;=1
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1254 -->
<pre>/*
 * @lc app=leetcode id=1254 lang=cpp
 *
 * [1254] Number of Closed Islands
 */

// @lc code=start
class Solution {
public:
    int count=0;
    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid,int x,int y,int&amp; t){
        if(x&lt;0 || x&gt;=grid.size() || y&lt;0 || y&gt;=grid[0].size()){
            if(t==0){
                t++;
                count++;
            }
            return;
        }
        if(grid[x][y]!=0)return;
        grid[x][y] = 1;
        dfs(grid,x-1,y,t);
        dfs(grid,x+1,y,t);
        dfs(grid,x,y-1,t);
        dfs(grid,x,y+1,t);
    }


    int closedIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int ans =0 ;
        for(int i=0; i&lt;grid.size();i++){
            for(int j=0; j&lt;grid[0].size();j++){
                if(grid[i][j]==0){
                    int t=0;
                    dfs(grid,i,j,t);
                    ans++;
                }
            }
        }
        cout&lt;&lt;count;
        return ans-count;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1262. Greatest Sum Divisible by Three
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array
   <code>
    nums
   </code>
   of integers, we need to find the maximum possible sum of elements of the array such that it is divisible by three.
  </p>
  <ol>
  </ol>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,6,5,1,8]
<strong>Output:</strong> 18
<strong>Explanation:</strong> Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3).</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [4]
<strong>Output:</strong> 0
<strong>Explanation:</strong> Since 4 is not divisible by 3, do not pick any number.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,2,3,4,4]
<strong>Output:</strong> 12
<strong>Explanation:</strong> Pick numbers 1, 3, 4 and 4 their sum is 12 (maximum sum divisible by 3).
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 4 * 10^4
    </code>
   </li>
   <li>
    <code>
     1 &lt;= nums[i] &lt;= 10^4
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1262 -->
<pre>/*
 * @lc app=leetcode id=1262 lang=cpp
 *
 * [1262] Greatest Sum Divisible by Three
 */

// @lc code=start
class Solution {
public:
    int solve(int i,int rem,vector&lt;int&gt;&amp; nums,vector&lt;vector&lt;int&gt;&gt;&amp;dp){
        if(i&gt;=nums.size()){
            if(rem==0) return 0;
            return INT_MIN;
        }
        if(dp[i][rem]!=-1) return dp[i][rem];
        int pick=nums[i]+solve(i+1,(rem+nums[i])%3,nums,dp);
        int nopick=solve(i+1,rem,nums,dp);
        return dp[i][rem]=max(pick,nopick);
    }
    int maxSumDivThree(vector&lt;int&gt;&amp; nums) {
        int n =nums.size();
        vector&lt;vector&lt;int&gt;&gt; dp(n,vector&lt;int&gt;(3,-1));
        return solve(0,0,nums,dp);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1301. Number of Paths with Max Score
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given a square
   <code>
    board
   </code>
   of characters. You can move on the board starting at the bottom right square marked with the character
   <code>
    'S'
   </code>
   .
  </p>
  <p>
   You need to reach the top left square marked with the character
   <code>
    'E'
   </code>
   . The rest of the squares are labeled either with a numeric character
   <code>
    1, 2, ..., 9
   </code>
   or with an obstacle
   <code>
    'X'
   </code>
   . In one move you can go up, left or up-left (diagonally) only if there is no obstacle there.
  </p>
  <p>
   Return a list of two integers: the first integer is the maximum sum of numeric characters you can collect, and the second is the number of such paths that you can take to get that maximum sum,
   <strong>
    taken modulo
    <code>
     10^9 + 7
    </code>
   </strong>
   .
  </p>
  <p>
   In case there is no path, return
   <code>
    [0, 0]
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> board = ["E23","2X2","12S"]
<strong>Output:</strong> [7,1]
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> board = ["E12","1X1","21S"]
<strong>Output:</strong> [4,2]
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> board = ["E11","XXX","11S"]
<strong>Output:</strong> [0,0]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     2 &lt;= board.length == board[i].length &lt;= 100
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1301 -->
<pre>/*
 * @lc app=leetcode id=1301 lang=cpp
 *
 * [1301] Number of Paths with Max Score
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; pathsWithMaxScore(vector&lt;string&gt;&amp; board) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1311. Get Watched Videos by Your Friends
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   There are
   <code>
    n
   </code>
   people, each person has a unique
   <em>
    id
   </em>
   between
   <code>
    0
   </code>
   and
   <code>
    n-1
   </code>
   . Given the arrays
   <code>
    watchedVideos
   </code>
   and
   <code>
    friends
   </code>
   , where
   <code>
    watchedVideos[i]
   </code>
   and
   <code>
    friends[i]
   </code>
   contain the list of watched videos and the list of friends respectively for the person with
   <code>
    id = i
   </code>
   .
  </p>
  <p>
   Level
   <strong>
    1
   </strong>
   of videos are all watched videos by your friends, level
   <strong>
    2
   </strong>
   of videos are all watched videos by the friends of your friends and so on. In general, the level
   <code>
    k
   </code>
   of videos are all watched videos by people with the shortest path
   <strong>
    exactly
   </strong>
   equal to
   <code>
    k
   </code>
   with you. Given your
   <code>
    id
   </code>
   and the
   <code>
    level
   </code>
   of videos, return the list of videos ordered by their frequencies (increasing). For videos with the same frequency order them alphabetically from least to greatest.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <p>
   <strong>
    <img alt="" src="./output_files/leetcode_friends_1.png" style="width: 144px; height: 200px;"/>
   </strong>
  </p>
  <pre><strong>Input:</strong> watchedVideos = [["A","B"],["C"],["B","C"],["D"]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1
<strong>Output:</strong> ["B","C"] 
<strong>Explanation:</strong> 
You have id = 0 (green color in the figure) and your friends are (yellow color in the figure):
Person with id = 1 -&gt; watchedVideos = ["C"] 
Person with id = 2 -&gt; watchedVideos = ["B","C"] 
The frequencies of watchedVideos by your friends are: 
B -&gt; 1 
C -&gt; 2
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <p>
   <strong>
    <img alt="" src="./output_files/leetcode_friends_2.png" style="width: 144px; height: 200px;"/>
   </strong>
  </p>
  <pre><strong>Input:</strong> watchedVideos = [["A","B"],["C"],["B","C"],["D"]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2
<strong>Output:</strong> ["D"]
<strong>Explanation:</strong> 
You have id = 0 (green color in the figure) and the only friend of your friends is the person with id = 3 (yellow color in the figure).
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == watchedVideos.length == friends.length
    </code>
   </li>
   <li>
    <code>
     2 &lt;= n &lt;= 100
    </code>
   </li>
   <li>
    <code>
     1 &lt;= watchedVideos[i].length &lt;= 100
    </code>
   </li>
   <li>
    <code>
     1 &lt;= watchedVideos[i][j].length &lt;= 8
    </code>
   </li>
   <li>
    <code>
     0 &lt;= friends[i].length &lt; n
    </code>
   </li>
   <li>
    <code>
     0 &lt;= friends[i][j] &lt; n
    </code>
   </li>
   <li>
    <code>
     0 &lt;= id &lt; n
    </code>
   </li>
   <li>
    <code>
     1 &lt;= level &lt; n
    </code>
   </li>
   <li>
    if
    <code>
     friends[i]
    </code>
    contains
    <code>
     j
    </code>
    , then
    <code>
     friends[j]
    </code>
    contains
    <code>
     i
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1311 -->
<pre>/*
 * @lc app=leetcode id=1311 lang=cpp
 *
 * [1311] Get Watched Videos by Your Friends
 */

// @lc code=start
class Solution {
public:
    vector&lt;string&gt; watchedVideosByFriends(vector&lt;vector&lt;string&gt;&gt;&amp; watchedVideos, vector&lt;vector&lt;int&gt;&gt;&amp; friends, int id, int level) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1312. Minimum Insertion Steps to Make a String Palindrome
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    s
   </code>
   . In one step you can insert any character at any index of the string.
  </p>
  <p>
   Return
   <em>
    the minimum number of steps
   </em>
   to make
   <code>
    s
   </code>
   palindrome.
  </p>
  <p>
   A
   <b>
    Palindrome String
   </b>
   is one that reads the same backward as well as forward.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "zzazz"
<strong>Output:</strong> 0
<strong>Explanation:</strong> The string "zzazz" is already palindrome we don't need any insertions.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "mbadm"
<strong>Output:</strong> 2
<strong>Explanation:</strong> String can be "mbdadbm" or "mdbabdm".
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "leetcode"
<strong>Output:</strong> 5
<strong>Explanation:</strong> Inserting 5 characters the string becomes "leetcodocteel".
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "g"
<strong>Output:</strong> 0
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "no"
<strong>Output:</strong> 1
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 500
    </code>
   </li>
   <li>
    All characters of
    <code>
     s
    </code>
    are lower case English letters.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1312 -->
<pre>/*
 * @lc app=leetcode id=1312 lang=cpp
 *
 * [1312] Minimum Insertion Steps to Make a String Palindrome
 */

// @lc code=start
class Solution {
public:
    int minInsertions(string s) {
        int m=s.length();
        int n=s.length();
        string t=&quot;&quot;;
        for(int i=0; i&lt;m; i++){
            t=s[i]+t;
        }

        vector&lt;vector&lt;int&gt;&gt;dp(m+1,vector&lt;int&gt;(n+1,0));

        for(int i=1;i&lt;=m;i++) dp[i][0]=0;
        for(int i=1;i&lt;=n;i++) dp[0][i]=0;

        for(int i=1;i&lt;=n;i++){
            for(int j=1;j&lt;=n;j++){
                if(s[i-1]==t[j-1]) dp[i][j] = 1+ dp[i-1][j-1];
                else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
            }
        }
        for(auto x:dp){
            for(int y:x){
                cout&lt;&lt;y;
            }
            cout&lt;&lt;&#x27;\n&#x27;;
        }
        return m-dp[m][n];
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1319. Number of Operations to Make Network Connected
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a string
   <code>
    s
   </code>
   . Return all the words vertically in the same order in which they appear in
   <code>
    s
   </code>
   .
   <br/>
   Words are returned as a list of strings, complete with spaces when is necessary. (Trailing spaces are not allowed).
   <br/>
   Each word would be put on only one column and that in one column there will be only one word.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "HOW ARE YOU"
<strong>Output:</strong> ["HAY","ORO","WEU"]
<strong>Explanation: </strong>Each word is printed vertically. 
 "HAY"
 "ORO"
 "WEU"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "TO BE OR NOT TO BE"
<strong>Output:</strong> ["TBONTB","OEROOE","   T"]
<strong>Explanation: </strong>Trailing spaces is not allowed. 
"TBONTB"
"OEROOE"
"   T"
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> s = "CONTEST IS COMING"
<strong>Output:</strong> ["CIC","OSO","N M","T I","E N","S G","T"]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= s.length &lt;= 200
    </code>
   </li>
   <li>
    <code>
     s
    </code>
    contains only upper case English letters.
   </li>
   <li>
    It's guaranteed that there is only one space between 2 words.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1319 -->
<pre>/*
 * @lc app=leetcode id=1319 lang=cpp
 *
 * [1319] Number of Operations to Make Network Connected
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt;parent;
    int find(int x){
        return x==parent[x]?x:find(parent[x]);
    }
    int makeConnected(int n, vector&lt;vector&lt;int&gt;&gt;&amp; connections) {
        if(connections.size()&lt;n-1) return -1;
        parent.resize(n);
        iota(parent.begin(), parent.end(),0);
        int connected = 0;
        for(auto a:connections){
            int x=find(a[0]);
            int y=find(a[1]);
            if(x!=y){
                parent[y]=x;
            }
        }
        for(int i=0;i&lt;n;i++) if(parent[i]==i) connected++;
        return connected-1;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1333. Filter Restaurants by Vegan-Friendly, Price and Distance
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given the array
   <code>
    restaurants
   </code>
   where
   <code>
    restaurants[i] = [id
    <sub>
     i
    </sub>
    , rating
    <sub>
     i
    </sub>
    , veganFriendly
    <sub>
     i
    </sub>
    , price
    <sub>
     i
    </sub>
    , distance
    <sub>
     i
    </sub>
    ]
   </code>
   . You have to filter the restaurants using three filters.
  </p>
  <p>
   The
   <code>
    veganFriendly
   </code>
   filter will be either
   <em>
    true
   </em>
   (meaning you should only include restaurants with
   <code>
    veganFriendly
    <sub>
     i
    </sub>
   </code>
   set to true) or
   <em>
    false
   </em>
   (meaning you can include any restaurant). In addition, you have the filters
   <code>
    maxPrice
   </code>
   and
   <code>
    maxDistance
   </code>
   which are the maximum value for price and distance of restaurants you should consider respectively.
  </p>
  <p>
   Return the array of restaurant
   <em>
    <strong>
     IDs
    </strong>
   </em>
   after filtering, ordered by
   <strong>
    rating
   </strong>
   from highest to lowest. For restaurants with the same rating, order them by
   <em>
    <strong>
     id
    </strong>
   </em>
   from highest to lowest. For simplicity
   <code>
    veganFriendly
    <sub>
     i
    </sub>
   </code>
   and
   <code>
    veganFriendly
   </code>
   take value
   <em>
    1
   </em>
   when it is
   <em>
    true
   </em>
   , and
   <em>
    0
   </em>
   when it is
   <em>
    false
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10
<strong>Output:</strong> [3,1,5] 
<strong>Explanation: 
</strong>The restaurants are:
Restaurant 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10]
Restaurant 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5]
Restaurant 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4]
Restaurant 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3]
Restaurant 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] 
After filter restaurants with veganFriendly = 1, maxPrice = 50 and maxDistance = 10 we have restaurant 3, restaurant 1 and restaurant 5 (ordered by rating from highest to lowest). 
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 50, maxDistance = 10
<strong>Output:</strong> [4,3,2,1,5]
<strong>Explanation:</strong> The restaurants are the same as in example 1, but in this case the filter veganFriendly = 0, therefore all restaurants are considered.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 30, maxDistance = 3
<strong>Output:</strong> [4,5]
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= restaurants.length &lt;= 10^4
    </code>
   </li>
   <li>
    <code>
     restaurants[i].length == 5
    </code>
   </li>
   <li>
    <code>
     1 &lt;= id
     <sub>
      i
     </sub>
     , rating
     <sub>
      i
     </sub>
     , price
     <sub>
      i
     </sub>
     , distance
     <sub>
      i
     </sub>
     &lt;= 10^5
    </code>
   </li>
   <li>
    <code>
     1 &lt;= maxPrice, maxDistance &lt;= 10^5
    </code>
   </li>
   <li>
    <code>
     veganFriendly
     <sub>
      i
     </sub>
    </code>
    and
    <code>
     veganFriendly
    </code>
    are 0 or 1.
   </li>
   <li>
    All
    <code>
     id
     <sub>
      i
     </sub>
    </code>
    are distinct.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1333 -->
<pre>/*
 * @lc app=leetcode id=1333 lang=cpp
 *
 * [1333] Filter Restaurants by Vegan-Friendly, Price and Distance
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; filterRestaurants(vector&lt;vector&lt;int&gt;&gt;&amp; restaurants, int veganFriendly, int maxPrice, int maxDistance) {
        vector&lt;vector&lt;int&gt;&gt;filtered;
        for(auto x:restaurants){
            if(maxPrice &gt;= x[3] &amp;&amp; maxDistance &gt;= x[4]){
                if(veganFriendly==0 || (veganFriendly==1 &amp;&amp; x[2]==1))
                filtered.push_back(x);
            }
        }
        sort(filtered.begin(), filtered.end(),[](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)-&gt;bool{return a[1]==b[1]?a[0]&gt;b[0]:a[1]&gt;b[1];});
        vector&lt;int&gt;ans;
        for(auto x:filtered)
        {
            ans.push_back(x[0]);
        }
        return ans;
    }

};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   There are
   <code>
    n
   </code>
   cities numbered from
   <code>
    0
   </code>
   to
   <code>
    n-1
   </code>
   . Given the array
   <code>
    edges
   </code>
   where
   <code>
    edges[i] = [from
    <sub>
     i
    </sub>
    , to
    <sub>
     i
    </sub>
    , weight
    <sub>
     i
    </sub>
    ]
   </code>
   represents a bidirectional and weighted edge between cities
   <code>
    from
    <sub>
     i
    </sub>
   </code>
   and
   <code>
    to
    <sub>
     i
    </sub>
   </code>
   , and given the integer
   <code>
    distanceThreshold
   </code>
   .
  </p>
  <p>
   Return the city with the smallest number of cities that are reachable through some path and whose distance is
   <strong>
    at most
   </strong>
   <code>
    distanceThreshold
   </code>
   , If there are multiple such cities, return the city with the greatest number.
  </p>
  <p>
   Notice that the distance of a path connecting cities
   <em>
    <strong>
     i
    </strong>
   </em>
   and
   <em>
    <strong>
     j
    </strong>
   </em>
   is equal to the sum of the edges' weights along that path.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/find_the_city_01.png" style="width: 300px; height: 225px;"/>
  <pre><strong>Input:</strong> n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4
<strong>Output:</strong> 3
<strong>Explanation: </strong>The figure above describes the graph. 
The neighboring cities at a distanceThreshold = 4 for each city are:
City 0 -&gt; [City 1, City 2] 
City 1 -&gt; [City 0, City 2, City 3] 
City 2 -&gt; [City 0, City 1, City 3] 
City 3 -&gt; [City 1, City 2] 
Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/find_the_city_02.png" style="width: 300px; height: 225px;"/>
  <pre><strong>Input:</strong> n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2
<strong>Output:</strong> 0
<strong>Explanation: </strong>The figure above describes the graph. 
The neighboring cities at a distanceThreshold = 2 for each city are:
City 0 -&gt; [City 1] 
City 1 -&gt; [City 0, City 4] 
City 2 -&gt; [City 3, City 4] 
City 3 -&gt; [City 2, City 4]
City 4 -&gt; [City 1, City 2, City 3] 
The city 0 has 1 neighboring city at a distanceThreshold = 2.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     2 &lt;= n &lt;= 100
    </code>
   </li>
   <li>
    <code>
     1 &lt;= edges.length &lt;= n * (n - 1) / 2
    </code>
   </li>
   <li>
    <code>
     edges[i].length == 3
    </code>
   </li>
   <li>
    <code>
     0 &lt;= from
     <sub>
      i
     </sub>
     &lt; to
     <sub>
      i
     </sub>
     &lt; n
    </code>
   </li>
   <li>
    <code>
     1 &lt;= weight
     <sub>
      i
     </sub>
     , distanceThreshold &lt;= 10^4
    </code>
   </li>
   <li>
    All pairs
    <code>
     (from
     <sub>
      i
     </sub>
     , to
     <sub>
      i
     </sub>
     )
    </code>
    are distinct.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1334 -->
<pre>/*
 * @lc app=leetcode id=1334 lang=cpp
 *
 * [1334] Find the City With the Smallest Number of Neighbors at a Threshold Distance
 */

// @lc code=start
class Solution {
public:
    int findTheCity(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int distanceThreshold) {
        int city_count=100000;
        int city=-1;
        for(int k=0; k&lt;n; k++){
        vector&lt;int&gt;dist(n,100000);
        dist[k]=0;
        for(int i=0; i&lt;n; i++){
            vector&lt;int&gt; new_dist=dist;
            for(auto x:edges){
                new_dist[x[1]]=min(dist[x[0]]+x[2],new_dist[x[1]]);
                new_dist[x[0]]=min(dist[x[1]]+x[2],new_dist[x[0]]);
            }
            dist=new_dist;
        }
        int count = -1;
		for (int i = 0; i &lt; n; i++)
		{
			count +=(dist[i]&lt;=distanceThreshold);
		}
        if(city_count&gt;=count){
            city_count=count;
            city=k;
        }
    }
        return city;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1376. Time Needed to Inform All Employees
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   A company has
   <code>
    n
   </code>
   employees with a unique ID for each employee from
   <code>
    0
   </code>
   to
   <code>
    n - 1
   </code>
   . The head of the company is the one with
   <code>
    headID
   </code>
   .
  </p>
  <p>
   Each employee has one direct manager given in the
   <code>
    manager
   </code>
   array where
   <code>
    manager[i]
   </code>
   is the direct manager of the
   <code>
    i-th
   </code>
   employee,
   <code>
    manager[headID] = -1
   </code>
   . Also, it is guaranteed that the subordination relationships have a tree structure.
  </p>
  <p>
   The head of the company wants to inform all the company employees of an urgent piece of news. He will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news.
  </p>
  <p>
   The
   <code>
    i-th
   </code>
   employee needs
   <code>
    informTime[i]
   </code>
   minutes to inform all of his direct subordinates (i.e., After informTime[i] minutes, all his direct subordinates can start spreading the news).
  </p>
  <p>
   Return
   <em>
    the number of minutes
   </em>
   needed to inform all the employees about the urgent news.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 1, headID = 0, manager = [-1], informTime = [0]
<strong>Output:</strong> 0
<strong>Explanation:</strong> The head of the company is the only employee in the company.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/graph(2).png" style="width: 404px; height: 174px;"/>
  <pre><strong>Input:</strong> n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]
<strong>Output:</strong> 1
<strong>Explanation:</strong> The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.
The tree structure of the employees in the company is shown.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <img alt="" src="./output_files/1730_example_3_5.PNG" style="width: 568px; height: 432px;"/>
  <pre><strong>Input:</strong> n = 7, headID = 6, manager = [1,2,3,4,5,6,-1], informTime = [0,6,5,4,3,2,1]
<strong>Output:</strong> 21
<strong>Explanation:</strong> The head has id = 6. He will inform employee with id = 5 in 1 minute.
The employee with id = 5 will inform the employee with id = 4 in 2 minutes.
The employee with id = 4 will inform the employee with id = 3 in 3 minutes.
The employee with id = 3 will inform the employee with id = 2 in 4 minutes.
The employee with id = 2 will inform the employee with id = 1 in 5 minutes.
The employee with id = 1 will inform the employee with id = 0 in 6 minutes.
Needed time = 1 + 2 + 3 + 4 + 5 + 6 = 21.
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 15, headID = 0, manager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6], informTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The first minute the head will inform employees 1 and 2.
The second minute they will inform employees 3, 4, 5 and 6.
The third minute they will inform the rest of employees.
</pre>
  <p>
   <strong>
    Example 5:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 4, headID = 2, manager = [3,3,-1,2], informTime = [0,0,162,914]
<strong>Output:</strong> 1076
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     0 &lt;= headID &lt; n
    </code>
   </li>
   <li>
    <code>
     manager.length == n
    </code>
   </li>
   <li>
    <code>
     0 &lt;= manager[i] &lt; n
    </code>
   </li>
   <li>
    <code>
     manager[headID] == -1
    </code>
   </li>
   <li>
    <code>
     informTime.length == n
    </code>
   </li>
   <li>
    <code>
     0 &lt;= informTime[i] &lt;= 1000
    </code>
   </li>
   <li>
    <code>
     informTime[i] == 0
    </code>
    if employee
    <code>
     i
    </code>
    has no subordinates.
   </li>
   <li>
    It is
    <strong>
     guaranteed
    </strong>
    that all the employees can be informed.
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1376 -->
<pre>/*
 * @lc app=leetcode id=1376 lang=cpp
 *
 * [1376] Time Needed to Inform All Employees
 */

// @lc code=start
class Solution {
public:
    int numOfMinutes(int n, int headID, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1448. Count Good Nodes in Binary Tree
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a binary tree
   <code>
    root
   </code>
   , a node
   <em>
    X
   </em>
   in the tree is named
   <strong>
    good
   </strong>
   if in the path from root to
   <em>
    X
   </em>
   there are no nodes with a value
   <em>
    greater than
   </em>
   X.
  </p>
  <p>
   Return the number of
   <strong>
    good
   </strong>
   nodes in the binary tree.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <p>
   <strong>
    <img alt="" src="./output_files/test_sample_1.png" style="width: 263px; height: 156px;"/>
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [3,1,4,3,null,1,5]
<strong>Output:</strong> 4
<strong>Explanation:</strong> Nodes in blue are <strong>good</strong>.
Root Node (3) is always a good node.
Node 4 -&gt; (3,4) is the maximum value in the path starting from the root.
Node 5 -&gt; (3,4,5) is the maximum value in the path
Node 3 -&gt; (3,1,3) is the maximum value in the path.</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <p>
   <strong>
    <img alt="" src="./output_files/test_sample_2.png" style="width: 157px; height: 161px;"/>
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [3,3,null,4,2]
<strong>Output:</strong> 3
<strong>Explanation:</strong> Node 2 -&gt; (3, 3, 2) is not good, because "3" is higher than it.</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> root = [1]
<strong>Output:</strong> 1
<strong>Explanation:</strong> Root is considered as <strong>good</strong>.</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    The number of nodes in the binary tree is in the range
    <code>
     [1, 10^5]
    </code>
    .
   </li>
   <li>
    Each node's value is between
    <code>
     [-10^4, 10^4]
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1448 -->
<pre>/*
 * @lc app=leetcode id=1448 lang=cpp
 *
 * [1448] Count Good Nodes in Binary Tree
 */

// @lc code=start
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int ans(TreeNode * root,int current_max){
        if(root == NULL) return 0;
        int n;
        if(root-&gt;val &gt;= current_max) n=1;
        else n=0;
        current_max=max(current_max,root-&gt;val);
        return n + ans(root-&gt;left,current_max) +ans(root-&gt;right,current_max) ;
    }
    int goodNodes(TreeNode* root) {
        int current_max=INT_MIN;
        return ans(root,current_max);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1498. Number of Subsequences That Satisfy the Given Sum Condition
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given an array of integers
   <code>
    nums
   </code>
   and an integer
   <code>
    target
   </code>
   .
  </p>
  <p>
   Return the number of
   <strong>
    non-empty
   </strong>
   subsequences of
   <code>
    nums
   </code>
   such that the sum of the minimum and maximum element on it is less or equal to
   <code>
    target
   </code>
   . Since the answer may be too large, return it modulo
   <code>
    10
    <sup>
     9
    </sup>
    + 7
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,5,6,7], target = 9
<strong>Output:</strong> 4
<strong>Explanation: </strong>There are 4 subsequences that satisfy the condition.
[3] -&gt; Min value + max value &lt;= target (3 + 3 &lt;= 9)
[3,5] -&gt; (3 + 5 &lt;= 9)
[3,5,6] -&gt; (3 + 6 &lt;= 9)
[3,6] -&gt; (3 + 6 &lt;= 9)
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,3,6,8], target = 10
<strong>Output:</strong> 6
<strong>Explanation: </strong>There are 6 subsequences that satisfy the condition. (nums can have repeated numbers).
[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [2,3,3,4,6,7], target = 12
<strong>Output:</strong> 61
<strong>Explanation: </strong>There are 63 non-empty subsequences, two of them don't satisfy the condition ([6,7], [7]).
Number of valid subsequences (63 - 2 = 61).
</pre>
  <p>
   <strong>
    Example 4:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [5,2,4,1,7,6,8], target = 16
<strong>Output:</strong> 127
<strong>Explanation: </strong>All non-empty subset satisfy the condition (2^7 - 1) = 127</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     1 &lt;= nums[i] &lt;= 10
     <sup>
      6
     </sup>
    </code>
   </li>
   <li>
    <code>
     1 &lt;= target &lt;= 10
     <sup>
      6
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1498 -->
<pre>/*
 * @lc app=leetcode id=1498 lang=cpp
 *
 * [1498] Number of Subsequences That Satisfy the Given Sum Condition
 */

// @lc code=start
class Solution {
public:
    int numSubseq(vector&lt;int&gt;&amp; nums, int target) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1547. Minimum Cost to Cut a Stick
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   Given a wooden stick of length
   <code>
    n
   </code>
   units. The stick is labelled from
   <code>
    0
   </code>
   to
   <code>
    n
   </code>
   . For example, a stick of length
   <strong>
    6
   </strong>
   is labelled as follows:
  </p>
  <img alt="" src="./output_files/statement.jpg" style="width: 521px; height: 111px;"/>
  <p>
   Given an integer array
   <code>
    cuts
   </code>
   where
   <code>
    cuts[i]
   </code>
   denotes a position you should perform a cut at.
  </p>
  <p>
   You should perform the cuts in order, you can change the order of the cuts as you wish.
  </p>
  <p>
   The cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.
  </p>
  <p>
   Return
   <em>
    the minimum total cost
   </em>
   of the cuts.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/e1(10).jpg" style="width: 350px; height: 284px;"/>
  <pre><strong>Input:</strong> n = 7, cuts = [1,3,4,5]
<strong>Output:</strong> 16
<strong>Explanation:</strong> Using cuts order = [1, 3, 4, 5] as in the input leads to the following scenario:
<img alt="" src="./output_files/e11.jpg" style="width: 350px; height: 284px;"/>
The first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.
Rearranging the cuts to be [3, 5, 1, 4] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 9, cuts = [5,6,1,4,2]
<strong>Output:</strong> 22
<strong>Explanation:</strong> If you try the given cuts ordering the cost will be 25.
There are much ordering with total cost &lt;= 25, for example, the order [4, 6, 5, 2, 1] has total cost = 22 which is the minimum possible.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     2 &lt;= n &lt;= 10^6
    </code>
   </li>
   <li>
    <code>
     1 &lt;= cuts.length &lt;= min(n - 1, 100)
    </code>
   </li>
   <li>
    <code>
     1 &lt;= cuts[i] &lt;= n - 1
    </code>
   </li>
   <li>
    All the integers in
    <code>
     cuts
    </code>
    array are
    <strong>
     distinct
    </strong>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1547 -->
<pre>/*
 * @lc app=leetcode id=1547 lang=cpp
 *
 * [1547] Minimum Cost to Cut a Stick
 */

// @lc code=start
class Solution {
public:
    int minCost(int n, vector&lt;int&gt;&amp; cuts) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1659. Maximize Grid Happiness
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given four integers,
   <code>
    m
   </code>
   ,
   <code>
    n
   </code>
   ,
   <code>
    introvertsCount
   </code>
   , and
   <code>
    extrovertsCount
   </code>
   . You have an
   <code>
    m x n
   </code>
   grid, and there are two types of people: introverts and extroverts. There are
   <code>
    introvertsCount
   </code>
   introverts and
   <code>
    extrovertsCount
   </code>
   extroverts.
  </p>
  <p>
   You should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you
   <strong>
    do not
   </strong>
   have to have all the people living in the grid.
  </p>
  <p>
   The
   <strong>
    happiness
   </strong>
   of each person is calculated as follows:
  </p>
  <ul>
   <li>
    Introverts
    <strong>
     start
    </strong>
    with
    <code>
     120
    </code>
    happiness and
    <strong>
     lose
    </strong>
    <code>
     30
    </code>
    happiness for each neighbor (introvert or extrovert).
   </li>
   <li>
    Extroverts
    <strong>
     start
    </strong>
    with
    <code>
     40
    </code>
    happiness and
    <strong>
     gain
    </strong>
    <code>
     20
    </code>
    happiness for each neighbor (introvert or extrovert).
   </li>
  </ul>
  <p>
   Neighbors live in the directly adjacent cells north, east, south, and west of a person's cell.
  </p>
  <p>
   The
   <strong>
    grid happiness
   </strong>
   is the
   <strong>
    sum
   </strong>
   of each person's happiness. Return
   <em>
    the
    <strong>
     maximum possible grid happiness
    </strong>
    .
   </em>
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/grid_happiness.png" style="width: 261px; height: 121px;"/>
  <pre><strong>Input:</strong> m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2
<strong>Output:</strong> 240
<strong>Explanation:</strong> Assume the grid is 1-indexed with coordinates (row, column).
We can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3).
- Introvert at (1,1) happiness: 120 (starting happiness) - (0 * 30) (0 neighbors) = 120
- Extrovert at (1,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60
- Extrovert at (2,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60
The grid happiness is 120 + 60 + 60 = 240.
The above figure shows the grid in this example with each person's happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1
<strong>Output:</strong> 260
<strong>Explanation:</strong> Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1).
- Introvert at (1,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90
- Extrovert at (2,1) happiness: 40 (starting happiness) + (2 * 20) (2 neighbors) = 80
- Introvert at (3,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90
The grid happiness is 90 + 80 + 90 = 260.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0
<strong>Output:</strong> 240
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= m, n &lt;= 5
    </code>
   </li>
   <li>
    <code>
     0 &lt;= introvertsCount, extrovertsCount &lt;= min(m * n, 6)
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1659 -->
<pre>/*
 * @lc app=leetcode id=1659 lang=cpp
 *
 * [1659] Maximize Grid Happiness
 */

// @lc code=start
class Solution {
public:
    int getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1863. Sum of All Subset XOR Totals
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   The
   <strong>
    XOR total
   </strong>
   of an array is defined as the bitwise
   <code>
    XOR
   </code>
   of
   <strong>
    all its elements
   </strong>
   , or
   <code>
    0
   </code>
   if the array is
   <strong>
    empty
   </strong>
   .
  </p>
  <ul>
   <li>
    For example, the
    <strong>
     XOR total
    </strong>
    of the array
    <code>
     [2,5,6]
    </code>
    is
    <code>
     2 XOR 5 XOR 6 = 1
    </code>
    .
   </li>
  </ul>
  <p>
   Given an array
   <code>
    nums
   </code>
   , return
   <em>
    the
    <strong>
     sum
    </strong>
    of all
    <strong>
     XOR totals
    </strong>
    for every
    <strong>
     subset
    </strong>
    of
   </em>
   <code>
    nums
   </code>
   .
  </p>
  <p>
   <strong>
    Note:
   </strong>
   Subsets with the
   <strong>
    same
   </strong>
   elements should be counted
   <strong>
    multiple
   </strong>
   times.
  </p>
  <p>
   An array
   <code>
    a
   </code>
   is a
   <strong>
    subset
   </strong>
   of an array
   <code>
    b
   </code>
   if
   <code>
    a
   </code>
   can be obtained from
   <code>
    b
   </code>
   by deleting some (possibly zero) elements of
   <code>
    b
   </code>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [1,3]
<strong>Output:</strong> 6
<strong>Explanation: </strong>The 4 subsets of [1,3] are:
- The empty subset has an XOR total of 0.
- [1] has an XOR total of 1.
- [3] has an XOR total of 3.
- [1,3] has an XOR total of 1 XOR 3 = 2.
0 + 1 + 3 + 2 = 6
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [5,1,6]
<strong>Output:</strong> 28
<strong>Explanation: </strong>The 8 subsets of [5,1,6] are:
- The empty subset has an XOR total of 0.
- [5] has an XOR total of 5.
- [1] has an XOR total of 1.
- [6] has an XOR total of 6.
- [5,1] has an XOR total of 5 XOR 1 = 4.
- [5,6] has an XOR total of 5 XOR 6 = 3.
- [1,6] has an XOR total of 1 XOR 6 = 7.
- [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.
0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,4,5,6,7,8]
<strong>Output:</strong> 480
<strong>Explanation:</strong> The sum of all XOR totals for every subset is 480.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= nums.length &lt;= 12
    </code>
   </li>
   <li>
    <code>
     1 &lt;= nums[i] &lt;= 20
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1863 -->
<pre>/*
 * @lc app=leetcode id=1863 lang=cpp
 *
 * [1863] Sum of All Subset XOR Totals
 */

// @lc code=start
class Solution {
public:
    int subsetXORSum(vector&lt;int&gt;&amp; nums) {
        int bits=0;
        for(int i=0;i&lt;nums.size();i++)
        {
            bits=bits|nums[i];
        }
        return bits*pow(2,nums.size()-1);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1877. Minimize Maximum Pair Sum in Array
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   The
   <strong>
    pair sum
   </strong>
   of a pair
   <code>
    (a,b)
   </code>
   is equal to
   <code>
    a + b
   </code>
   . The
   <strong>
    maximum pair sum
   </strong>
   is the largest
   <strong>
    pair sum
   </strong>
   in a list of pairs.
  </p>
  <ul>
   <li>
    For example, if we have pairs
    <code>
     (1,5)
    </code>
    ,
    <code>
     (2,3)
    </code>
    , and
    <code>
     (4,4)
    </code>
    , the
    <strong>
     maximum pair sum
    </strong>
    would be
    <code>
     max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8
    </code>
    .
   </li>
  </ul>
  <p>
   Given an array
   <code>
    nums
   </code>
   of
   <strong>
    even
   </strong>
   length
   <code>
    n
   </code>
   , pair up the elements of
   <code>
    nums
   </code>
   into
   <code>
    n / 2
   </code>
   pairs such that:
  </p>
  <ul>
   <li>
    Each element of
    <code>
     nums
    </code>
    is in
    <strong>
     exactly one
    </strong>
    pair, and
   </li>
   <li>
    The
    <strong>
     maximum pair sum
    </strong>
    is
    <strong>
     minimized
    </strong>
    .
   </li>
  </ul>
  <p>
   Return
   <em>
    the minimized
    <strong>
     maximum pair sum
    </strong>
    after optimally pairing up the elements
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,5,2,3]
<strong>Output:</strong> 7
<strong>Explanation:</strong> The elements can be paired up into pairs (3,3) and (5,2).
The maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [3,5,4,2,4,6]
<strong>Output:</strong> 8
<strong>Explanation:</strong> The elements can be paired up into pairs (3,5), (4,4), and (6,2).
The maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == nums.length
    </code>
   </li>
   <li>
    <code>
     2 &lt;= n &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     n
    </code>
    is
    <strong>
     even
    </strong>
    .
   </li>
   <li>
    <code>
     1 &lt;= nums[i] &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1877 -->
<pre>/*
 * @lc app=leetcode id=1877 lang=cpp
 *
 * [1877] Minimize Maximum Pair Sum in Array
 */

// @lc code=start
class Solution {
public:
    int minPairSum(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());
        int maxx=INT_MIN;
        int start=0,end=nums.size()-1;
        while(start&lt;=end){
            maxx=max(maxx,nums[start]+nums[end]);
            start++;
            end--;
        }
        return maxx;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1879. Minimum XOR Sum of Two Arrays
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given two integer arrays
   <code>
    nums1
   </code>
   and
   <code>
    nums2
   </code>
   of length
   <code>
    n
   </code>
   .
  </p>
  <p>
   The
   <strong>
    XOR sum
   </strong>
   of the two integer arrays is
   <code>
    (nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1])
   </code>
   (
   <strong>
    0-indexed
   </strong>
   ).
  </p>
  <ul>
   <li>
    For example, the
    <strong>
     XOR sum
    </strong>
    of
    <code>
     [1,2,3]
    </code>
    and
    <code>
     [3,2,1]
    </code>
    is equal to
    <code>
     (1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4
    </code>
    .
   </li>
  </ul>
  <p>
   Rearrange the elements of
   <code>
    nums2
   </code>
   such that the resulting
   <strong>
    XOR sum
   </strong>
   is
   <b>
    minimized
   </b>
   .
  </p>
  <p>
   Return
   <em>
    the
    <strong>
     XOR sum
    </strong>
    after the rearrangement
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums1 = [1,2], nums2 = [2,3]
<strong>Output:</strong> 2
<b>Explanation:</b> Rearrange <code>nums2</code> so that it becomes <code>[3,2]</code>.
The XOR sum is (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2.</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums1 = [1,0,3], nums2 = [5,3,4]
<strong>Output:</strong> 8
<b>Explanation:</b> Rearrange <code>nums2</code> so that it becomes <code>[5,4,3]</code>. 
The XOR sum is (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == nums1.length
    </code>
   </li>
   <li>
    <code>
     n == nums2.length
    </code>
   </li>
   <li>
    <code>
     1 &lt;= n &lt;= 14
    </code>
   </li>
   <li>
    <code>
     0 &lt;= nums1[i], nums2[i] &lt;= 10
     <sup>
      7
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1879 -->
<pre>/*
 * @lc app=leetcode id=1879 lang=cpp
 *
 * [1879] Minimum XOR Sum of Two Arrays
 */

// @lc code=start
class Solution {
public:

    int dfs(int mask,int index,vector&lt;int&gt;nums1,vector&lt;int&gt;nums2,vector&lt;vector&lt;int&gt;&gt;&amp;dp){
        if(index&gt;=nums1.size()) return 0;
        if(dp[index][mask]!=-1) return dp[index][mask];
        int ans=INT_MAX;
        for(int i=0;i&lt;nums2.size();i++){
            if(!(mask&amp;(1&lt;&lt;i))){
                ans=min(ans,(nums1[index]^nums2[i]) + dfs(mask|(1&lt;&lt;i),index+1,nums1,nums2,dp));
            }
        }
        return dp[index][mask]=ans;
    }
    int minimumXORSum(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        int n=nums1.size();
        vector&lt;vector&lt;int&gt;&gt;dp(n+1,vector&lt;int&gt;(1&lt;&lt;n,-1));
        return dfs(0,0,nums1,nums2,dp);
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1915. Number of Wonderful Substrings
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   A
   <strong>
    wonderful
   </strong>
   string is a string where
   <strong>
    at most one
   </strong>
   letter appears an
   <strong>
    odd
   </strong>
   number of times.
  </p>
  <ul>
   <li>
    For example,
    <code>
     "ccjjc"
    </code>
    and
    <code>
     "abab"
    </code>
    are wonderful, but
    <code>
     "ab"
    </code>
    is not.
   </li>
  </ul>
  <p>
   Given a string
   <code>
    word
   </code>
   that consists of the first ten lowercase English letters (
   <code>
    'a'
   </code>
   through
   <code>
    'j'
   </code>
   ), return
   <em>
    the
    <strong>
     number of wonderful non-empty substrings
    </strong>
    in
   </em>
   <code>
    word
   </code>
   <em>
    . If the same substring appears multiple times in
   </em>
   <code>
    word
   </code>
   <em>
    , then count
    <strong>
     each occurrence
    </strong>
    separately.
   </em>
  </p>
  <p>
   A
   <strong>
    substring
   </strong>
   is a contiguous sequence of characters in a string.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> word = "aba"
<strong>Output:</strong> 4
<strong>Explanation:</strong> The four wonderful substrings are underlined below:
- "<u><strong>a</strong></u>ba" -&gt; "a"
- "a<u><strong>b</strong></u>a" -&gt; "b"
- "ab<u><strong>a</strong></u>" -&gt; "a"
- "<u><strong>aba</strong></u>" -&gt; "aba"
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> word = "aabb"
<strong>Output:</strong> 9
<strong>Explanation:</strong> The nine wonderful substrings are underlined below:
- "<strong><u>a</u></strong>abb" -&gt; "a"
- "<u><strong>aa</strong></u>bb" -&gt; "aa"
- "<u><strong>aab</strong></u>b" -&gt; "aab"
- "<u><strong>aabb</strong></u>" -&gt; "aabb"
- "a<u><strong>a</strong></u>bb" -&gt; "a"
- "a<u><strong>abb</strong></u>" -&gt; "abb"
- "aa<u><strong>b</strong></u>b" -&gt; "b"
- "aa<u><strong>bb</strong></u>" -&gt; "bb"
- "aab<u><strong>b</strong></u>" -&gt; "b"
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> word = "he"
<strong>Output:</strong> 2
<strong>Explanation:</strong> The two wonderful substrings are underlined below:
- "<b><u>h</u></b>e" -&gt; "h"
- "h<strong><u>e</u></strong>" -&gt; "e"
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= word.length &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     word
    </code>
    consists of lowercase English letters from
    <code>
     'a'
    </code>
    to
    <code>
     'j'
    </code>
    .
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1915 -->
<pre>/*
 * @lc app=leetcode id=1915 lang=cpp
 *
 * [1915] Number of Wonderful Substrings
 */

// @lc code=start
class Solution {
public:
    long long wonderfulSubstrings(string word) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 1982. Find Array Given Subset Sums
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an integer
   <code>
    n
   </code>
   representing the length of an unknown array that you are trying to recover. You are also given an array
   <code>
    sums
   </code>
   containing the values of all
   <code>
    2
    <sup>
     n
    </sup>
   </code>
   <strong>
    subset sums
   </strong>
   of the unknown array (in no particular order).
  </p>
  <p>
   Return
   <em>
    the array
   </em>
   <code>
    ans
   </code>
   <em>
    of length
   </em>
   <code>
    n
   </code>
   <em>
    representing the unknown array. If
    <strong>
     multiple
    </strong>
    answers exist, return
    <strong>
     any
    </strong>
    of them
   </em>
   .
  </p>
  <p>
   An array
   <code>
    sub
   </code>
   is a
   <strong>
    subset
   </strong>
   of an array
   <code>
    arr
   </code>
   if
   <code>
    sub
   </code>
   can be obtained from
   <code>
    arr
   </code>
   by deleting some (possibly zero or all) elements of
   <code>
    arr
   </code>
   . The sum of the elements in
   <code>
    sub
   </code>
   is one possible
   <strong>
    subset sum
   </strong>
   of
   <code>
    arr
   </code>
   . The sum of an empty array is considered to be
   <code>
    0
   </code>
   .
  </p>
  <p>
   <strong>
    Note:
   </strong>
   Test cases are generated such that there will
   <strong>
    always
   </strong>
   be at least one correct answer.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 3, sums = [-3,-2,-1,0,0,1,2,3]
<strong>Output:</strong> [1,2,-3]
<strong>Explanation: </strong>[1,2,-3] is able to achieve the given subset sums:
- []: sum is 0
- [1]: sum is 1
- [2]: sum is 2
- [1,2]: sum is 3
- [-3]: sum is -3
- [1,-3]: sum is -2
- [2,-3]: sum is -1
- [1,2,-3]: sum is 0
Note that any permutation of [1,2,-3] and also any permutation of [-1,-2,3] will also be accepted.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 2, sums = [0,0,0,0]
<strong>Output:</strong> [0,0]
<strong>Explanation:</strong> The only correct answer is [0,0].
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <pre><strong>Input:</strong> n = 4, sums = [0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8]
<strong>Output:</strong> [0,-1,4,5]
<strong>Explanation:</strong> [0,-1,4,5] is able to achieve the given subset sums.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 15
    </code>
   </li>
   <li>
    <code>
     sums.length == 2
     <sup>
      n
     </sup>
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      4
     </sup>
     &lt;= sums[i] &lt;= 10
     <sup>
      4
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 1982 -->
<pre>/*
 * @lc app=leetcode id=1982 lang=cpp
 *
 * [1982] Find Array Given Subset Sums
 */

// @lc code=start
class Solution {
public:
    vector&lt;int&gt; recoverArray(int n, vector&lt;int&gt;&amp; sums) {
        
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 2035. Partition Array Into Two Arrays to Minimize Sum Difference
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given an integer array
   <code>
    nums
   </code>
   of
   <code>
    2 * n
   </code>
   integers. You need to partition
   <code>
    nums
   </code>
   into
   <strong>
    two
   </strong>
   arrays of length
   <code>
    n
   </code>
   to
   <strong>
    minimize the absolute difference
   </strong>
   of the
   <strong>
    sums
   </strong>
   of the arrays. To partition
   <code>
    nums
   </code>
   , put each element of
   <code>
    nums
   </code>
   into
   <strong>
    one
   </strong>
   of the two arrays.
  </p>
  <p>
   Return
   <em>
    the
    <strong>
     minimum
    </strong>
    possible absolute difference
   </em>
   .
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="example-1" src="./output_files/ex1(15).png" style="width: 240px; height: 106px;"/>
  <pre><strong>Input:</strong> nums = [3,9,7,3]
<strong>Output:</strong> 2
<strong>Explanation:</strong> One optimal partition is: [3,9] and [7,3].
The absolute difference between the sums of the arrays is abs((3 + 9) - (7 + 3)) = 2.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <pre><strong>Input:</strong> nums = [-36,36]
<strong>Output:</strong> 72
<strong>Explanation:</strong> One optimal partition is: [-36] and [36].
The absolute difference between the sums of the arrays is abs((-36) - (36)) = 72.
</pre>
  <p>
   <strong>
    Example 3:
   </strong>
  </p>
  <img alt="example-3" src="./output_files/ex3(5).png" style="width: 316px; height: 106px;"/>
  <pre><strong>Input:</strong> nums = [2,-1,0,4,-2,-9]
<strong>Output:</strong> 0
<strong>Explanation:</strong> One optimal partition is: [2,4,-9] and [-1,0,-2].
The absolute difference between the sums of the arrays is abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     1 &lt;= n &lt;= 15
    </code>
   </li>
   <li>
    <code>
     nums.length == 2 * n
    </code>
   </li>
   <li>
    <code>
     -10
     <sup>
      7
     </sup>
     &lt;= nums[i] &lt;= 10
     <sup>
      7
     </sup>
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 2035 -->
<pre>/*
 * @lc app=leetcode id=2035 lang=cpp
 *
 * [2035] Partition Array Into Two Arrays to Minimize Sum Difference
 */

// @lc code=start
class Solution {
public:
    int minimumDifference(vector&lt;int&gt;&amp; nums) {
        int n=nums.size();
        vector&lt;int&gt;dp(1&lt;&lt;n,0);
        int x=INT_MAX;
        int sum=0;
        for(int i=0; i&lt;n; i++) sum+=nums[i];
        for(int mask=0; mask&lt; (1&lt;&lt;n)-1; mask++){
            for(int i=0; i&lt;n; i++){
                if(!(mask&amp;(1&lt;&lt;i))){
                    dp[mask|(1&lt;&lt;i)]=dp[mask]+nums[i];
                }
            }
        }
        for(int i=1; i&lt; (1&lt;&lt;n)-1;i++){
            x=min(x,abs(2*dp[i]-sum));
            cout&lt;&lt;dp[i]&lt;&lt;&#x27; &#x27;&lt;&lt;x&lt;&lt;&#x27;\n&#x27;;
        }
        return x;
    }
};
// @lc code=end

</pre><html><head></head><body>
<div id="title">
 2360. Longest Cycle in a Graph
</div>
<div class="content__u3I1 question-content__JfgR">
 <div>
  <p>
   You are given a
   <strong>
    directed
   </strong>
   graph of
   <code>
    n
   </code>
   nodes numbered from
   <code>
    0
   </code>
   to
   <code>
    n - 1
   </code>
   , where each node has
   <strong>
    at most one
   </strong>
   outgoing edge.
  </p>
  <p>
   The graph is represented with a given
   <strong>
    0-indexed
   </strong>
   array
   <code>
    edges
   </code>
   of size
   <code>
    n
   </code>
   , indicating that there is a directed edge from node
   <code>
    i
   </code>
   to node
   <code>
    edges[i]
   </code>
   . If there is no outgoing edge from node
   <code>
    i
   </code>
   , then
   <code>
    edges[i] == -1
   </code>
   .
  </p>
  <p>
   Return
   <em>
    the length of the
    <strong>
     longest
    </strong>
    cycle in the graph
   </em>
   . If no cycle exists, return
   <code>
    -1
   </code>
   .
  </p>
  <p>
   A cycle is a path that starts and ends at the
   <strong>
    same
   </strong>
   node.
  </p>
  <p>
  </p>
  <p>
   <strong>
    Example 1:
   </strong>
  </p>
  <img alt="" src="./output_files/graph4drawio-5.png" style="width: 335px; height: 191px;"/>
  <pre><strong>Input:</strong> edges = [3,3,4,2,3]
<strong>Output:</strong> 3
<strong>Explanation:</strong> The longest cycle in the graph is the cycle: 2 -&gt; 4 -&gt; 3 -&gt; 2.
The length of this cycle is 3, so 3 is returned.
</pre>
  <p>
   <strong>
    Example 2:
   </strong>
  </p>
  <img alt="" src="./output_files/graph4drawio-1.png" style="width: 171px; height: 161px;"/>
  <pre><strong>Input:</strong> edges = [2,-1,3,1]
<strong>Output:</strong> -1
<strong>Explanation:</strong> There are no cycles in this graph.
</pre>
  <p>
  </p>
  <p>
   <strong>
    Constraints:
   </strong>
  </p>
  <ul>
   <li>
    <code>
     n == edges.length
    </code>
   </li>
   <li>
    <code>
     2 &lt;= n &lt;= 10
     <sup>
      5
     </sup>
    </code>
   </li>
   <li>
    <code>
     -1 &lt;= edges[i] &lt; n
    </code>
   </li>
   <li>
    <code>
     edges[i] != i
    </code>
   </li>
  </ul>
 </div>
</div>
</body></html>
<!-- Solution for Question 2360 -->
<pre>/*
 * @lc app=leetcode id=2360 lang=cpp
 *
 * [2360] Longest Cycle in a Graph
 */

// @lc code=start
class Solution {
public:
    int longestCycle(vector&lt;int&gt;&amp; edges) {
        
    }
};
// @lc code=end

</pre></body>
</html>
